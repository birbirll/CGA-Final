"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(assignment)/assignment/A2a/page",{

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A2a/fragment.glsl":
/*!***********************************************************!*\
  !*** ./src/app/(assignment)/assignment/A2a/fragment.glsl ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"precision highp float;\\n#define GLSLIFY 1\\n              //// set default precision of float variables to high precision\\n\\nvarying vec2 vUv;                   //// screen uv coordinates (varying, from vertex shader)\\nuniform vec2 iResolution;           //// screen resolution (uniform, from CPU)\\nuniform float iTime;                //// time elapsed (uniform, from CPU)\\n\\n// noise\\n// Volume raycasting by XT95\\n// https://www.shadertoy.com/view/lss3zr\\nmat3 m = mat3( 0.00,  0.80,  0.60,\\n              -0.80,  0.36, -0.48,\\n              -0.60, -0.48,  0.64 );\\nfloat hash( float n )\\n{\\n    return fract(sin(n)*43758.5453);\\n}\\n\\nfloat noise( in vec3 x )\\n{\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\n    f = f*f*(3.0-2.0*f);\\n\\n    float n = p.x + p.y*57.0 + 113.0*p.z;\\n\\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\\n    return res;\\n}\\n\\nfloat fbm( vec3 p )\\n{\\n    float f;\\n    f  = 0.5000*noise( p ); p = m*p*2.02;\\n    f += 0.2500*noise( p ); p = m*p*2.03;\\n    f += 0.12500*noise( p ); p = m*p*2.01;\\n    f += 0.06250*noise( p );\\n    return f;\\n}\\n/////////////////////////////////////\\n\\nfloat stepUp(float t, float len, float smo)\\n{\\n  float tt = mod(t += smo, len);\\n  float stp = floor(t / len) - 1.0;\\n  return smoothstep(0.0, smo, tt) + stp;\\n}\\n\\n// iq's smin\\nfloat smin( float d1, float d2, float k ) {\\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\\n\\nfloat sdTorus( vec3 p, vec2 t )\\n{\\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\\n  return length(q)-t.y;\\n}\\n\\nfloat map( in vec3 p )\\n{\\n    p *= 2.0;\\n\\tvec3 q = p - vec3(0.0,0.5,1.0)*iTime;\\n    float f = fbm(q);\\n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\\n\\n\\treturn min(max(0.0, torus), 1.0);\\n}\\n\\nfloat jitter;\\n\\n#define MAX_STEPS 48\\n#define SHADOW_STEPS 8\\n#define VOLUME_LENGTH 15.\\n#define SHADOW_LENGTH 2.\\n\\n// Reference\\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\\nvec4 cloudMarch(vec3 p, vec3 ray)\\n{\\n    float density = 0.;\\n\\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\\n\\n    vec4 sum = vec4(0., 0., 0., 1.);\\n    \\n    vec3 pos = p + ray * jitter * stepLength;\\n    \\n    for (int i = 0; i < MAX_STEPS; i++)\\n    {\\n        if (sum.a < 0.1) {\\n        \\tbreak;\\n        }\\n        float d = map(pos);\\n    \\n        if( d > 0.001)\\n        {\\n            vec3 lpos = pos + light * jitter * shadowStepLength;\\n            float shadow = 0.;\\n    \\n            for (int s = 0; s < SHADOW_STEPS; s++)\\n            {\\n                lpos += light * shadowStepLength;\\n                float lsample = map(lpos);\\n                shadow += lsample;\\n            }\\n    \\n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\\n            sum.a *= 1.-density;\\n\\n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\\n        }\\n        pos += ray * stepLength;\\n    }\\n\\n    return sum;\\n}\\n\\nmat3 camera(vec3 ro, vec3 ta, float cr )\\n{\\n\\tvec3 cw = normalize(ta - ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\\n    jitter = hash(p.x + p.y * 57.0 + iTime);\\n    vec3 ro = vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0);\\n    vec3 ta = vec3(0.0, 1., 0.0);\\n    mat3 c = camera(ro, ta, 0.0);\\n    vec3 ray = c * normalize(vec3(p, 1.75));\\n    vec4 col = cloudMarch(ro, ray);\\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\\n    \\n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\\n\\n    result = pow(result, vec3(1.0/2.2));\\n    \\n    fragColor = vec4(result,1.0);\\n}\\n\\nvoid main() {\\n    vec4 fragColor;\\n    mainImage(fragColor, vUv * iResolution.xy);\\n    gl_FragColor = fragColor;\\n}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTJhL2ZyYWdtZW50Lmdsc2wiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLHVCQUF1QiwwSUFBMEksOEZBQThGLGdGQUFnRix1T0FBdU8sMEJBQTBCLHNDQUFzQyxHQUFHLCtCQUErQix3QkFBd0Isd0JBQXdCLDRCQUE0Qiw2Q0FBNkMscVJBQXFSLGlCQUFpQixHQUFHLDBCQUEwQixjQUFjLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLCtCQUErQixhQUFhLDhCQUE4QixlQUFlLEdBQUcseUZBQXlGLGtDQUFrQyxxQ0FBcUMsMENBQTBDLEdBQUcsNkRBQTZELHVEQUF1RCw4Q0FBOEMsc0NBQXNDLHdDQUF3Qyx5QkFBeUIsR0FBRyw2QkFBNkIsZUFBZSx5Q0FBeUMsdUJBQXVCLHNFQUFzRSx1Q0FBdUMsR0FBRyxpQkFBaUIsMk5BQTJOLHlCQUF5Qiw0REFBNEQsbUVBQW1FLGtEQUFrRCx3Q0FBd0MscURBQXFELDRCQUE0QixlQUFlLFdBQVcsNEJBQTRCLGtCQUFrQixXQUFXLDZCQUE2Qix5Q0FBeUMsa0VBQWtFLGdDQUFnQyxvQ0FBb0Msa0JBQWtCLG1CQUFtQixtREFBbUQsNENBQTRDLG9DQUFvQyxlQUFlLDZFQUE2RSxrRUFBa0Usd0VBQXdFLGtDQUFrQyw0R0FBNEcsV0FBVyxrQ0FBa0MsT0FBTyxtQkFBbUIsR0FBRywrQ0FBK0MsaUNBQWlDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLGdDQUFnQyxHQUFHLDhEQUE4RCx5RkFBeUYsOENBQThDLDZFQUE2RSxtQ0FBbUMsbUNBQW1DLDhDQUE4QyxxQ0FBcUMsb0dBQW9HLGtGQUFrRix5REFBeUQsNENBQTRDLHlDQUF5QyxHQUFHLGlCQUFpQixxQkFBcUIsaURBQWlELCtCQUErQixHQUFHLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC8oYXNzaWdubWVudCkvYXNzaWdubWVudC9BMmEvZnJhZ21lbnQuZ2xzbD9lYTllIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgICAgICAgICAvLy8vIHNldCBkZWZhdWx0IHByZWNpc2lvbiBvZiBmbG9hdCB2YXJpYWJsZXMgdG8gaGlnaCBwcmVjaXNpb25cXG5cXG52YXJ5aW5nIHZlYzIgdlV2OyAgICAgICAgICAgICAgICAgICAvLy8vIHNjcmVlbiB1diBjb29yZGluYXRlcyAodmFyeWluZywgZnJvbSB2ZXJ0ZXggc2hhZGVyKVxcbnVuaWZvcm0gdmVjMiBpUmVzb2x1dGlvbjsgICAgICAgICAgIC8vLy8gc2NyZWVuIHJlc29sdXRpb24gKHVuaWZvcm0sIGZyb20gQ1BVKVxcbnVuaWZvcm0gZmxvYXQgaVRpbWU7ICAgICAgICAgICAgICAgIC8vLy8gdGltZSBlbGFwc2VkICh1bmlmb3JtLCBmcm9tIENQVSlcXG5cXG4vLyBub2lzZVxcbi8vIFZvbHVtZSByYXljYXN0aW5nIGJ5IFhUOTVcXG4vLyBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbHNzM3pyXFxubWF0MyBtID0gbWF0MyggMC4wMCwgIDAuODAsICAwLjYwLFxcbiAgICAgICAgICAgICAgLTAuODAsICAwLjM2LCAtMC40OCxcXG4gICAgICAgICAgICAgIC0wLjYwLCAtMC40OCwgIDAuNjQgKTtcXG5mbG9hdCBoYXNoKCBmbG9hdCBuIClcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4obikqNDM3NTguNTQ1Myk7XFxufVxcblxcbmZsb2F0IG5vaXNlKCBpbiB2ZWMzIHggKVxcbntcXG4gICAgdmVjMyBwID0gZmxvb3IoeCk7XFxuICAgIHZlYzMgZiA9IGZyYWN0KHgpO1xcblxcbiAgICBmID0gZipmKigzLjAtMi4wKmYpO1xcblxcbiAgICBmbG9hdCBuID0gcC54ICsgcC55KjU3LjAgKyAxMTMuMCpwLno7XFxuXFxuICAgIGZsb2F0IHJlcyA9IG1peChtaXgobWl4KCBoYXNoKG4rICAwLjApLCBoYXNoKG4rICAxLjApLGYueCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4KCBoYXNoKG4rIDU3LjApLCBoYXNoKG4rIDU4LjApLGYueCksZi55KSxcXG4gICAgICAgICAgICAgICAgICAgIG1peChtaXgoIGhhc2gobisxMTMuMCksIGhhc2gobisxMTQuMCksZi54KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXgoIGhhc2gobisxNzAuMCksIGhhc2gobisxNzEuMCksZi54KSxmLnkpLGYueik7XFxuICAgIHJldHVybiByZXM7XFxufVxcblxcbmZsb2F0IGZibSggdmVjMyBwIClcXG57XFxuICAgIGZsb2F0IGY7XFxuICAgIGYgID0gMC41MDAwKm5vaXNlKCBwICk7IHAgPSBtKnAqMi4wMjtcXG4gICAgZiArPSAwLjI1MDAqbm9pc2UoIHAgKTsgcCA9IG0qcCoyLjAzO1xcbiAgICBmICs9IDAuMTI1MDAqbm9pc2UoIHAgKTsgcCA9IG0qcCoyLjAxO1xcbiAgICBmICs9IDAuMDYyNTAqbm9pc2UoIHAgKTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5cXG5mbG9hdCBzdGVwVXAoZmxvYXQgdCwgZmxvYXQgbGVuLCBmbG9hdCBzbW8pXFxue1xcbiAgZmxvYXQgdHQgPSBtb2QodCArPSBzbW8sIGxlbik7XFxuICBmbG9hdCBzdHAgPSBmbG9vcih0IC8gbGVuKSAtIDEuMDtcXG4gIHJldHVybiBzbW9vdGhzdGVwKDAuMCwgc21vLCB0dCkgKyBzdHA7XFxufVxcblxcbi8vIGlxJ3Mgc21pblxcbmZsb2F0IHNtaW4oIGZsb2F0IGQxLCBmbG9hdCBkMiwgZmxvYXQgayApIHtcXG4gICAgZmxvYXQgaCA9IGNsYW1wKCAwLjUgKyAwLjUqKGQyLWQxKS9rLCAwLjAsIDEuMCApO1xcbiAgICByZXR1cm4gbWl4KCBkMiwgZDEsIGggKSAtIGsqaCooMS4wLWgpOyB9XFxuXFxuZmxvYXQgc2RUb3J1cyggdmVjMyBwLCB2ZWMyIHQgKVxcbntcXG4gIHZlYzIgcSA9IHZlYzIobGVuZ3RoKHAueHopLXQueCxwLnkpO1xcbiAgcmV0dXJuIGxlbmd0aChxKS10Lnk7XFxufVxcblxcbmZsb2F0IG1hcCggaW4gdmVjMyBwIClcXG57XFxuICAgIHAgKj0gMi4wO1xcblxcdHZlYzMgcSA9IHAgLSB2ZWMzKDAuMCwwLjUsMS4wKSppVGltZTtcXG4gICAgZmxvYXQgZiA9IGZibShxKTtcXG4gICAgZmxvYXQgdG9ydXMgPSAxLiAtIHNkVG9ydXMocCAqIDIuMCwgdmVjMig2LjAsIDAuMDA1KSkgKyBmICogMy41O1xcblxcblxcdHJldHVybiBtaW4obWF4KDAuMCwgdG9ydXMpLCAxLjApO1xcbn1cXG5cXG5mbG9hdCBqaXR0ZXI7XFxuXFxuI2RlZmluZSBNQVhfU1RFUFMgNDhcXG4jZGVmaW5lIFNIQURPV19TVEVQUyA4XFxuI2RlZmluZSBWT0xVTUVfTEVOR1RIIDE1LlxcbiNkZWZpbmUgU0hBRE9XX0xFTkdUSCAyLlxcblxcbi8vIFJlZmVyZW5jZVxcbi8vIGh0dHBzOi8vc2hhZGVyYml0cy5jb20vYmxvZy9jcmVhdGluZy12b2x1bWV0cmljLXJheS1tYXJjaGVyXFxudmVjNCBjbG91ZE1hcmNoKHZlYzMgcCwgdmVjMyByYXkpXFxue1xcbiAgICBmbG9hdCBkZW5zaXR5ID0gMC47XFxuXFxuICAgIGZsb2F0IHN0ZXBMZW5ndGggPSBWT0xVTUVfTEVOR1RIIC8gZmxvYXQoTUFYX1NURVBTKTtcXG4gICAgZmxvYXQgc2hhZG93U3RlcExlbmd0aCA9IFNIQURPV19MRU5HVEggLyBmbG9hdChTSEFET1dfU1RFUFMpO1xcbiAgICB2ZWMzIGxpZ2h0ID0gbm9ybWFsaXplKHZlYzMoMS4wLCAyLjAsIDEuMCkpO1xcblxcbiAgICB2ZWM0IHN1bSA9IHZlYzQoMC4sIDAuLCAwLiwgMS4pO1xcbiAgICBcXG4gICAgdmVjMyBwb3MgPSBwICsgcmF5ICogaml0dGVyICogc3RlcExlbmd0aDtcXG4gICAgXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTUFYX1NURVBTOyBpKyspXFxuICAgIHtcXG4gICAgICAgIGlmIChzdW0uYSA8IDAuMSkge1xcbiAgICAgICAgXFx0YnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCBkID0gbWFwKHBvcyk7XFxuICAgIFxcbiAgICAgICAgaWYoIGQgPiAwLjAwMSlcXG4gICAgICAgIHtcXG4gICAgICAgICAgICB2ZWMzIGxwb3MgPSBwb3MgKyBsaWdodCAqIGppdHRlciAqIHNoYWRvd1N0ZXBMZW5ndGg7XFxuICAgICAgICAgICAgZmxvYXQgc2hhZG93ID0gMC47XFxuICAgIFxcbiAgICAgICAgICAgIGZvciAoaW50IHMgPSAwOyBzIDwgU0hBRE9XX1NURVBTOyBzKyspXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICBscG9zICs9IGxpZ2h0ICogc2hhZG93U3RlcExlbmd0aDtcXG4gICAgICAgICAgICAgICAgZmxvYXQgbHNhbXBsZSA9IG1hcChscG9zKTtcXG4gICAgICAgICAgICAgICAgc2hhZG93ICs9IGxzYW1wbGU7XFxuICAgICAgICAgICAgfVxcbiAgICBcXG4gICAgICAgICAgICBkZW5zaXR5ID0gY2xhbXAoKGQgLyBmbG9hdChNQVhfU1RFUFMpKSAqIDIwLjAsIDAuMCwgMS4wKTtcXG4gICAgICAgICAgICBmbG9hdCBzID0gZXhwKCgtc2hhZG93IC8gZmxvYXQoU0hBRE9XX1NURVBTKSkgKiAzLik7XFxuICAgICAgICAgICAgc3VtLnJnYiArPSB2ZWMzKHMgKiBkZW5zaXR5KSAqIHZlYzMoMS4xLCAwLjksIC41KSAqIHN1bS5hO1xcbiAgICAgICAgICAgIHN1bS5hICo9IDEuLWRlbnNpdHk7XFxuXFxuICAgICAgICAgICAgc3VtLnJnYiArPSBleHAoLW1hcChwb3MgKyB2ZWMzKDAsMC4yNSwwLjApKSAqIC4yKSAqIGRlbnNpdHkgKiB2ZWMzKDAuMTUsIDAuNDUsIDEuMSkgKiBzdW0uYTtcXG4gICAgICAgIH1cXG4gICAgICAgIHBvcyArPSByYXkgKiBzdGVwTGVuZ3RoO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBzdW07XFxufVxcblxcbm1hdDMgY2FtZXJhKHZlYzMgcm8sIHZlYzMgdGEsIGZsb2F0IGNyIClcXG57XFxuXFx0dmVjMyBjdyA9IG5vcm1hbGl6ZSh0YSAtIHJvKTtcXG5cXHR2ZWMzIGNwID0gdmVjMyhzaW4oY3IpLCBjb3MoY3IpLDAuKTtcXG5cXHR2ZWMzIGN1ID0gbm9ybWFsaXplKCBjcm9zcyhjdyxjcCkgKTtcXG5cXHR2ZWMzIGN2ID0gbm9ybWFsaXplKCBjcm9zcyhjdSxjdykgKTtcXG4gICAgcmV0dXJuIG1hdDMoIGN1LCBjdiwgY3cgKTtcXG59XFxuXFxudm9pZCBtYWluSW1hZ2UoIG91dCB2ZWM0IGZyYWdDb2xvciwgaW4gdmVjMiBmcmFnQ29vcmQgKVxcbntcXG4gICAgdmVjMiBwID0gKGZyYWdDb29yZC54eSAqIDIuMCAtIGlSZXNvbHV0aW9uLnh5KSAvIG1pbihpUmVzb2x1dGlvbi54LCBpUmVzb2x1dGlvbi55KTtcXG4gICAgaml0dGVyID0gaGFzaChwLnggKyBwLnkgKiA1Ny4wICsgaVRpbWUpO1xcbiAgICB2ZWMzIHJvID0gdmVjMyhjb3MoaVRpbWUgKiAuMzMzKSAqIDguMCwgLTUuNSwgc2luKGlUaW1lICogLjMzMykgKiA4LjApO1xcbiAgICB2ZWMzIHRhID0gdmVjMygwLjAsIDEuLCAwLjApO1xcbiAgICBtYXQzIGMgPSBjYW1lcmEocm8sIHRhLCAwLjApO1xcbiAgICB2ZWMzIHJheSA9IGMgKiBub3JtYWxpemUodmVjMyhwLCAxLjc1KSk7XFxuICAgIHZlYzQgY29sID0gY2xvdWRNYXJjaChybywgcmF5KTtcXG4gICAgdmVjMyByZXN1bHQgPSBjb2wucmdiICsgbWl4KHZlYzMoMC4zLCAwLjYsIDEuMCksIHZlYzMoMC4wNSwgMC4zNSwgMS4wKSwgcC55ICsgMC43NSkgKiAoY29sLmEpO1xcbiAgICBcXG4gICAgZmxvYXQgc3VuZG90ID0gY2xhbXAoZG90KHJheSxub3JtYWxpemUodmVjMygxLjAsIDIuMCwgMS4wKSkpLDAuMCwxLjApO1xcbiAgICByZXN1bHQgKz0gMC40KnZlYzMoMS4wLDAuNywwLjMpKnBvdyggc3VuZG90LCA0LjAgKTtcXG5cXG4gICAgcmVzdWx0ID0gcG93KHJlc3VsdCwgdmVjMygxLjAvMi4yKSk7XFxuICAgIFxcbiAgICBmcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwxLjApO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgZnJhZ0NvbG9yO1xcbiAgICBtYWluSW1hZ2UoZnJhZ0NvbG9yLCB2VXYgKiBpUmVzb2x1dGlvbi54eSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGZyYWdDb2xvcjtcXG59XCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A2a/fragment.glsl\n"));

/***/ })

});