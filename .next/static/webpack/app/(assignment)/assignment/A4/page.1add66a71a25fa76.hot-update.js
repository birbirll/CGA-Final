"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(assignment)/assignment/A4/page",{

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_final.glsl":
/*!****************************************************************!*\
  !*** ./src/app/(assignment)/assignment/A4/fragment_final.glsl ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"precision highp float;\\n#define GLSLIFY 1\\n              //// set default precision of float variables to high precision\\n\\nvarying vec2 vUv;                   //// screen uv coordinates (varying, from vertex shader)\\nuniform vec2 iResolution;           //// screen resolution (uniform, from CPU)\\nuniform float iTime;                //// time elapsed (uniform, from CPU)\\n\\n// noise\\n// Volume raycasting by XT95\\n// https://www.shadertoy.com/view/lss3zr\\nmat3 m = mat3( 0.00,  0.80,  0.60,\\n              -0.80,  0.36, -0.48,\\n              -0.60, -0.48,  0.64 );\\nfloat hash( float n )\\n{\\n    return fract(sin(n)*43758.5453);\\n}\\n\\nfloat noise( in vec3 x )\\n{\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\n    f = f*f*(3.0-2.0*f);\\n\\n    float n = p.x + p.y*57.0 + 113.0*p.z;\\n\\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\\n    return res;\\n}\\n\\nfloat fbm( vec3 p )\\n{\\n    float f;\\n    f  = 0.5000*noise( p ); p = m*p*2.02;\\n    f += 0.2500*noise( p ); p = m*p*2.03;\\n    f += 0.12500*noise( p ); p = m*p*2.01;\\n    f += 0.06250*noise( p );\\n    return f;\\n}\\n/////////////////////////////////////\\n\\nfloat stepUp(float t, float len, float smo)\\n{\\n  float tt = mod(t += smo, len);\\n  float stp = floor(t / len) - 1.0;\\n  return smoothstep(0.0, smo, tt) + stp;\\n}\\n\\n// iq's smin\\nfloat smin( float d1, float d2, float k ) {\\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\\n\\nfloat sdTorus( vec3 p, vec2 t )\\n{\\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\\n  return length(q)-t.y;\\n}\\n\\nfloat map( in vec3 p )\\n{\\n\\tvec3 q = p - vec3(0.0,0.5,1.0)*iTime;\\n    float f = fbm(q);\\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\\n    float s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\\n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\\n    float s3 = 1.0 - smin(smin(\\n                           length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),\\n                           length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),\\n                           length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\\n    \\n    float t = mod(stepUp(iTime, 4.0, 1.0), 4.0);\\n    \\n\\tfloat d = mix(s1, s2, clamp(t, 0.0, 1.0));\\n    d = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));\\n    d = mix(d, s3, clamp(t - 2.0, 0.0, 1.0));\\n    d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));\\n    \\n\\treturn min(max(0.0, d), 1.0);\\n}\\n\\nfloat jitter;\\n\\n#define MAX_STEPS 48\\n#define SHADOW_STEPS 8\\n#define VOLUME_LENGTH 15.\\n#define SHADOW_LENGTH 2.\\n\\n// Reference\\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\\nvec4 cloudMarch(vec3 p, vec3 ray)\\n{\\n    float density = 0.;\\n\\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\\n\\n    vec4 sum = vec4(0., 0., 0., 1.);\\n    \\n    vec3 pos = p + ray * jitter * stepLength;\\n    \\n    for (int i = 0; i < MAX_STEPS; i++)\\n    {\\n        if (sum.a < 0.1) {\\n        \\tbreak;\\n        }\\n        float d = map(pos);\\n    \\n        if( d > 0.001)\\n        {\\n            vec3 lpos = pos + light * jitter * shadowStepLength;\\n            float shadow = 0.;\\n    \\n            for (int s = 0; s < SHADOW_STEPS; s++)\\n            {\\n                lpos += light * shadowStepLength;\\n                float lsample = map(lpos);\\n                shadow += lsample;\\n            }\\n    \\n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\\n            sum.a *= 1.-density;\\n\\n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\\n        }\\n        pos += ray * stepLength;\\n    }\\n\\n    return sum;\\n}\\n\\nmat3 camera(vec3 ro, vec3 ta, float cr )\\n{\\n\\tvec3 cw = normalize(ta - ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\\n    jitter = hash(p.x + p.y * 57.0 + iTime);\\n    vec3 ro = vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0);\\n    vec3 ta = vec3(0.0, 1., 0.0);\\n    mat3 c = camera(ro, ta, 0.0);\\n    vec3 ray = c * normalize(vec3(p, 1.75));\\n    vec4 col = cloudMarch(ro, ray);\\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\\n    \\n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\\n\\n    result = pow(result, vec3(1.0/2.2));\\n    \\n    fragColor = vec4(result,1.0);\\n}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvZnJhZ21lbnRfZmluYWwuZ2xzbCIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsdUJBQXVCLDBJQUEwSSw4RkFBOEYsZ0ZBQWdGLHVPQUF1TywwQkFBMEIsc0NBQXNDLEdBQUcsK0JBQStCLHdCQUF3Qix3QkFBd0IsNEJBQTRCLDZDQUE2QyxxUkFBcVIsaUJBQWlCLEdBQUcsMEJBQTBCLGNBQWMsOEJBQThCLGFBQWEsOEJBQThCLGFBQWEsK0JBQStCLGFBQWEsOEJBQThCLGVBQWUsR0FBRyx5RkFBeUYsa0NBQWtDLHFDQUFxQywwQ0FBMEMsR0FBRyw2REFBNkQsdURBQXVELDhDQUE4QyxzQ0FBc0Msd0NBQXdDLHlCQUF5QixHQUFHLDZCQUE2Qix5Q0FBeUMsdUJBQXVCLGlFQUFpRSxpRUFBaUUsc0VBQXNFLDRXQUE0Vyx3REFBd0Qsb0RBQW9ELGtEQUFrRCwrQ0FBK0MsK0NBQStDLHVDQUF1QyxHQUFHLGlCQUFpQiwyTkFBMk4seUJBQXlCLDREQUE0RCxtRUFBbUUsa0RBQWtELHdDQUF3QyxxREFBcUQsNEJBQTRCLGVBQWUsV0FBVyw0QkFBNEIsa0JBQWtCLFdBQVcsNkJBQTZCLHlDQUF5QyxrRUFBa0UsZ0NBQWdDLG9DQUFvQyxrQkFBa0IsbUJBQW1CLG1EQUFtRCw0Q0FBNEMsb0NBQW9DLGVBQWUsNkVBQTZFLGtFQUFrRSx3RUFBd0Usa0NBQWtDLDRHQUE0RyxXQUFXLGtDQUFrQyxPQUFPLG1CQUFtQixHQUFHLCtDQUErQyxpQ0FBaUMsd0NBQXdDLHdDQUF3Qyx3Q0FBd0MsZ0NBQWdDLEdBQUcsOERBQThELHlGQUF5Riw4Q0FBOEMsNkVBQTZFLG1DQUFtQyxtQ0FBbUMsOENBQThDLHFDQUFxQyxvR0FBb0csa0ZBQWtGLHlEQUF5RCw0Q0FBNEMseUNBQXlDLEdBQUcsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwLyhhc3NpZ25tZW50KS9hc3NpZ25tZW50L0E0L2ZyYWdtZW50X2ZpbmFsLmdsc2w/ZTI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgICAgICAgICAgLy8vLyBzZXQgZGVmYXVsdCBwcmVjaXNpb24gb2YgZmxvYXQgdmFyaWFibGVzIHRvIGhpZ2ggcHJlY2lzaW9uXFxuXFxudmFyeWluZyB2ZWMyIHZVdjsgICAgICAgICAgICAgICAgICAgLy8vLyBzY3JlZW4gdXYgY29vcmRpbmF0ZXMgKHZhcnlpbmcsIGZyb20gdmVydGV4IHNoYWRlcilcXG51bmlmb3JtIHZlYzIgaVJlc29sdXRpb247ICAgICAgICAgICAvLy8vIHNjcmVlbiByZXNvbHV0aW9uICh1bmlmb3JtLCBmcm9tIENQVSlcXG51bmlmb3JtIGZsb2F0IGlUaW1lOyAgICAgICAgICAgICAgICAvLy8vIHRpbWUgZWxhcHNlZCAodW5pZm9ybSwgZnJvbSBDUFUpXFxuXFxuLy8gbm9pc2VcXG4vLyBWb2x1bWUgcmF5Y2FzdGluZyBieSBYVDk1XFxuLy8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2xzczN6clxcbm1hdDMgbSA9IG1hdDMoIDAuMDAsICAwLjgwLCAgMC42MCxcXG4gICAgICAgICAgICAgIC0wLjgwLCAgMC4zNiwgLTAuNDgsXFxuICAgICAgICAgICAgICAtMC42MCwgLTAuNDgsICAwLjY0ICk7XFxuZmxvYXQgaGFzaCggZmxvYXQgbiApXFxue1xcbiAgICByZXR1cm4gZnJhY3Qoc2luKG4pKjQzNzU4LjU0NTMpO1xcbn1cXG5cXG5mbG9hdCBub2lzZSggaW4gdmVjMyB4IClcXG57XFxuICAgIHZlYzMgcCA9IGZsb29yKHgpO1xcbiAgICB2ZWMzIGYgPSBmcmFjdCh4KTtcXG5cXG4gICAgZiA9IGYqZiooMy4wLTIuMCpmKTtcXG5cXG4gICAgZmxvYXQgbiA9IHAueCArIHAueSo1Ny4wICsgMTEzLjAqcC56O1xcblxcbiAgICBmbG9hdCByZXMgPSBtaXgobWl4KG1peCggaGFzaChuKyAgMC4wKSwgaGFzaChuKyAgMS4wKSxmLngpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peCggaGFzaChuKyA1Ny4wKSwgaGFzaChuKyA1OC4wKSxmLngpLGYueSksXFxuICAgICAgICAgICAgICAgICAgICBtaXgobWl4KCBoYXNoKG4rMTEzLjApLCBoYXNoKG4rMTE0LjApLGYueCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4KCBoYXNoKG4rMTcwLjApLCBoYXNoKG4rMTcxLjApLGYueCksZi55KSxmLnopO1xcbiAgICByZXR1cm4gcmVzO1xcbn1cXG5cXG5mbG9hdCBmYm0oIHZlYzMgcCApXFxue1xcbiAgICBmbG9hdCBmO1xcbiAgICBmICA9IDAuNTAwMCpub2lzZSggcCApOyBwID0gbSpwKjIuMDI7XFxuICAgIGYgKz0gMC4yNTAwKm5vaXNlKCBwICk7IHAgPSBtKnAqMi4wMztcXG4gICAgZiArPSAwLjEyNTAwKm5vaXNlKCBwICk7IHAgPSBtKnAqMi4wMTtcXG4gICAgZiArPSAwLjA2MjUwKm5vaXNlKCBwICk7XFxuICAgIHJldHVybiBmO1xcbn1cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxuZmxvYXQgc3RlcFVwKGZsb2F0IHQsIGZsb2F0IGxlbiwgZmxvYXQgc21vKVxcbntcXG4gIGZsb2F0IHR0ID0gbW9kKHQgKz0gc21vLCBsZW4pO1xcbiAgZmxvYXQgc3RwID0gZmxvb3IodCAvIGxlbikgLSAxLjA7XFxuICByZXR1cm4gc21vb3Roc3RlcCgwLjAsIHNtbywgdHQpICsgc3RwO1xcbn1cXG5cXG4vLyBpcSdzIHNtaW5cXG5mbG9hdCBzbWluKCBmbG9hdCBkMSwgZmxvYXQgZDIsIGZsb2F0IGsgKSB7XFxuICAgIGZsb2F0IGggPSBjbGFtcCggMC41ICsgMC41KihkMi1kMSkvaywgMC4wLCAxLjAgKTtcXG4gICAgcmV0dXJuIG1peCggZDIsIGQxLCBoICkgLSBrKmgqKDEuMC1oKTsgfVxcblxcbmZsb2F0IHNkVG9ydXMoIHZlYzMgcCwgdmVjMiB0IClcXG57XFxuICB2ZWMyIHEgPSB2ZWMyKGxlbmd0aChwLnh6KS10LngscC55KTtcXG4gIHJldHVybiBsZW5ndGgocSktdC55O1xcbn1cXG5cXG5mbG9hdCBtYXAoIGluIHZlYzMgcCApXFxue1xcblxcdHZlYzMgcSA9IHAgLSB2ZWMzKDAuMCwwLjUsMS4wKSppVGltZTtcXG4gICAgZmxvYXQgZiA9IGZibShxKTtcXG4gICAgZmxvYXQgczEgPSAxLjAgLSBsZW5ndGgocCAqIHZlYzMoMC41LCAxLjAsIDAuNSkpICsgZiAqIDIuMjtcXG4gICAgZmxvYXQgczIgPSAxLjAgLSBsZW5ndGgocCAqIHZlYzMoMC4xLCAxLjAsIDAuMikpICsgZiAqIDIuNTtcXG4gICAgZmxvYXQgdG9ydXMgPSAxLiAtIHNkVG9ydXMocCAqIDIuMCwgdmVjMig2LjAsIDAuMDA1KSkgKyBmICogMy41O1xcbiAgICBmbG9hdCBzMyA9IDEuMCAtIHNtaW4oc21pbihcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgocCAqIDEuMCAtIHZlYzMoY29zKGlUaW1lICogMy4wKSAqIDYuMCwgc2luKGlUaW1lICogMi4wKSAqIDUuMCwgMC4wKSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoKHAgKiAyLjAgLSB2ZWMzKDAuMCwgc2luKGlUaW1lKSAqIDQuMCwgY29zKGlUaW1lICogMi4wKSAqIDMuMCkpLCA0LjApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aChwICogMy4wIC0gdmVjMyhjb3MoaVRpbWUgKiAyLjApICogMy4wLCAwLjAsIHNpbihpVGltZSAqIDMuMykgKiA3LjApKSwgNC4wKSArIGYgKiAyLjU7XFxuICAgIFxcbiAgICBmbG9hdCB0ID0gbW9kKHN0ZXBVcChpVGltZSwgNC4wLCAxLjApLCA0LjApO1xcbiAgICBcXG5cXHRmbG9hdCBkID0gbWl4KHMxLCBzMiwgY2xhbXAodCwgMC4wLCAxLjApKTtcXG4gICAgZCA9IG1peChkLCB0b3J1cywgY2xhbXAodCAtIDEuMCwgMC4wLCAxLjApKTtcXG4gICAgZCA9IG1peChkLCBzMywgY2xhbXAodCAtIDIuMCwgMC4wLCAxLjApKTtcXG4gICAgZCA9IG1peChkLCBzMSwgY2xhbXAodCAtIDMuMCwgMC4wLCAxLjApKTtcXG4gICAgXFxuXFx0cmV0dXJuIG1pbihtYXgoMC4wLCBkKSwgMS4wKTtcXG59XFxuXFxuZmxvYXQgaml0dGVyO1xcblxcbiNkZWZpbmUgTUFYX1NURVBTIDQ4XFxuI2RlZmluZSBTSEFET1dfU1RFUFMgOFxcbiNkZWZpbmUgVk9MVU1FX0xFTkdUSCAxNS5cXG4jZGVmaW5lIFNIQURPV19MRU5HVEggMi5cXG5cXG4vLyBSZWZlcmVuY2VcXG4vLyBodHRwczovL3NoYWRlcmJpdHMuY29tL2Jsb2cvY3JlYXRpbmctdm9sdW1ldHJpYy1yYXktbWFyY2hlclxcbnZlYzQgY2xvdWRNYXJjaCh2ZWMzIHAsIHZlYzMgcmF5KVxcbntcXG4gICAgZmxvYXQgZGVuc2l0eSA9IDAuO1xcblxcbiAgICBmbG9hdCBzdGVwTGVuZ3RoID0gVk9MVU1FX0xFTkdUSCAvIGZsb2F0KE1BWF9TVEVQUyk7XFxuICAgIGZsb2F0IHNoYWRvd1N0ZXBMZW5ndGggPSBTSEFET1dfTEVOR1RIIC8gZmxvYXQoU0hBRE9XX1NURVBTKTtcXG4gICAgdmVjMyBsaWdodCA9IG5vcm1hbGl6ZSh2ZWMzKDEuMCwgMi4wLCAxLjApKTtcXG5cXG4gICAgdmVjNCBzdW0gPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG4gICAgXFxuICAgIHZlYzMgcG9zID0gcCArIHJheSAqIGppdHRlciAqIHN0ZXBMZW5ndGg7XFxuICAgIFxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9TVEVQUzsgaSsrKVxcbiAgICB7XFxuICAgICAgICBpZiAoc3VtLmEgPCAwLjEpIHtcXG4gICAgICAgIFxcdGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgZCA9IG1hcChwb3MpO1xcbiAgICBcXG4gICAgICAgIGlmKCBkID4gMC4wMDEpXFxuICAgICAgICB7XFxuICAgICAgICAgICAgdmVjMyBscG9zID0gcG9zICsgbGlnaHQgKiBqaXR0ZXIgKiBzaGFkb3dTdGVwTGVuZ3RoO1xcbiAgICAgICAgICAgIGZsb2F0IHNoYWRvdyA9IDAuO1xcbiAgICBcXG4gICAgICAgICAgICBmb3IgKGludCBzID0gMDsgcyA8IFNIQURPV19TVEVQUzsgcysrKVxcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgbHBvcyArPSBsaWdodCAqIHNoYWRvd1N0ZXBMZW5ndGg7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGxzYW1wbGUgPSBtYXAobHBvcyk7XFxuICAgICAgICAgICAgICAgIHNoYWRvdyArPSBsc2FtcGxlO1xcbiAgICAgICAgICAgIH1cXG4gICAgXFxuICAgICAgICAgICAgZGVuc2l0eSA9IGNsYW1wKChkIC8gZmxvYXQoTUFYX1NURVBTKSkgKiAyMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgICAgICAgZmxvYXQgcyA9IGV4cCgoLXNoYWRvdyAvIGZsb2F0KFNIQURPV19TVEVQUykpICogMy4pO1xcbiAgICAgICAgICAgIHN1bS5yZ2IgKz0gdmVjMyhzICogZGVuc2l0eSkgKiB2ZWMzKDEuMSwgMC45LCAuNSkgKiBzdW0uYTtcXG4gICAgICAgICAgICBzdW0uYSAqPSAxLi1kZW5zaXR5O1xcblxcbiAgICAgICAgICAgIHN1bS5yZ2IgKz0gZXhwKC1tYXAocG9zICsgdmVjMygwLDAuMjUsMC4wKSkgKiAuMikgKiBkZW5zaXR5ICogdmVjMygwLjE1LCAwLjQ1LCAxLjEpICogc3VtLmE7XFxuICAgICAgICB9XFxuICAgICAgICBwb3MgKz0gcmF5ICogc3RlcExlbmd0aDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gc3VtO1xcbn1cXG5cXG5tYXQzIGNhbWVyYSh2ZWMzIHJvLCB2ZWMzIHRhLCBmbG9hdCBjciApXFxue1xcblxcdHZlYzMgY3cgPSBub3JtYWxpemUodGEgLSBybyk7XFxuXFx0dmVjMyBjcCA9IHZlYzMoc2luKGNyKSwgY29zKGNyKSwwLik7XFxuXFx0dmVjMyBjdSA9IG5vcm1hbGl6ZSggY3Jvc3MoY3csY3ApICk7XFxuXFx0dmVjMyBjdiA9IG5vcm1hbGl6ZSggY3Jvc3MoY3UsY3cpICk7XFxuICAgIHJldHVybiBtYXQzKCBjdSwgY3YsIGN3ICk7XFxufVxcblxcbnZvaWQgbWFpbkltYWdlKCBvdXQgdmVjNCBmcmFnQ29sb3IsIGluIHZlYzIgZnJhZ0Nvb3JkIClcXG57XFxuICAgIHZlYzIgcCA9IChmcmFnQ29vcmQueHkgKiAyLjAgLSBpUmVzb2x1dGlvbi54eSkgLyBtaW4oaVJlc29sdXRpb24ueCwgaVJlc29sdXRpb24ueSk7XFxuICAgIGppdHRlciA9IGhhc2gocC54ICsgcC55ICogNTcuMCArIGlUaW1lKTtcXG4gICAgdmVjMyBybyA9IHZlYzMoY29zKGlUaW1lICogLjMzMykgKiA4LjAsIC01LjUsIHNpbihpVGltZSAqIC4zMzMpICogOC4wKTtcXG4gICAgdmVjMyB0YSA9IHZlYzMoMC4wLCAxLiwgMC4wKTtcXG4gICAgbWF0MyBjID0gY2FtZXJhKHJvLCB0YSwgMC4wKTtcXG4gICAgdmVjMyByYXkgPSBjICogbm9ybWFsaXplKHZlYzMocCwgMS43NSkpO1xcbiAgICB2ZWM0IGNvbCA9IGNsb3VkTWFyY2gocm8sIHJheSk7XFxuICAgIHZlYzMgcmVzdWx0ID0gY29sLnJnYiArIG1peCh2ZWMzKDAuMywgMC42LCAxLjApLCB2ZWMzKDAuMDUsIDAuMzUsIDEuMCksIHAueSArIDAuNzUpICogKGNvbC5hKTtcXG4gICAgXFxuICAgIGZsb2F0IHN1bmRvdCA9IGNsYW1wKGRvdChyYXksbm9ybWFsaXplKHZlYzMoMS4wLCAyLjAsIDEuMCkpKSwwLjAsMS4wKTtcXG4gICAgcmVzdWx0ICs9IDAuNCp2ZWMzKDEuMCwwLjcsMC4zKSpwb3coIHN1bmRvdCwgNC4wICk7XFxuXFxuICAgIHJlc3VsdCA9IHBvdyhyZXN1bHQsIHZlYzMoMS4wLzIuMikpO1xcbiAgICBcXG4gICAgZnJhZ0NvbG9yID0gdmVjNChyZXN1bHQsMS4wKTtcXG59XCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_final.glsl\n"));

/***/ })

});