"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(assignment)/assignment/A4/page",{

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A4/page.tsx":
/*!*****************************************************!*\
  !*** ./src/app/(assignment)/assignment/A4/page.tsx ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ XPBDRopePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _shaders_common_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/shaders/common/vertex.glsl */ \"(app-pages-browser)/./src/shaders/common/vertex.glsl\");\n/* harmony import */ var _fragment_ce_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragment_ce.glsl */ \"(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_ce.glsl\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n // Simple vertex shader\n // Fragment shader\nconst XPBDRope = (param)=>{\n    let { dpr } = param;\n    _s();\n    const { viewport, gl, scene, camera } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)();\n    const uniforms = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        iTime: {\n            value: 0\n        },\n        iTimeDelta: {\n            value: 0\n        },\n        iFrame: {\n            value: 0\n        },\n        iResolution: {\n            value: new three__WEBPACK_IMPORTED_MODULE_5__.Vector2(window.innerWidth * dpr, window.innerHeight * dpr)\n        },\n        iMouse: {\n            value: new three__WEBPACK_IMPORTED_MODULE_5__.Vector4(0, 0, 0, 0)\n        },\n        iChannel0: {\n            value: new three__WEBPACK_IMPORTED_MODULE_5__.Texture()\n        }\n    }).current;\n    // Create double-buffered RenderTarget\n    const renderTargets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([\n        new three__WEBPACK_IMPORTED_MODULE_5__.WebGLRenderTarget(window.innerWidth * dpr, window.innerHeight * dpr, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            format: three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat,\n            type: three__WEBPACK_IMPORTED_MODULE_5__.FloatType\n        }),\n        new three__WEBPACK_IMPORTED_MODULE_5__.WebGLRenderTarget(window.innerWidth * dpr, window.innerHeight * dpr, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            format: three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat,\n            type: three__WEBPACK_IMPORTED_MODULE_5__.FloatType\n        })\n    ]).current;\n    const bufferIndex = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    let lastTime = performance.now(); // Record the time of the previous frame\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(()=>{\n        const now = performance.now();\n        uniforms.iTimeDelta.value = (now - lastTime) / 1000; // Compute delta time in seconds\n        lastTime = now;\n        uniforms.iTime.value += uniforms.iTimeDelta.value;\n        uniforms.iFrame.value++; // Increment frame counter\n        uniforms.iResolution.value.set(window.innerWidth * dpr, window.innerHeight * dpr);\n        //console.log('Frame:', uniforms.iFrame.value);\n        //console.log('Time:', uniforms.iTime.value);\n        // Set the current frame input texture (using the other RenderTarget)\n        uniforms.iChannel0.value = renderTargets[1 - bufferIndex.current].texture;\n        gl.setRenderTarget(renderTargets[bufferIndex.current]);\n        gl.render(scene, camera);\n        gl.setRenderTarget(null); // Switch back to the default framebuffer\n        // Swap buffers\n        bufferIndex.current = 1 - bufferIndex.current;\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleMouseMove = (event)=>{\n            uniforms.iMouse.value.x = event.clientX * dpr;\n            uniforms.iMouse.value.y = (window.innerHeight - event.clientY) * dpr; // Flip Y-axis\n        };\n        const handleMouseDown = (event)=>{\n            if (event.button === 0) {\n                uniforms.iMouse.value.z = 1; // 左键按下\n            }\n        };\n        const handleMouseUp = (event)=>{\n            if (event.button === 0) {\n                uniforms.iMouse.value.z = 0; // 左键释放\n            } else if (event.button === 2) {\n                uniforms.iMouse.value.z = 2; // 右键释放的瞬间\n                requestAnimationFrame(()=>{\n                    uniforms.iMouse.value.z = 0; // 下一帧恢复为 0\n                });\n            }\n        };\n        window.addEventListener(\"mousemove\", handleMouseMove);\n        window.addEventListener(\"mousedown\", handleMouseDown);\n        window.addEventListener(\"mouseup\", handleMouseUp);\n        window.addEventListener(\"contextmenu\", (e)=>e.preventDefault()); // 阻止右键菜单\n        return ()=>{\n            window.removeEventListener(\"mousemove\", handleMouseMove);\n            window.removeEventListener(\"mousedown\", handleMouseDown);\n            window.removeEventListener(\"mouseup\", handleMouseUp);\n        };\n    }, [\n        dpr\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n        scale: [\n            viewport.width,\n            viewport.height,\n            1\n        ],\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                args: [\n                    1,\n                    1\n                ]\n            }, void 0, false, {\n                fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n                lineNumber: 103,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"shaderMaterial\", {\n                fragmentShader: _fragment_ce_glsl__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n                vertexShader: _shaders_common_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n                uniforms: uniforms\n            }, void 0, false, {\n                fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n                lineNumber: 104,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n        lineNumber: 102,\n        columnNumber: 5\n    }, undefined);\n};\n_s(XPBDRope, \"e8OySB1Ty5yM23xsuElxkkKaiAI=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F\n    ];\n});\n_c = XPBDRope;\nfunction XPBDRopePage() {\n    const dpr = 1;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_6__.Canvas, {\n        dpr: dpr,\n        orthographic: true,\n        camera: {\n            position: [\n                0,\n                0,\n                6\n            ]\n        },\n        style: {\n            position: \"fixed\",\n            top: 0,\n            left: 0,\n            width: \"100vw\",\n            height: \"100vh\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n            fallback: null,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(XPBDRope, {\n                dpr: dpr\n            }, void 0, false, {\n                fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n                lineNumber: 129,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n            lineNumber: 128,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n        lineNumber: 116,\n        columnNumber: 5\n    }, this);\n}\n_c1 = XPBDRopePage;\nvar _c, _c1;\n$RefreshReg$(_c, \"XPBDRope\");\n$RefreshReg$(_c1, \"XPBDRopePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFFb0Q7QUFDWTtBQUNqQztBQUV5QixDQUFDLHVCQUF1QjtBQUNoQyxDQUFDLGtCQUFrQjtBQUVuRSxNQUFNUyxXQUFXO1FBQUMsRUFBRUMsR0FBRyxFQUFtQjs7SUFDeEMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLEVBQUUsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR1QscURBQVFBO0lBRWhELE1BQU1VLFdBQVdkLDZDQUFNQSxDQUFDO1FBQ3RCZSxPQUFPO1lBQUVDLE9BQU87UUFBRTtRQUNsQkMsWUFBWTtZQUFFRCxPQUFPO1FBQUU7UUFDdkJFLFFBQVE7WUFBRUYsT0FBTztRQUFFO1FBQ25CRyxhQUFhO1lBQ1hILE9BQU8sSUFBSVgsMENBQWEsQ0FBQ2dCLE9BQU9DLFVBQVUsR0FBR2IsS0FBS1ksT0FBT0UsV0FBVyxHQUFHZDtRQUN6RTtRQUNBZSxRQUFRO1lBQUVSLE9BQU8sSUFBSVgsMENBQWEsQ0FBQyxHQUFHLEdBQUcsR0FBRztRQUFHO1FBQy9DcUIsV0FBVztZQUFFVixPQUFPLElBQUlYLDBDQUFhO1FBQUc7SUFDMUMsR0FBR3VCLE9BQU87SUFFVixzQ0FBc0M7SUFDdEMsTUFBTUMsZ0JBQWdCN0IsNkNBQU1BLENBQUM7UUFDM0IsSUFBSUssb0RBQXVCLENBQUNnQixPQUFPQyxVQUFVLEdBQUdiLEtBQUtZLE9BQU9FLFdBQVcsR0FBR2QsS0FBSztZQUM3RXNCLFdBQVcxQixnREFBbUI7WUFDOUI0QixXQUFXNUIsZ0RBQW1CO1lBQzlCNkIsUUFBUTdCLDZDQUFnQjtZQUN4QitCLE1BQU0vQiw0Q0FBZTtRQUN2QjtRQUNBLElBQUlBLG9EQUF1QixDQUFDZ0IsT0FBT0MsVUFBVSxHQUFHYixLQUFLWSxPQUFPRSxXQUFXLEdBQUdkLEtBQUs7WUFDN0VzQixXQUFXMUIsZ0RBQW1C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L0MsOERBQUNDO2dCQUFjQyxNQUFNO29CQUFDO29CQUFHO2lCQUFFOzs7Ozs7MEJBQzNCLDhEQUFDQztnQkFDQzVELGdCQUFnQkEseURBQWNBO2dCQUM5QkQsY0FBY0EsbUVBQVlBO2dCQUMxQlEsVUFBVUE7Ozs7Ozs7Ozs7OztBQUlsQjtHQXJHTU47O1FBQ29DSixpREFBUUE7UUFnQ2hERCxpREFBUUE7OztLQWpDSks7QUF1R1MsU0FBUzREO0lBQ3RCLE1BQU0zRCxNQUFNO0lBQ1oscUJBQ0UsOERBQUNQLHNEQUFNQTtRQUNMTyxLQUFLQTtRQUNMNEQsWUFBWTtRQUNaeEQsUUFBUTtZQUFFeUQsVUFBVTtnQkFBQztnQkFBRztnQkFBRzthQUFFO1FBQUM7UUFDOUJDLE9BQU87WUFDTEQsVUFBVTtZQUNWRSxLQUFLO1lBQ0xDLE1BQU07WUFDTlYsT0FBTztZQUNQQyxRQUFRO1FBQ1Y7a0JBRUEsNEVBQUNqRSwyQ0FBUUE7WUFBQzJFLFVBQVU7c0JBQ2xCLDRFQUFDbEU7Z0JBQVNDLEtBQUtBOzs7Ozs7Ozs7Ozs7Ozs7O0FBSXZCO01BcEJ3QjJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvcGFnZS50c3g/MWNiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IFN1c3BlbnNlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENhbnZhcywgdXNlRnJhbWUsIHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHZlcnRleFNoYWRlciBmcm9tICdAL3NoYWRlcnMvY29tbW9uL3ZlcnRleC5nbHNsJzsgLy8gU2ltcGxlIHZlcnRleCBzaGFkZXJcbmltcG9ydCBmcmFnbWVudFNoYWRlciBmcm9tICcuL2ZyYWdtZW50X2NlLmdsc2wnOyAvLyBGcmFnbWVudCBzaGFkZXJcblxuY29uc3QgWFBCRFJvcGUgPSAoeyBkcHIgfTogeyBkcHI6IG51bWJlciB9KSA9PiB7XG4gIGNvbnN0IHsgdmlld3BvcnQsIGdsLCBzY2VuZSwgY2FtZXJhIH0gPSB1c2VUaHJlZSgpO1xuXG4gIGNvbnN0IHVuaWZvcm1zID0gdXNlUmVmKHtcbiAgICBpVGltZTogeyB2YWx1ZTogMCB9LFxuICAgIGlUaW1lRGVsdGE6IHsgdmFsdWU6IDAgfSwgLy8gRGVsdGEgdGltZSBiZXR3ZWVuIGZyYW1lc1xuICAgIGlGcmFtZTogeyB2YWx1ZTogMCB9LCAvLyBDdXJyZW50IGZyYW1lIG51bWJlclxuICAgIGlSZXNvbHV0aW9uOiB7XG4gICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIod2luZG93LmlubmVyV2lkdGggKiBkcHIsIHdpbmRvdy5pbm5lckhlaWdodCAqIGRwciksXG4gICAgfSxcbiAgICBpTW91c2U6IHsgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KDAsIDAsIDAsIDApIH0sXG4gICAgaUNoYW5uZWwwOiB7IHZhbHVlOiBuZXcgVEhSRUUuVGV4dHVyZSgpIH0sIC8vIElucHV0IHRleHR1cmVcbiAgfSkuY3VycmVudDtcblxuICAvLyBDcmVhdGUgZG91YmxlLWJ1ZmZlcmVkIFJlbmRlclRhcmdldFxuICBjb25zdCByZW5kZXJUYXJnZXRzID0gdXNlUmVmKFtcbiAgICBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQod2luZG93LmlubmVyV2lkdGggKiBkcHIsIHdpbmRvdy5pbm5lckhlaWdodCAqIGRwciwge1xuICAgICAgbWluRmlsdGVyOiBUSFJFRS5OZWFyZXN0RmlsdGVyLFxuICAgICAgbWFnRmlsdGVyOiBUSFJFRS5OZWFyZXN0RmlsdGVyLFxuICAgICAgZm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0LFxuICAgICAgdHlwZTogVEhSRUUuRmxvYXRUeXBlLFxuICAgIH0pLFxuICAgIG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCh3aW5kb3cuaW5uZXJXaWR0aCAqIGRwciwgd2luZG93LmlubmVySGVpZ2h0ICogZHByLCB7XG4gICAgICBtaW5GaWx0ZXI6IFRIUkVFLk5lYXJlc3RGaWx0ZXIsXG4gICAgICBtYWdGaWx0ZXI6IFRIUkVFLk5lYXJlc3RGaWx0ZXIsXG4gICAgICBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQsXG4gICAgICB0eXBlOiBUSFJFRS5GbG9hdFR5cGUsXG4gICAgfSksXG4gIF0pLmN1cnJlbnQ7XG5cbiAgY29uc3QgYnVmZmVySW5kZXggPSB1c2VSZWYoMCk7XG4gIGxldCBsYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBSZWNvcmQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzIGZyYW1lXG5cbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHVuaWZvcm1zLmlUaW1lRGVsdGEudmFsdWUgPSAobm93IC0gbGFzdFRpbWUpIC8gMTAwMDsgLy8gQ29tcHV0ZSBkZWx0YSB0aW1lIGluIHNlY29uZHNcbiAgICBsYXN0VGltZSA9IG5vdztcblxuICAgIHVuaWZvcm1zLmlUaW1lLnZhbHVlICs9IHVuaWZvcm1zLmlUaW1lRGVsdGEudmFsdWU7XG4gICAgdW5pZm9ybXMuaUZyYW1lLnZhbHVlKys7IC8vIEluY3JlbWVudCBmcmFtZSBjb3VudGVyXG4gICAgdW5pZm9ybXMuaVJlc29sdXRpb24udmFsdWUuc2V0KHdpbmRvdy5pbm5lcldpZHRoICogZHByLCB3aW5kb3cuaW5uZXJIZWlnaHQgKiBkcHIpO1xuXG4gICAgLy9jb25zb2xlLmxvZygnRnJhbWU6JywgdW5pZm9ybXMuaUZyYW1lLnZhbHVlKTtcbiAgICAvL2NvbnNvbGUubG9nKCdUaW1lOicsIHVuaWZvcm1zLmlUaW1lLnZhbHVlKTtcblxuICAgIC8vIFNldCB0aGUgY3VycmVudCBmcmFtZSBpbnB1dCB0ZXh0dXJlICh1c2luZyB0aGUgb3RoZXIgUmVuZGVyVGFyZ2V0KVxuICAgIHVuaWZvcm1zLmlDaGFubmVsMC52YWx1ZSA9IHJlbmRlclRhcmdldHNbMSAtIGJ1ZmZlckluZGV4LmN1cnJlbnRdLnRleHR1cmU7XG5cbiAgICBnbC5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0c1tidWZmZXJJbmRleC5jdXJyZW50XSk7XG4gICAgZ2wucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIGdsLnNldFJlbmRlclRhcmdldChudWxsKTsgLy8gU3dpdGNoIGJhY2sgdG8gdGhlIGRlZmF1bHQgZnJhbWVidWZmZXJcblxuICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgIGJ1ZmZlckluZGV4LmN1cnJlbnQgPSAxIC0gYnVmZmVySW5kZXguY3VycmVudDtcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIHVuaWZvcm1zLmlNb3VzZS52YWx1ZS54ID0gZXZlbnQuY2xpZW50WCAqIGRwcjtcbiAgICAgIHVuaWZvcm1zLmlNb3VzZS52YWx1ZS55ID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGV2ZW50LmNsaWVudFkpICogZHByOyAvLyBGbGlwIFktYXhpc1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZURvd24gPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5idXR0b24gPT09IDApIHtcbiAgICAgICAgdW5pZm9ybXMuaU1vdXNlLnZhbHVlLnogPSAxOyAvLyDlt6bplK7mjInkuItcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VVcCA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB1bmlmb3Jtcy5pTW91c2UudmFsdWUueiA9IDA7IC8vIOW3pumUrumHiuaUvlxuICAgICAgfSBlbHNlIGlmIChldmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgdW5pZm9ybXMuaU1vdXNlLnZhbHVlLnogPSAyOyAvLyDlj7PplK7ph4rmlL7nmoTnnqzpl7RcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB1bmlmb3Jtcy5pTW91c2UudmFsdWUueiA9IDA7IC8vIOS4i+S4gOW4p+aBouWkjeS4uiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpOyAvLyDpmLvmraLlj7PplK7oj5zljZVcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgICB9O1xuICB9LCBbZHByXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8bWVzaCBzY2FsZT17W3ZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQsIDFdfT5cbiAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1sxLCAxXX0gLz5cbiAgICAgIDxzaGFkZXJNYXRlcmlhbFxuICAgICAgICBmcmFnbWVudFNoYWRlcj17ZnJhZ21lbnRTaGFkZXJ9XG4gICAgICAgIHZlcnRleFNoYWRlcj17dmVydGV4U2hhZGVyfVxuICAgICAgICB1bmlmb3Jtcz17dW5pZm9ybXN9XG4gICAgICAvPlxuICAgIDwvbWVzaD5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFhQQkRSb3BlUGFnZSgpIHtcbiAgY29uc3QgZHByID0gMTtcbiAgcmV0dXJuIChcbiAgICA8Q2FudmFzXG4gICAgICBkcHI9e2Rwcn1cbiAgICAgIG9ydGhvZ3JhcGhpY1xuICAgICAgY2FtZXJhPXt7IHBvc2l0aW9uOiBbMCwgMCwgNl0gfX1cbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiAnMTAwdncnLFxuICAgICAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgICB9fVxuICAgID5cbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17bnVsbH0+XG4gICAgICAgIDxYUEJEUm9wZSBkcHI9e2Rwcn0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgPC9DYW52YXM+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiU3VzcGVuc2UiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJDYW52YXMiLCJ1c2VGcmFtZSIsInVzZVRocmVlIiwiVEhSRUUiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsIlhQQkRSb3BlIiwiZHByIiwidmlld3BvcnQiLCJnbCIsInNjZW5lIiwiY2FtZXJhIiwidW5pZm9ybXMiLCJpVGltZSIsInZhbHVlIiwiaVRpbWVEZWx0YSIsImlGcmFtZSIsImlSZXNvbHV0aW9uIiwiVmVjdG9yMiIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImlNb3VzZSIsIlZlY3RvcjQiLCJpQ2hhbm5lbDAiLCJUZXh0dXJlIiwiY3VycmVudCIsInJlbmRlclRhcmdldHMiLCJXZWJHTFJlbmRlclRhcmdldCIsIm1pbkZpbHRlciIsIk5lYXJlc3RGaWx0ZXIiLCJtYWdGaWx0ZXIiLCJmb3JtYXQiLCJSR0JBRm9ybWF0IiwidHlwZSIsIkZsb2F0VHlwZSIsImJ1ZmZlckluZGV4IiwibGFzdFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInNldCIsInRleHR1cmUiLCJzZXRSZW5kZXJUYXJnZXQiLCJyZW5kZXIiLCJoYW5kbGVNb3VzZU1vdmUiLCJldmVudCIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJoYW5kbGVNb3VzZURvd24iLCJidXR0b24iLCJ6IiwiaGFuZGxlTW91c2VVcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibWVzaCIsInNjYWxlIiwid2lkdGgiLCJoZWlnaHQiLCJwbGFuZUdlb21ldHJ5IiwiYXJncyIsInNoYWRlck1hdGVyaWFsIiwiWFBCRFJvcGVQYWdlIiwib3J0aG9ncmFwaGljIiwicG9zaXRpb24iLCJzdHlsZSIsInRvcCIsImxlZnQiLCJmYWxsYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A4/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_ce.glsl":
/*!*************************************************************!*\
  !*** ./src/app/(assignment)/assignment/A4/fragment_ce.glsl ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"precision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vUv; // UV (screen) coordinates in [0,1]^2\\n\\nuniform float iTime;\\nuniform float iTimeDelta;\\nuniform float iFrame;\\nuniform vec2 iResolution;\\nuniform vec4 iMouse;\\nuniform sampler2D iChannel0;\\n\\nfloat remap01(float inp, float inp_start, float inp_end) {\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\\n}\\nfloat dist_sqr(vec2 a, vec2 b) {\\n    vec2 diff = a - b;\\n    return dot(diff, diff);\\n}\\n\\nconst float RADIUS = 0.015;\\n\\n// ------------------------------------------------------------\\n// Particle structure\\nstruct Particle {\\n    vec2 pos;\\n    vec2 pos_prev;\\n    vec2 vel;\\n    float inv_mass;\\n    bool is_fixed;\\n};\\n\\n// Simulation constants\\nconst float damp = 2.0;\\nconst float collision_dist = RADIUS * 1.5;\\nconst float ground_collision_dist = collision_dist * 0.1;\\nconst vec2 gravity = vec2(0.0, -1.);\\n\\nconst float PI = 3.14159265359;\\n\\n// Define n_rope rope particles and add one extra \\\"mouse particle\\\".\\nconst int MAX_PARTICLES = 100;\\nconst int MAX_SPRINGS = 40;\\n\\n//0: mouse particle\\n//1...5: rope particles\\nint n_particles;\\nParticle particles[MAX_PARTICLES];\\n\\nint nearest_particle(vec2 p) {\\n    int idx = 1;\\n    float min_dist = 1e9;\\n    for (int i = 1; i < n_particles; i++) {\\n        float d = dist_sqr(p, particles[i].pos);\\n        if (d < min_dist) {\\n            min_dist = d;\\n            idx = i;\\n        }\\n    }\\n    return idx;\\n}\\n\\n// ------------------------------------------------------------\\n// Spring structure\\nstruct Spring {\\n    int a;\\n    int b;\\n    float restLength;\\n    float inv_stiffness;\\n};\\n// Create springs between adjacent rope particles (n_rope-1 springs)\\n// and one spring connecting the last rope particle and the mouse particle.\\nSpring springs[MAX_SPRINGS];\\nint n_springs;\\nint selected_particle = -1;\\nint current_add_particle = -1;\\n\\nSpring add_spring(int a, int b, float inv_stiffness){\\n    Spring s;\\n    s.a = a;\\n    s.b = b;\\n    s.restLength = length(particles[a].pos - particles[b].pos);\\n    s.inv_stiffness = inv_stiffness;\\n    return s;\\n}\\n\\nconst int initial_particles = 40;\\n\\nvoid init_state(void) {\\n    n_particles = initial_particles;\\n    n_springs = initial_particles - 1;\\n\\n    float x_start = -0.9;\\n    float x_end = -0.3;\\n    float y_start = 0.4;\\n    float y_end = -0.3;\\n\\n    for (int i = 1; i < initial_particles; i++) {\\n        float t = float(i - 1) / float(initial_particles - 2);\\n        float x = mix(x_start, x_end, t);\\n        float y = mix(y_start, y_end, t);\\n        particles[i].pos = vec2(x, y);\\n        particles[i].vel = vec2(0.0);\\n        particles[i].inv_mass = 1.0;\\n        particles[i].is_fixed = false;\\n    }\\n    current_add_particle = initial_particles;\\n\\n    // Add springs between adjacent particles\\n    for (int i = 1; i < initial_particles - 1; i++) {\\n        springs[i] = add_spring(i, i + 1, 1.0 / 80000.0);\\n    }\\n}\\n\\nvec2 screen_to_xy(vec2 coord) {\\n    return (coord - 0.5 * iResolution.xy) * 2.0 / iResolution.y;\\n}\\n\\nbool is_initializing() {\\n    return iTime < 0.06 || iFrame < 2.;\\n}\\n\\n// Load rope particles from the previous frame and update the mouse particle.\\nvoid load_state() {\\n    //0,0: (num_particles, num_springs, selected_particle)\\n\\n    vec4 data = texelFetch(iChannel0, ivec2(0, 0), 0);\\n    n_particles = int(data.x);\\n    n_springs = int(data.y);\\n    selected_particle = int(data.z);\\n    current_add_particle = int(data.w);\\n\\n    //initialize mouse particle\\n    {\\n        int mouse_idx = 0;\\n        particles[mouse_idx].pos = screen_to_xy(iMouse.xy);\\n        particles[mouse_idx].vel = vec2(0.0);\\n        particles[mouse_idx].inv_mass = 0.0; // fixed particle\\n        particles[mouse_idx].is_fixed = true;\\n    }\\n    // Load other particles\\n    for (int i = 1; i < n_particles; i++) {\\n        vec4 data = texelFetch(iChannel0, ivec2(i, 0), 0);\\n        particles[i].pos = data.xy;\\n        particles[i].vel = data.zw;\\n        particles[i].inv_mass = 1.0; // all particles have mass 1.0\\n        particles[i].is_fixed = false;\\n\\n        if(i==1 || i==initial_particles-1){\\n        // if(i == 1){\\n            particles[i].inv_mass = 0.0; // fixed particles at the ends of the rope\\n            particles[i].is_fixed = true; // make sure the first and last particles are fixed\\n        }\\n    }\\n\\n    //select nearest particle to mouse\\n    if(iMouse.z == 1.){\\n        if(selected_particle == -1){\\n            selected_particle = nearest_particle(particles[0].pos);\\n        }\\n    }\\n    else{\\n        selected_particle = -1;\\n    }\\n    \\n    if(iMouse.z == 2.){\\n        particles[current_add_particle].pos = screen_to_xy(iMouse.xy); // update the position of the selected particle\\n        particles[current_add_particle].vel = vec2(0.0); // reset velocity to zero when mouse is released\\n        particles[current_add_particle].inv_mass = 1.0; // make sure the selected particle is fixed\\n        particles[current_add_particle].is_fixed = false; // make sure the selected particle is fixed\\n        if(current_add_particle >= n_particles){\\n            // If we reach the maximum number of particles, reset to the first available index.\\n            n_particles = current_add_particle + 1; // skip the mouse particle at index 0\\n        }\\n        current_add_particle++;\\n        if(current_add_particle >= MAX_PARTICLES){\\n            current_add_particle = initial_particles;\\n        }\\n    }\\n\\n    //load springs\\n    springs[0] = Spring(0, selected_particle, 0.0, 1.0 / 100.0); // mouse particle to first rope particle\\n    for (int i = 1; i < n_springs; i++) {\\n        vec4 data = texelFetch(iChannel0, ivec2(i, 1), 0);\\n        springs[i].a = int(data.x);\\n        springs[i].b = int(data.y);\\n        springs[i].restLength = data.z;\\n        springs[i].inv_stiffness = data.w;\\n    }\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 1.1: Computing the spring constraint\\n//// This function calculates the deviation of a spring's length \\n//// from its rest length. The constraint is defined as L - L0, \\n//// This constraint is later used to adjust the positions of particles \\n//// to enforce the spring constraint.\\n/////////////////////////////////////////////////////\\nfloat spring_constraint(Spring s) {\\n    // The spring has two endpoints a and b.\\n    // Their positions are particles[s.a].pos and particles[s.b].pos respectively.\\n    // The spring constraint is L-L0, where L is the current length of the spring\\n    // and L0 = s.restLength is the rest length of the spring.\\n\\n    //// Your implementation starts\\n    return length(particles[s.a].pos - particles[s.b].pos) - s.restLength;\\n    //// Your implementation ends\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 1.2: Computing the spring constraint gradient\\n//// This function calculates the gradient of the spring constraint constraint \\n//// for a spring a--b with respect to the position of a.\\n/////////////////////////////////////////////////////\\nvec2 spring_constraint_gradient(vec2 a, vec2 b) {\\n    // Gradient of the spring constraint for points a,b with respect to a.\\n    // Think: what is the gradient of (a-b) with respect to a?\\n\\n    //// Your implementation starts\\n    vec2 diff = a - b;\\n    float dist = length(diff);\\n    return (dist == 0.0) ? vec2(0.0) : diff / dist;\\n    //// Your implementation ends\\n}\\n\\n// Compute the gradient of the spring constraint with respect to a given particle.\\nvec2 spring_constraint_grad(Spring s, int particle_idx) {\\n    float sgn = (particle_idx == s.a) ? 1.0 : -1.0;\\n    return sgn * spring_constraint_gradient(particles[s.a].pos, particles[s.b].pos);\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 1.3: Solving a single spring constraint\\n//// Calculate the numerator and denominator for the Lagrangian multiplier update.\\n//// You will calculate the numer/denom for PBD updates.\\n//// The Lagrangian multiplier update is calculated with lambda=(numer/denom)\\n//// See the documentation for more details.\\n/////////////////////////////////////////////////////\\nvoid solve_spring(Spring s, float dt) {   \\n    float numer = 0.;\\n    float denom = 0.;\\n\\n    //// Your implementation starts\\n    // vec2 grad_a = vec2(0.); // only keep for the sake of the compiler\\n    // vec2 grad_b = vec2(0.); // only keep for the sake of the compiler\\n\\n    numer = -spring_constraint(s);\\n\\n    vec2 grad_a = spring_constraint_grad(s, s.a);\\n    vec2 grad_b = spring_constraint_grad(s, s.b);\\n\\n    float inertial_a = particles[s.a].inv_mass * dot(grad_a, grad_a);\\n    float inertial_b = particles[s.b].inv_mass * dot(grad_b, grad_b);\\n\\n    denom = inertial_a + inertial_b;\\n\\n    //// Your implementation ends\\n\\n    // PBD if you comment out the following line\\n    denom += s.inv_stiffness / (dt * dt);\\n    \\n    if (denom == 0.0) return;\\n    float lambda = numer / denom;\\n    particles[s.a].pos += lambda * particles[s.a].inv_mass * grad_a;\\n    particles[s.b].pos += lambda * particles[s.b].inv_mass * grad_b;\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 2.1: Computing the collision constraint\\n//// If two particles a,b are closer than collision_dist,\\n//// a spring constraint is applied to separate them.\\n//// The rest length of the spring is set to collision_dist.\\n//// Otherwise return 0.0.\\n/////////////////////////////////////////////////////\\nfloat collision_constraint(vec2 a, vec2 b, float collision_dist){\\n    // Compute the distance between two particles a and b.\\n    // The constraint is defined as L - L0, where L is the current distance between a and b\\n    // and L0 = collision_dist is the minimum distance between a and b.\\n\\n    float dist = length(a - b);\\n    if(dist < collision_dist){\\n        //// Your implementation starts\\n        return dist - collision_dist;\\n        //// Your implementation ends\\n    }\\n    else{\\n        return 0.0;\\n    }\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 2.2: Computing the collision constraint gradient\\n//// If two particles a,b are closer than collision_dist,\\n//// calculate the gradient of the collision constraint with respect to a.\\n//// It's similar to the spring constraint gradient.\\n//// Otherwise return vec2(0.0, 0.0).\\n/////////////////////////////////////////////////////\\nvec2 collision_constraint_gradient(vec2 a, vec2 b, float collision_dist){\\n    // Compute the gradient of the collision constraint with respect to a.\\n\\n    float dist = length(a - b);\\n    if(dist <= collision_dist){\\n        //// Your implementation starts\\n        // return (dist == 0.0) ? vec2(0.0) : (a - b) / dist;\\n        return (a - b) / dist;\\n        //// Your implementation ends\\n    }\\n    else{\\n        return vec2(0.0, 0.0);\\n    }\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 2.3: Solving a single collision constraint\\n//// It solves for the collision constraint between particle i and j.\\n//// Calculate the numerator and denominator for the Lagrangian multiplier update.\\n//// You will calculate the numer/denom for PBD updates.\\n//// The Lagrangian multiplier update is calculated with lambda=(numer/denom)\\n//// See the documentation for more details.\\n/////////////////////////////////////////////////////\\nvoid solve_collision_constraint(int i, int j, float collision_dist, float dt){\\n    // Compute the collision constraint for particles i and j.\\n    float numer = 0.0;\\n    float denom = 0.0;\\n\\n    //// Your implementation starts\\n    vec2 a = particles[i].pos;\\n    vec2 b = particles[j].pos;\\n    vec2 grad = collision_constraint_gradient(a, b, collision_dist);\\n\\n    if (grad == vec2(0.0)) return; // no collision\\n\\n    numer = -collision_constraint(a, b, collision_dist);\\n    float inertial_a = particles[i].inv_mass * dot(grad, grad);\\n    float inertial_b = particles[j].inv_mass * dot(grad, grad);\\n    denom = inertial_a + inertial_b;\\n    //// Your implementation ends\\n\\n    //PBD if you comment out the following line, which is faster\\n    denom += (1. / 1000.) / (dt * dt);\\n\\n    if (denom == 0.0) return;\\n    float lambda = numer / denom;\\n    particles[i].pos += lambda * particles[i].inv_mass * grad;\\n    particles[j].pos -= lambda * particles[j].inv_mass * grad;\\n}\\n\\nfloat phi(vec2 p){\\n    const float PI = 3.14159265359;\\n    //let's do sin(x)+0.5\\n    return p.y - (0.1 * sin(p.x * 2. * PI) - 0.5);\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 3.1: Computing the ground constraint\\n//// For a point p, if phi(p) < ground_collision_dist,\\n//// we set a constraint to push the point away from the ground.\\n//// The constraint is defined as phi(p) - ground_collision_dist.\\n//// Otherwise return 0.0.\\n/////////////////////////////////////////////////////\\nfloat ground_constraint(vec2 p, float ground_collision_dist){\\n    if(phi(p) < ground_collision_dist){\\n        //// Your implementation starts\\n        return phi(p) - ground_collision_dist;\\n        //// Your implementation ends\\n    }\\n    else{\\n        return 0.0;\\n    }    \\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 3.2: Computing the ground constraint gradient\\n//// If phi(p) < ground_collision_dist, \\n//// compute the gradient of the ground constraint.\\n//// Otherwise return vec2(0.0, 0.0).\\n/////////////////////////////////////////////////////\\nvec2 ground_constraint_gradient(vec2 p, float ground_collision_dist){\\n    // Compute the gradient of the ground constraint with respect to p.\\n\\n    if(phi(p) < ground_collision_dist){\\n        //// Your implementation starts\\n        float grad_x = -0.2 * PI * cos(2.0 * PI * p.x);\\n        float grad_y = 1.0;\\n        return vec2(grad_x, grad_y); \\n        //// Your implementation ends\\n    }\\n    else{\\n        return vec2(0.0, 0.0);\\n    }\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 3.3: Solving a single ground constraint\\n//// It solves for the ground constraint for particle i.\\n//// Calculate the numerator and denominator for the Lagrangian multiplier update.\\n//// You will calculate the numer/denom for PBD updates.\\n//// The Lagrangian multiplier update is calculated with lambda=(numer/denom)\\n//// See the documentation for more details.\\n/////////////////////////////////////////////////////\\nvoid solve_ground_constraint(int i, float ground_collision_dist, float dt){\\n    // Compute the ground constraint for particle i.\\n    float numer = 0.0;\\n    float denom = 0.0;\\n\\n    //// Your implementation starts\\n    vec2 p_i = particles[i].pos;\\n    vec2 grad = ground_constraint_gradient(p_i, ground_collision_dist);\\n    \\n    numer = -ground_constraint(p_i, ground_collision_dist);\\n    denom = particles[i].inv_mass * dot(grad, grad);\\n\\n    //// Your implementation ends\\n\\n    //PBD if you comment out the following line, which is faster\\n    denom += (1. / 1000.) / (dt * dt);\\n\\n    if (denom == 0.0) return;\\n    float lambda = numer / denom;\\n    particles[i].pos += lambda * particles[i].inv_mass * grad;\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 10: Solving all constraints\\n//// You need to solve for all 3 types of constraints using previously defined functions:\\n//// 1. Spring constraints defined by springs[1] to springs[n_springs-1]\\n//// 2. Ground constraints for all particles (except the mouse particle 0).\\n//// 3. Collision constraints for all pairs of particles (except the mouse particle 0).\\n/////////////////////////////////////////////////////\\nvoid solve_constraints(float dt) {\\n    //If left mouse is pressed, calculate the spring constraint for the mouse particle to the first rope particle.\\n    if(iMouse.z == 1.){\\n        solve_spring(springs[0], dt); // mouse particle to first rope particle\\n    }\\n\\n    // Solve all constraints\\n\\n    //// Your implementation starts\\n\\n    // Spring Constraints\\n    for (int i = 1; i < n_springs; i++) {\\n        solve_spring(springs[i], dt);\\n    }\\n    // Collision Constraints between every pair of particles\\n    for (int i = 1; i < n_particles; i++) {\\n        for (int j = i + 1; j < n_particles; j++) {\\n            solve_collision_constraint(i, j, collision_dist, dt);\\n        }\\n    }\\n    // Ground Constraints\\n    for (int i = 1; i < n_particles; i++) {\\n        solve_ground_constraint(i, ground_collision_dist, dt);\\n    }\\n\\n    //// Your implementation ends\\n}\\n\\nfloat dist_to_segment(vec2 p, vec2 a, vec2 b) {\\n    vec2 pa = p - a;\\n    vec2 ba = b - a;\\n    // Compute the projection factor and clamp it between 0 and 1.\\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n    // Return the distance from p to the closest point on the segment.\\n    return length(pa - h * ba);\\n}\\n\\n// quadratic polynomial smoothed minimum: https://iquilezles.org/articles/smin/\\nfloat smin( float a, float b, float k )\\n{\\n    k *= 4.0;\\n    float h = max( k-abs(a-b), 0.0 )/k;\\n    return min(a,b) - h*h*k*(1.0/4.0);\\n}\\n\\nvec3 render_scene(vec2 pixel_xy) {\\n    float phi = phi(pixel_xy);\\n    vec3 col;\\n    if(phi < 0.0) {\\n        float t = remap01(phi, 0.0, -1.0);\\n        vec3 color1 = vec3(0.82); // light blue\\n        vec3 color2 = vec3(0.34, 0.35, 0.35); // dark blue\\n        vec3 color = mix(color1, color2, t);\\n        return color;\\n    }\\n    else{\\n        // col = vec3(229, 242, 250) / 255.; // background color\\n        // Render a gradient background\\n        float t = remap01(pixel_xy.y, 0.0, 1.0);\\n        vec3 color1 = vec3(0.9, 0.69, 0.46); // light blue\\n        vec3 color2 = vec3(0.97, 0.73, 1.0); // dark blue\\n        col = mix(color1, color2, t);\\n    }\\n    \\n    float pixel_size = 2.0 / iResolution.y;\\n    \\n    // If still initializing, return the background color.\\n    if (is_initializing()) {\\n        return col;\\n    }\\n\\n    // Render fluid particles\\n    {\\n        float distance = length(pixel_xy - particles[1].pos);\\n\\n        for (int i = initial_particles; i < n_particles; i++) {\\n            distance = smin(distance, length(pixel_xy - particles[i].pos), RADIUS);\\n            // if (distance < RADIUS) {\\n            //     float t = remap01(distance, RADIUS * 0.7, RADIUS * 2.);\\n            //     vec3 color1 = vec3(0.17, 0.71, 1.0); // light blue\\n            //     vec3 color2 = vec3(1.0); // dark blue\\n            //     vec3 color = mix(color1, color2, t);\\n            //     // vec3 color = vec3(0.49, 0.69, 0.92);\\n            //     col = color;\\n            //     // break;\\n            // }\\n        }\\n        if (distance < RADIUS) {\\n            float t = remap01(distance, RADIUS * 0.8, RADIUS * 1.1);\\n            vec3 color1 = vec3(0.45, 0.81, 1.0); // light blue\\n            vec3 color2 = vec3(1.0); // dark blue\\n            vec3 color = mix(color1, color2, t);\\n            // vec3 color = vec3(0.49, 0.69, 0.92);\\n            col = color;\\n            // break;\\n        }\\n    }\\n    \\n    // Render All springs\\n    {\\n        float min_dist = 1e9;\\n\\n        if(iMouse.z == 1.){\\n            min_dist = dist_to_segment(pixel_xy, particles[0].pos, particles[selected_particle].pos);\\n        }\\n\\n        for (int i = 1; i < n_springs; i++) {\\n            int a = springs[i].a;\\n            int b = springs[i].b;\\n            min_dist = min(min_dist, dist_to_segment(pixel_xy, particles[a].pos, particles[b].pos));\\n        }\\n\\n        const float thickness = RADIUS;\\n        if (min_dist < thickness) {\\n            float t = remap01(min_dist, 0.0, thickness * 2.);\\n            vec3 color1 = vec3(0.85);\\n            vec3 color2 = vec3(0.58);\\n            vec3 color = mix(color1, color2, t);\\n            col = color;\\n        }\\n    }\\n\\n    // col.z = 1.0;\\n    return col;\\n}\\n\\nvec4 output_color(vec2 pixel_ij){\\n    int i = int(pixel_ij.x);\\n    int j = int(pixel_ij.y);\\n    \\n    if(j == 0){\\n        // (0,0): (num_particles, num_springs, selected_particle)\\n        if(i==0){\\n            return vec4(float(n_particles), float(n_springs), float(selected_particle), float(current_add_particle));\\n        }\\n        else if(i < n_particles){\\n            //a particle\\n            return vec4(particles[i].pos, particles[i].vel);\\n        }\\n        else{\\n            return vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n    else if(j == 1){\\n        if(i < n_springs){\\n            return vec4(float(springs[i].a), float(springs[i].b), springs[i].restLength, springs[i].inv_stiffness);\\n        }\\n        else{\\n            return vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n    else{\\n        vec2 pixel_xy = screen_to_xy(pixel_ij);\\n        vec3 color = render_scene(pixel_xy);\\n        return vec4(color, 1.0);\\n    }\\n}\\n\\n// ------------------------------------------------------------\\n// Main function\\nvoid main() {\\n    vec2 pixel_ij = vUv * iResolution.xy;\\n    int pixel_i = int(pixel_ij.x);\\n    int pixel_j = int(pixel_ij.y);\\n\\n    if(is_initializing()){\\n        init_state();\\n    }\\n    else{\\n        load_state();\\n        if (pixel_j == 0) {\\n            if (pixel_i >= n_particles) return;\\n\\n            float actual_dt = min(iTimeDelta, 0.02);\\n            const int n_steps = 5;\\n            float dt = actual_dt / float(n_steps);\\n\\n            for (int i = 0; i < n_steps; i++) {\\n                // Update rope particles only; skip updating the mouse particle since it's fixed.\\n                for (int j = 0; j < n_particles; j++) {\\n                    if (!particles[j].is_fixed)\\n                        particles[j].vel += dt * gravity;\\n                    particles[j].vel *= exp(-damp * dt);\\n                    particles[j].pos_prev = particles[j].pos;\\n                    particles[j].pos += dt * particles[j].vel;\\n                }\\n                solve_constraints(dt);\\n                // Update velocities for rope particles only.\\n                for (int j = 0; j < n_particles; j++) {\\n                    if (!particles[j].is_fixed){\\n                        particles[j].vel = (particles[j].pos - particles[j].pos_prev) / dt;\\n                    }\\n                }\\n                // Keep the mouse particle fixed by reassigning its position each step.\\n                int mouse_idx = 0;\\n                particles[mouse_idx].pos = screen_to_xy(iMouse.xy);\\n            }\\n        }\\n    }\\n\\n    gl_FragColor = output_color(pixel_ij);\\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvZnJhZ21lbnRfY2UuZ2xzbCIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsdUJBQXVCLHVDQUF1Qyw2REFBNkQsMkJBQTJCLHVCQUF1QiwyQkFBMkIsc0JBQXNCLDhCQUE4Qiw4REFBOEQsd0VBQXdFLEdBQUcsa0NBQWtDLHdCQUF3Qiw2QkFBNkIsR0FBRywrQkFBK0IsNkdBQTZHLGVBQWUsb0JBQW9CLGVBQWUscUJBQXFCLG9CQUFvQixJQUFJLG9EQUFvRCw0Q0FBNEMsMkRBQTJELHNDQUFzQyxtQ0FBbUMseUdBQXlHLDZCQUE2QixrRUFBa0Usb0NBQW9DLGtDQUFrQyxrQkFBa0IsMkJBQTJCLHNCQUFzQixpQkFBaUIsTUFBTSxrREFBa0QsNkJBQTZCLDJCQUEyQixzQkFBc0IsV0FBVyxPQUFPLGlCQUFpQixHQUFHLHlHQUF5RyxZQUFZLFlBQVksdUJBQXVCLDBCQUEwQixJQUFJLGlMQUFpTCxnQkFBZ0IsNkJBQTZCLGdDQUFnQyx5REFBeUQsZUFBZSxjQUFjLGNBQWMsaUVBQWlFLHNDQUFzQyxlQUFlLEdBQUcscUNBQXFDLDJCQUEyQixzQ0FBc0Msd0NBQXdDLDZCQUE2Qix5QkFBeUIsMEJBQTBCLHlCQUF5Qix3QkFBd0IsdUJBQXVCLE1BQU0sZ0VBQWdFLDJDQUEyQywyQ0FBMkMsd0NBQXdDLHVDQUF1QyxzQ0FBc0Msd0NBQXdDLE9BQU8sK0NBQStDLHVFQUF1RSwyQkFBMkIsTUFBTSwyREFBMkQsT0FBTyxHQUFHLG1DQUFtQyxrRUFBa0UsR0FBRyw0QkFBNEIseUNBQXlDLEdBQUcsc0dBQXNHLHNIQUFzSCxnQ0FBZ0MsOEJBQThCLHNDQUFzQyx5Q0FBeUMsMENBQTBDLDRCQUE0Qiw2REFBNkQsK0NBQStDLCtDQUErQyxnRUFBZ0UsT0FBTyxtREFBbUQsaUJBQWlCLE1BQU0sNERBQTRELHFDQUFxQyxxQ0FBcUMsdUNBQXVDLHNFQUFzRSwrQ0FBK0Msd0JBQXdC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LFdBQVcsdUJBQXVCLDZCQUE2QixpREFBaUQsd0RBQXdELG9DQUFvQyxvREFBb0QsZ0NBQWdDLGFBQWEsTUFBTSxpREFBaUQsb0ZBQW9GLGlCQUFpQixNQUFNLDRHQUE0RywwREFBMEQsK0RBQStELGdFQUFnRSxtQkFBbUIsd0NBQXdDLGlHQUFpRyxpQkFBaUIsTUFBTSxrREFBa0QsNkZBQTZGLHVCQUF1QixtQkFBbUIsNkhBQTZILHFFQUFxRSxlQUFlLFdBQVcsT0FBTyw4Q0FBOEMsR0FBRyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvZnJhZ21lbnRfY2UuZ2xzbD8wNmRlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZVdjsgLy8gVVYgKHNjcmVlbikgY29vcmRpbmF0ZXMgaW4gWzAsMV1eMlxcblxcbnVuaWZvcm0gZmxvYXQgaVRpbWU7XFxudW5pZm9ybSBmbG9hdCBpVGltZURlbHRhO1xcbnVuaWZvcm0gZmxvYXQgaUZyYW1lO1xcbnVuaWZvcm0gdmVjMiBpUmVzb2x1dGlvbjtcXG51bmlmb3JtIHZlYzQgaU1vdXNlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGlDaGFubmVsMDtcXG5cXG5mbG9hdCByZW1hcDAxKGZsb2F0IGlucCwgZmxvYXQgaW5wX3N0YXJ0LCBmbG9hdCBpbnBfZW5kKSB7XFxuICAgIHJldHVybiBjbGFtcCgoaW5wIC0gaW5wX3N0YXJ0KSAvIChpbnBfZW5kIC0gaW5wX3N0YXJ0KSwgMC4wLCAxLjApO1xcbn1cXG5mbG9hdCBkaXN0X3Nxcih2ZWMyIGEsIHZlYzIgYikge1xcbiAgICB2ZWMyIGRpZmYgPSBhIC0gYjtcXG4gICAgcmV0dXJuIGRvdChkaWZmLCBkaWZmKTtcXG59XFxuXFxuY29uc3QgZmxvYXQgUkFESVVTID0gMC4wMTU7XFxuXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gUGFydGljbGUgc3RydWN0dXJlXFxuc3RydWN0IFBhcnRpY2xlIHtcXG4gICAgdmVjMiBwb3M7XFxuICAgIHZlYzIgcG9zX3ByZXY7XFxuICAgIHZlYzIgdmVsO1xcbiAgICBmbG9hdCBpbnZfbWFzcztcXG4gICAgYm9vbCBpc19maXhlZDtcXG59O1xcblxcbi8vIFNpbXVsYXRpb24gY29uc3RhbnRzXFxuY29uc3QgZmxvYXQgZGFtcCA9IDIuMDtcXG5jb25zdCBmbG9hdCBjb2xsaXNpb25fZGlzdCA9IFJBRElVUyAqIDEuNTtcXG5jb25zdCBmbG9hdCBncm91bmRfY29sbGlzaW9uX2Rpc3QgPSBjb2xsaXNpb25fZGlzdCAqIDAuMTtcXG5jb25zdCB2ZWMyIGdyYXZpdHkgPSB2ZWMyKDAuMCwgLTEuKTtcXG5cXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTk7XFxuXFxuLy8gRGVmaW5lIG5fcm9wZSByb3BlIHBhcnRpY2xlcyBhbmQgYWRkIG9uZSBleHRyYSBcXFwibW91c2UgcGFydGljbGVcXFwiLlxcbmNvbnN0IGludCBNQVhfUEFSVElDTEVTID0gMTAwO1xcbmNvbnN0IGludCBNQVhfU1BSSU5HUyA9IDQwO1xcblxcbi8vMDogbW91c2UgcGFydGljbGVcXG4vLzEuLi41OiByb3BlIHBhcnRpY2xlc1xcbmludCBuX3BhcnRpY2xlcztcXG5QYXJ0aWNsZSBwYXJ0aWNsZXNbTUFYX1BBUlRJQ0xFU107XFxuXFxuaW50IG5lYXJlc3RfcGFydGljbGUodmVjMiBwKSB7XFxuICAgIGludCBpZHggPSAxO1xcbiAgICBmbG9hdCBtaW5fZGlzdCA9IDFlOTtcXG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuX3BhcnRpY2xlczsgaSsrKSB7XFxuICAgICAgICBmbG9hdCBkID0gZGlzdF9zcXIocCwgcGFydGljbGVzW2ldLnBvcyk7XFxuICAgICAgICBpZiAoZCA8IG1pbl9kaXN0KSB7XFxuICAgICAgICAgICAgbWluX2Rpc3QgPSBkO1xcbiAgICAgICAgICAgIGlkeCA9IGk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGlkeDtcXG59XFxuXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gU3ByaW5nIHN0cnVjdHVyZVxcbnN0cnVjdCBTcHJpbmcge1xcbiAgICBpbnQgYTtcXG4gICAgaW50IGI7XFxuICAgIGZsb2F0IHJlc3RMZW5ndGg7XFxuICAgIGZsb2F0IGludl9zdGlmZm5lc3M7XFxufTtcXG4vLyBDcmVhdGUgc3ByaW5ncyBiZXR3ZWVuIGFkamFjZW50IHJvcGUgcGFydGljbGVzIChuX3JvcGUtMSBzcHJpbmdzKVxcbi8vIGFuZCBvbmUgc3ByaW5nIGNvbm5lY3RpbmcgdGhlIGxhc3Qgcm9wZSBwYXJ0aWNsZSBhbmQgdGhlIG1vdXNlIHBhcnRpY2xlLlxcblNwcmluZyBzcHJpbmdzW01BWF9TUFJJTkdTXTtcXG5pbnQgbl9zcHJpbmdzO1xcbmludCBzZWxlY3RlZF9wYXJ0aWNsZSA9IC0xO1xcbmludCBjdXJyZW50X2FkZF9wYXJ0aWNsZSA9IC0xO1xcblxcblNwcmluZyBhZGRfc3ByaW5nKGludCBhLCBpbnQgYiwgZmxvYXQgaW52X3N0aWZmbmVzcyl7XFxuICAgIFNwcmluZyBzO1xcbiAgICBzLmEgPSBhO1xcbiAgICBzLmIgPSBiO1xcbiAgICBzLnJlc3RMZW5ndGggPSBsZW5ndGgocGFydGljbGVzW2FdLnBvcyAtIHBhcnRpY2xlc1tiXS5wb3MpO1xcbiAgICBzLmludl9zdGlmZm5lc3MgPSBpbnZfc3RpZmZuZXNzO1xcbiAgICByZXR1cm4gcztcXG59XFxuXFxuY29uc3QgaW50IGluaXRpYWxfcGFydGljbGVzID0gNDA7XFxuXFxudm9pZCBpbml0X3N0YXRlKHZvaWQpIHtcXG4gICAgbl9wYXJ0aWNsZXMgPSBpbml0aWFsX3BhcnRpY2xlcztcXG4gICAgbl9zcHJpbmdzID0gaW5pdGlhbF9wYXJ0aWNsZXMgLSAxO1xcblxcbiAgICBmbG9hdCB4X3N0YXJ0ID0gLTAuOTtcXG4gICAgZmxvYXQgeF9lbmQgPSAtMC4zO1xcbiAgICBmbG9hdCB5X3N0YXJ0ID0gMC40O1xcbiAgICBmbG9hdCB5X2VuZCA9IC0wLjM7XFxuXFxuICAgIGZvciAoaW50IGkgPSAxOyBpIDwgaW5pdGlhbF9wYXJ0aWNsZXM7IGkrKykge1xcbiAgICAgICAgZmxvYXQgdCA9IGZsb2F0KGkgLSAxKSAvIGZsb2F0KGluaXRpYWxfcGFydGljbGVzIC0gMik7XFxuICAgICAgICBmbG9hdCB4ID0gbWl4KHhfc3RhcnQsIHhfZW5kLCB0KTtcXG4gICAgICAgIGZsb2F0IHkgPSBtaXgoeV9zdGFydCwgeV9lbmQsIHQpO1xcbiAgICAgICAgcGFydGljbGVzW2ldLnBvcyA9IHZlYzIoeCwgeSk7XFxuICAgICAgICBwYXJ0aWNsZXNbaV0udmVsID0gdmVjMigwLjApO1xcbiAgICAgICAgcGFydGljbGVzW2ldLmludl9tYXNzID0gMS4wO1xcbiAgICAgICAgcGFydGljbGVzW2ldLmlzX2ZpeGVkID0gZmFsc2U7XFxuICAgIH1cXG4gICAgY3VycmVudF9hZGRfcGFydGljbGUgPSBpbml0aWFsX3BhcnRpY2xlcztcXG5cXG4gICAgLy8gQWRkIHNwcmluZ3MgYmV0d2VlbiBhZGphY2VudCBwYXJ0aWNsZXNcXG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBpbml0aWFsX3BhcnRpY2xlcyAtIDE7IGkrKykge1xcbiAgICAgICAgc3ByaW5nc1tpXSA9IGFkZF9zcHJpbmcoaSwgaSArIDEsIDEuMCAvIDgwMDAwLjApO1xcbiAgICB9XFxufVxcblxcbnZlYzIgc2NyZWVuX3RvX3h5KHZlYzIgY29vcmQpIHtcXG4gICAgcmV0dXJuIChjb29yZCAtIDAuNSAqIGlSZXNvbHV0aW9uLnh5KSAqIDIuMCAvIGlSZXNvbHV0aW9uLnk7XFxufVxcblxcbmJvb2wgaXNfaW5pdGlhbGl6aW5nKCkge1xcbiAgICByZXR1cm4gaVRpbWUgPCAwLjA2IHx8IGlGcmFtZSA8IDIuO1xcbn1cXG5cXG4vLyBMb2FkIHJvcGUgcGFydGljbGVzIGZyb20gdGhlIHByZXZpb3VzIGZyYW1lIGFuZCB1cGRhdGUgdGhlIG1vdXNlIHBhcnRpY2xlLlxcbnZvaWQgbG9hZF9zdGF0ZSgpIHtcXG4gICAgLy8wLDA6IChudW1fcGFydGljbGVzLCBudW1fc3ByaW5ncywgc2VsZWN0ZWRfcGFydGljbGUpXFxuXFxuICAgIHZlYzQgZGF0YSA9IHRleGVsRmV0Y2goaUNoYW5uZWwwLCBpdmVjMigwLCAwKSwgMCk7XFxuICAgIG5fcGFydGljbGVzID0gaW50KGRhdGEueCk7XFxuICAgIG5fc3ByaW5ncyA9IGludChkYXRhLnkpO1xcbiAgICBzZWxlY3RlZF9wYXJ0aWNsZSA9IGludChkYXRhLnopO1xcbiAgICBjdXJyZW50X2FkZF9wYXJ0aWNsZSA9IGludChkYXRhLncpO1xcblxcbiAgICAvL2luaXRpYWxpemUgbW91c2UgcGFydGljbGVcXG4gICAge1xcbiAgICAgICAgaW50IG1vdXNlX2lkeCA9IDA7XFxuICAgICAgICBwYXJ0aWNsZXNbbW91c2VfaWR4XS5wb3MgPSBzY3JlZW5fdG9feHkoaU1vdXNlLnh5KTtcXG4gICAgICAgIHBhcnRpY2xlc1ttb3VzZV9pZHhdLnZlbCA9IHZlYzIoMC4wKTtcXG4gICAgICAgIHBhcnRpY2xlc1ttb3VzZV9pZHhdLmludl9tYXNzID0gMC4wOyAvLyBmaXhlZCBwYXJ0aWNsZVxcbiAgICAgICAgcGFydGljbGVzW21vdXNlX2lkeF0uaXNfZml4ZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIC8vIExvYWQgb3RoZXIgcGFydGljbGVzXFxuICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbl9wYXJ0aWNsZXM7IGkrKykge1xcbiAgICAgICAgdmVjNCBkYXRhID0gdGV4ZWxGZXRjaChpQ2hhbm5lbDAsIGl2ZWMyKGksIDApLCAwKTtcXG4gICAgICAgIHBhcnRpY2xlc1tpXS5wb3MgPSBkYXRhLnh5O1xcbiAgICAgICAgcGFydGljbGVzW2ldLnZlbCA9IGRhdGEuenc7XFxuICAgICAgICBwYXJ0aWNsZXNbaV0uaW52X21hc3MgPSAxLjA7IC8vIGFsbCBwYXJ0aWNsZXMgaGF2ZSBtYXNzIDEuMFxcbiAgICAgICAgcGFydGljbGVzW2ldLmlzX2ZpeGVkID0gZmFsc2U7XFxuXFxuICAgICAgICBpZihpPT0xIHx8IGk9PWluaXRpYWxfcGFydGljbGVzLTEpe1xcbiAgICAgICAgLy8gaWYoaSA9PSAxKXtcXG4gICAgICAgICAgICBwYXJ0aWNsZXNbaV0uaW52X21hc3MgPSAwLjA7IC8vIGZpeGVkIHBhcnRpY2xlcyBhdCB0aGUgZW5kcyBvZiB0aGUgcm9wZVxcbiAgICAgICAgICAgIHBhcnRpY2xlc1tpXS5pc19maXhlZCA9IHRydWU7IC8vIG1ha2Ugc3VyZSB0aGUgZmlyc3QgYW5kIGxhc3QgcGFydGljbGVzIGFyZSBmaXhlZFxcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vc2VsZWN0IG5lYXJlc3QgcGFydGljbGUgdG8gbW91c2VcXG4gICAgaWYoaU1vdXNlLnogPT0gMS4pe1xcbiAgICAgICAgaWYoc2VsZWN0ZWRfcGFydGljbGUgPT0gLTEpe1xcbiAgICAgICAgICAgIHNlbGVjdGVkX3BhcnRpY2xlID0gbmVhcmVzdF9wYXJ0aWNsZShwYXJ0aWNsZXNbMF0ucG9zKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBlbHNle1xcbiAgICAgICAgc2VsZWN0ZWRfcGFydGljbGUgPSAtMTtcXG4gICAgfVxcbiAgICBcXG4gICAgaWYoaU1vdXNlLnogPT0gMi4pe1xcbiAgICAgICAgcGFydGljbGVzW2N1cnJlbnRfYWRkX3BhcnRpY2xlXS5wb3MgPSBzY3JlZW5fdG9feHkoaU1vdXNlLnh5KTsgLy8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgcGFydGljbGVcXG4gICAgICAgIHBhcnRpY2xlc1tjdXJyZW50X2FkZF9wYXJ0aWNsZV0udmVsID0gdmVjMigwLjApOyAvLyByZXNldCB2ZWxvY2l0eSB0byB6ZXJvIHdoZW4gbW91c2UgaXMgcmVsZWFzZWRcXG4gICAgICAgIHBhcnRpY2xlc1tjdXJyZW50X2FkZF9wYXJ0aWNsZV0uaW52X21hc3MgPSAxLjA7IC8vIG1ha2Ugc3VyZSB0aGUgc2VsZWN0ZWQgcGFydGljbGUgaXMgZml4ZWRcXG4gICAgICAgIHBhcnRpY2xlc1tjdXJyZW50X2FkZF9wYXJ0aWNsZV0uaXNfZml4ZWQgPSBmYWxzZTsgLy8gbWFrZSBzdXJlIHRoZSBzZWxlY3RlZCBwYXJ0aWNsZSBpcyBmaXhlZFxcbiAgICAgICAgaWYoY3VycmVudF9hZGRfcGFydGljbGUgPj0gbl9wYXJ0aWNsZXMpe1xcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIHRoZSBtYXhpbXVtIG51bWJlciBvZiBwYXJ0aWNsZXMsIHJlc2V0IHRvIHRoZSBmaXJzdCBhdmFpbGFibGUgaW5kZXguXFxuICAgICAgICAgICAgbl9wYXJ0aWNsZXMgPSBjdXJyZW50X2FkZF9wYXJ0aWNsZSArIDE7IC8vIHNraXAgdGhlIG1vdXNlIHBhcnRpY2xlIGF0IGluZGV4IDBcXG4gICAgICAgIH1cXG4gICAgICAgIGN1cnJlbnRfYWRkX3BhcnRpY2xlKys7XFxuICAgICAgICBpZihjdXJyZW50X2FkZF9wYXJ0aWNsZSA+PSBNQVhfUEFSVElDTEVTKXtcXG4gICAgICAgICAgICBjdXJyZW50X2FkZF9wYXJ0aWNsZSA9IGluaXRpYWxfcGFydGljbGVzO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vbG9hZCBzcHJpbmdzXFxuICAgIHNwcmluZ3NbMF0gPSBTcHJpbmcoMCwgc2VsZWN0ZWRfcGFydGljbGUsIDAuMCwgMS4wIC8gMTAwLjApOyAvLyBtb3VzZSBwYXJ0aWNsZSB0byBmaXJzdCByb3BlIHBhcnRpY2xlXFxuICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbl9zcHJpbmdzOyBpKyspIHtcXG4gICAgICAgIHZlYzQgZGF0YSA9IHRleGVsRmV0Y2goaUNoYW5uZWwwLCBpdmVjMihpLCAxKSwgMCk7XFxuICAgICAgICBzcHJpbmdzW2ldLmEgPSBpbnQoZGF0YS54KTtcXG4gICAgICAgIHNwcmluZ3NbaV0uYiA9IGludChkYXRhLnkpO1xcbiAgICAgICAgc3ByaW5nc1tpXS5yZXN0TGVuZ3RoID0gZGF0YS56O1xcbiAgICAgICAgc3ByaW5nc1tpXS5pbnZfc3RpZmZuZXNzID0gZGF0YS53O1xcbiAgICB9XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBTdGVwIDEuMTogQ29tcHV0aW5nIHRoZSBzcHJpbmcgY29uc3RyYWludFxcbi8vLy8gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBkZXZpYXRpb24gb2YgYSBzcHJpbmcncyBsZW5ndGggXFxuLy8vLyBmcm9tIGl0cyByZXN0IGxlbmd0aC4gVGhlIGNvbnN0cmFpbnQgaXMgZGVmaW5lZCBhcyBMIC0gTDAsIFxcbi8vLy8gVGhpcyBjb25zdHJhaW50IGlzIGxhdGVyIHVzZWQgdG8gYWRqdXN0IHRoZSBwb3NpdGlvbnMgb2YgcGFydGljbGVzIFxcbi8vLy8gdG8gZW5mb3JjZSB0aGUgc3ByaW5nIGNvbnN0cmFpbnQuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5mbG9hdCBzcHJpbmdfY29uc3RyYWludChTcHJpbmcgcykge1xcbiAgICAvLyBUaGUgc3ByaW5nIGhhcyB0d28gZW5kcG9pbnRzIGEgYW5kIGIuXFxuICAgIC8vIFRoZWlyIHBvc2l0aW9ucyBhcmUgcGFydGljbGVzW3MuYV0ucG9zIGFuZCBwYXJ0aWNsZXNbcy5iXS5wb3MgcmVzcGVjdGl2ZWx5LlxcbiAgICAvLyBUaGUgc3ByaW5nIGNvbnN0cmFpbnQgaXMgTC1MMCwgd2hlcmUgTCBpcyB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHNwcmluZ1xcbiAgICAvLyBhbmQgTDAgPSBzLnJlc3RMZW5ndGggaXMgdGhlIHJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuXFxuXFxuICAgIC8vLy8gWW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG4gICAgcmV0dXJuIGxlbmd0aChwYXJ0aWNsZXNbcy5hXS5wb3MgLSBwYXJ0aWNsZXNbcy5iXS5wb3MpIC0gcy5yZXN0TGVuZ3RoO1xcbiAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gU3RlcCAxLjI6IENvbXB1dGluZyB0aGUgc3ByaW5nIGNvbnN0cmFpbnQgZ3JhZGllbnRcXG4vLy8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgb2YgdGhlIHNwcmluZyBjb25zdHJhaW50IGNvbnN0cmFpbnQgXFxuLy8vLyBmb3IgYSBzcHJpbmcgYS0tYiB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aW9uIG9mIGEuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG52ZWMyIHNwcmluZ19jb25zdHJhaW50X2dyYWRpZW50KHZlYzIgYSwgdmVjMiBiKSB7XFxuICAgIC8vIEdyYWRpZW50IG9mIHRoZSBzcHJpbmcgY29uc3RyYWludCBmb3IgcG9pbnRzIGEsYiB3aXRoIHJlc3BlY3QgdG8gYS5cXG4gICAgLy8gVGhpbms6IHdoYXQgaXMgdGhlIGdyYWRpZW50IG9mIChhLWIpIHdpdGggcmVzcGVjdCB0byBhP1xcblxcbiAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gc3RhcnRzXFxuICAgIHZlYzIgZGlmZiA9IGEgLSBiO1xcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpZmYpO1xcbiAgICByZXR1cm4gKGRpc3QgPT0gMC4wKSA/IHZlYzIoMC4wKSA6IGRpZmYgLyBkaXN0O1xcbiAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBncmFkaWVudCBvZiB0aGUgc3ByaW5nIGNvbnN0cmFpbnQgd2l0aCByZXNwZWN0IHRvIGEgZ2l2ZW4gcGFydGljbGUuXFxudmVjMiBzcHJpbmdfY29uc3RyYWludF9ncmFkKFNwcmluZyBzLCBpbnQgcGFydGljbGVfaWR4KSB7XFxuICAgIGZsb2F0IHNnbiA9IChwYXJ0aWNsZV9pZHggPT0gcy5hKSA/IDEuMCA6IC0xLjA7XFxuICAgIHJldHVybiBzZ24gKiBzcHJpbmdfY29uc3RyYWludF9ncmFkaWVudChwYXJ0aWNsZXNbcy5hXS5wb3MsIHBhcnRpY2xlc1tzLmJdLnBvcyk7XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBTdGVwIDEuMzogU29sdmluZyBhIHNpbmdsZSBzcHJpbmcgY29uc3RyYWludFxcbi8vLy8gQ2FsY3VsYXRlIHRoZSBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yIGZvciB0aGUgTGFncmFuZ2lhbiBtdWx0aXBsaWVyIHVwZGF0ZS5cXG4vLy8vIFlvdSB3aWxsIGNhbGN1bGF0ZSB0aGUgbnVtZXIvZGVub20gZm9yIFBCRCB1cGRhdGVzLlxcbi8vLy8gVGhlIExhZ3JhbmdpYW4gbXVsdGlwbGllciB1cGRhdGUgaXMgY2FsY3VsYXRlZCB3aXRoIGxhbWJkYT0obnVtZXIvZGVub20pXFxuLy8vLyBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscy5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbnZvaWQgc29sdmVfc3ByaW5nKFNwcmluZyBzLCBmbG9hdCBkdCkgeyAgIFxcbiAgICBmbG9hdCBudW1lciA9IDAuO1xcbiAgICBmbG9hdCBkZW5vbSA9IDAuO1xcblxcbiAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gc3RhcnRzXFxuICAgIC8vIHZlYzIgZ3JhZF9hID0gdmVjMigwLik7IC8vIG9ubHkga2VlcCBmb3IgdGhlIHNha2Ugb2YgdGhlIGNvbXBpbGVyXFxuICAgIC8vIHZlYzIgZ3JhZF9iID0gdmVjMigwLik7IC8vIG9ubHkga2VlcCBmb3IgdGhlIHNha2Ugb2YgdGhlIGNvbXBpbGVyXFxuXFxuICAgIG51bWVyID0gLXNwcmluZ19jb25zdHJhaW50KHMpO1xcblxcbiAgICB2ZWMyIGdyYWRfYSA9IHNwcmluZ19jb25zdHJhaW50X2dyYWQocywgcy5hKTtcXG4gICAgdmVjMiBncmFkX2IgPSBzcHJpbmdfY29uc3RyYWludF9ncmFkKHMsIHMuYik7XFxuXFxuICAgIGZsb2F0IGluZXJ0aWFsX2EgPSBwYXJ0aWNsZXNbcy5hXS5pbnZfbWFzcyAqIGRvdChncmFkX2EsIGdyYWRfYSk7XFxuICAgIGZsb2F0IGluZXJ0aWFsX2IgPSBwYXJ0aWNsZXNbcy5iXS5pbnZfbWFzcyAqIGRvdChncmFkX2IsIGdyYWRfYik7XFxuXFxuICAgIGRlbm9tID0gaW5lcnRpYWxfYSArIGluZXJ0aWFsX2I7XFxuXFxuICAgIC8vLy8gWW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxuXFxuICAgIC8vIFBCRCBpZiB5b3UgY29tbWVudCBvdXQgdGhlIGZvbGxvd2luZyBsaW5lXFxuICAgIGRlbm9tICs9IHMuaW52X3N0aWZmbmVzcyAvIChkdCAqIGR0KTtcXG4gICAgXFxuICAgIGlmIChkZW5vbSA9PSAwLjApIHJldHVybjtcXG4gICAgZmxvYXQgbGFtYmRhID0gbnVtZXIgLyBkZW5vbTtcXG4gICAgcGFydGljbGVzW3MuYV0ucG9zICs9IGxhbWJkYSAqIHBhcnRpY2xlc1tzLmFdLmludl9tYXNzICogZ3JhZF9hO1xcbiAgICBwYXJ0aWNsZXNbcy5iXS5wb3MgKz0gbGFtYmRhICogcGFydGljbGVzW3MuYl0uaW52X21hc3MgKiBncmFkX2I7XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBTdGVwIDIuMTogQ29tcHV0aW5nIHRoZSBjb2xsaXNpb24gY29uc3RyYWludFxcbi8vLy8gSWYgdHdvIHBhcnRpY2xlcyBhLGIgYXJlIGNsb3NlciB0aGFuIGNvbGxpc2lvbl9kaXN0LFxcbi8vLy8gYSBzcHJpbmcgY29uc3RyYWludCBpcyBhcHBsaWVkIHRvIHNlcGFyYXRlIHRoZW0uXFxuLy8vLyBUaGUgcmVzdCBsZW5ndGggb2YgdGhlIHNwcmluZyBpcyBzZXQgdG8gY29sbGlzaW9uX2Rpc3QuXFxuLy8vLyBPdGhlcndpc2UgcmV0dXJuIDAuMC5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbmZsb2F0IGNvbGxpc2lvbl9jb25zdHJhaW50KHZlYzIgYSwgdmVjMiBiLCBmbG9hdCBjb2xsaXNpb25fZGlzdCl7XFxuICAgIC8vIENvbXB1dGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBhcnRpY2xlcyBhIGFuZCBiLlxcbiAgICAvLyBUaGUgY29uc3RyYWludCBpcyBkZWZpbmVkIGFzIEwgLSBMMCwgd2hlcmUgTCBpcyB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcXG4gICAgLy8gYW5kIEwwID0gY29sbGlzaW9uX2Rpc3QgaXMgdGhlIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiLlxcblxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGEgLSBiKTtcXG4gICAgaWYoZGlzdCA8IGNvbGxpc2lvbl9kaXN0KXtcXG4gICAgICAgIC8vLy8gWW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG4gICAgICAgIHJldHVybiBkaXN0IC0gY29sbGlzaW9uX2Rpc3Q7XFxuICAgICAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbiAgICB9XFxuICAgIGVsc2V7XFxuICAgICAgICByZXR1cm4gMC4wO1xcbiAgICB9XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBTdGVwIDIuMjogQ29tcHV0aW5nIHRoZSBjb2xsaXNpb24gY29uc3RyYWludCBncmFkaWVudFxcbi8vLy8gSWYgdHdvIHBhcnRpY2xlcyBhLGIgYXJlIGNsb3NlciB0aGFuIGNvbGxpc2lvbl9kaXN0LFxcbi8vLy8gY2FsY3VsYXRlIHRoZSBncmFkaWVudCBvZiB0aGUgY29sbGlzaW9uIGNvbnN0cmFpbnQgd2l0aCByZXNwZWN0IHRvIGEuXFxuLy8vLyBJdCdzIHNpbWlsYXIgdG8gdGhlIHNwcmluZyBjb25zdHJhaW50IGdyYWRpZW50Llxcbi8vLy8gT3RoZXJ3aXNlIHJldHVybiB2ZWMyKDAuMCwgMC4wKS5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbnZlYzIgY29sbGlzaW9uX2NvbnN0cmFpbnRfZ3JhZGllbnQodmVjMiBhLCB2ZWMyIGIsIGZsb2F0IGNvbGxpc2lvbl9kaXN0KXtcXG4gICAgLy8gQ29tcHV0ZSB0aGUgZ3JhZGllbnQgb2YgdGhlIGNvbGxpc2lvbiBjb25zdHJhaW50IHdpdGggcmVzcGVjdCB0byBhLlxcblxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGEgLSBiKTtcXG4gICAgaWYoZGlzdCA8PSBjb2xsaXNpb25fZGlzdCl7XFxuICAgICAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gc3RhcnRzXFxuICAgICAgICAvLyByZXR1cm4gKGRpc3QgPT0gMC4wKSA/IHZlYzIoMC4wKSA6IChhIC0gYikgLyBkaXN0O1xcbiAgICAgICAgcmV0dXJuIChhIC0gYikgLyBkaXN0O1xcbiAgICAgICAgLy8vLyBZb3VyIGltcGxlbWVudGF0aW9uIGVuZHNcXG4gICAgfVxcbiAgICBlbHNle1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xcbiAgICB9XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBTdGVwIDIuMzogU29sdmluZyBhIHNpbmdsZSBjb2xsaXNpb24gY29uc3RyYWludFxcbi8vLy8gSXQgc29sdmVzIGZvciB0aGUgY29sbGlzaW9uIGNvbnN0cmFpbnQgYmV0d2VlbiBwYXJ0aWNsZSBpIGFuZCBqLlxcbi8vLy8gQ2FsY3VsYXRlIHRoZSBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yIGZvciB0aGUgTGFncmFuZ2lhbiBtdWx0aXBsaWVyIHVwZGF0ZS5cXG4vLy8vIFlvdSB3aWxsIGNhbGN1bGF0ZSB0aGUgbnVtZXIvZGVub20gZm9yIFBCRCB1cGRhdGVzLlxcbi8vLy8gVGhlIExhZ3JhbmdpYW4gbXVsdGlwbGllciB1cGRhdGUgaXMgY2FsY3VsYXRlZCB3aXRoIGxhbWJkYT0obnVtZXIvZGVub20pXFxuLy8vLyBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscy5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbnZvaWQgc29sdmVfY29sbGlzaW9uX2NvbnN0cmFpbnQoaW50IGksIGludCBqLCBmbG9hdCBjb2xsaXNpb25fZGlzdCwgZmxvYXQgZHQpe1xcbiAgICAvLyBDb21wdXRlIHRoZSBjb2xsaXNpb24gY29uc3RyYWludCBmb3IgcGFydGljbGVzIGkgYW5kIGouXFxuICAgIGZsb2F0IG51bWVyID0gMC4wO1xcbiAgICBmbG9hdCBkZW5vbSA9IDAuMDtcXG5cXG4gICAgLy8vLyBZb3VyIGltcGxlbWVudGF0aW9uIHN0YXJ0c1xcbiAgICB2ZWMyIGEgPSBwYXJ0aWNsZXNbaV0ucG9zO1xcbiAgICB2ZWMyIGIgPSBwYXJ0aWNsZXNbal0ucG9zO1xcbiAgICB2ZWMyIGdyYWQgPSBjb2xsaXNpb25fY29uc3RyYWludF9ncmFkaWVudChhLCBiLCBjb2xsaXNpb25fZGlzdCk7XFxuXFxuICAgIGlmIChncmFkID09IHZlYzIoMC4wKSkgcmV0dXJuOyAvLyBubyBjb2xsaXNpb25cXG5cXG4gICAgbnVtZXIgPSAtY29sbGlzaW9uX2NvbnN0cmFpbnQoYSwgYiwgY29sbGlzaW9uX2Rpc3QpO1xcbiAgICBmbG9hdCBpbmVydGlhbF9hID0gcGFydGljbGVzW2ldLmludl9tYXNzICogZG90KGdyYWQsIGdyYWQpO1xcbiAgICBmbG9hdCBpbmVydGlhbF9iID0gcGFydGljbGVzW2pdLmludl9tYXNzICogZG90KGdyYWQsIGdyYWQpO1xcbiAgICBkZW5vbSA9IGluZXJ0aWFsX2EgKyBpbmVydGlhbF9iO1xcbiAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcblxcbiAgICAvL1BCRCBpZiB5b3UgY29tbWVudCBvdXQgdGhlIGZvbGxvd2luZyBsaW5lLCB3aGljaCBpcyBmYXN0ZXJcXG4gICAgZGVub20gKz0gKDEuIC8gMTAwMC4pIC8gKGR0ICogZHQpO1xcblxcbiAgICBpZiAoZGVub20gPT0gMC4wKSByZXR1cm47XFxuICAgIGZsb2F0IGxhbWJkYSA9IG51bWVyIC8gZGVub207XFxuICAgIHBhcnRpY2xlc1tpXS5wb3MgKz0gbGFtYmRhICogcGFydGljbGVzW2ldLmludl9tYXNzICogZ3JhZDtcXG4gICAgcGFydGljbGVzW2pdLnBvcyAtPSBsYW1iZGEgKiBwYXJ0aWNsZXNbal0uaW52X21hc3MgKiBncmFkO1xcbn1cXG5cXG5mbG9hdCBwaGkodmVjMiBwKXtcXG4gICAgY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU5O1xcbiAgICAvL2xldCdzIGRvIHNpbih4KSswLjVcXG4gICAgcmV0dXJuIHAueSAtICgwLjEgKiBzaW4ocC54ICogMi4gKiBQSSkgLSAwLjUpO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gU3RlcCAzLjE6IENvbXB1dGluZyB0aGUgZ3JvdW5kIGNvbnN0cmFpbnRcXG4vLy8vIEZvciBhIHBvaW50IHAsIGlmIHBoaShwKSA8IGdyb3VuZF9jb2xsaXNpb25fZGlzdCxcXG4vLy8vIHdlIHNldCBhIGNvbnN0cmFpbnQgdG8gcHVzaCB0aGUgcG9pbnQgYXdheSBmcm9tIHRoZSBncm91bmQuXFxuLy8vLyBUaGUgY29uc3RyYWludCBpcyBkZWZpbmVkIGFzIHBoaShwKSAtIGdyb3VuZF9jb2xsaXNpb25fZGlzdC5cXG4vLy8vIE90aGVyd2lzZSByZXR1cm4gMC4wLlxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuZmxvYXQgZ3JvdW5kX2NvbnN0cmFpbnQodmVjMiBwLCBmbG9hdCBncm91bmRfY29sbGlzaW9uX2Rpc3Qpe1xcbiAgICBpZihwaGkocCkgPCBncm91bmRfY29sbGlzaW9uX2Rpc3Qpe1xcbiAgICAgICAgLy8vLyBZb3VyIGltcGxlbWVudGF0aW9uIHN0YXJ0c1xcbiAgICAgICAgcmV0dXJuIHBoaShwKSAtIGdyb3VuZF9jb2xsaXNpb25fZGlzdDtcXG4gICAgICAgIC8vLy8gWW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxuICAgIH1cXG4gICAgZWxzZXtcXG4gICAgICAgIHJldHVybiAwLjA7XFxuICAgIH0gICAgXFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBTdGVwIDMuMjogQ29tcHV0aW5nIHRoZSBncm91bmQgY29uc3RyYWludCBncmFkaWVudFxcbi8vLy8gSWYgcGhpKHApIDwgZ3JvdW5kX2NvbGxpc2lvbl9kaXN0LCBcXG4vLy8vIGNvbXB1dGUgdGhlIGdyYWRpZW50IG9mIHRoZSBncm91bmQgY29uc3RyYWludC5cXG4vLy8vIE90aGVyd2lzZSByZXR1cm4gdmVjMigwLjAsIDAuMCkuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG52ZWMyIGdyb3VuZF9jb25zdHJhaW50X2dyYWRpZW50KHZlYzIgcCwgZmxvYXQgZ3JvdW5kX2NvbGxpc2lvbl9kaXN0KXtcXG4gICAgLy8gQ29tcHV0ZSB0aGUgZ3JhZGllbnQgb2YgdGhlIGdyb3VuZCBjb25zdHJhaW50IHdpdGggcmVzcGVjdCB0byBwLlxcblxcbiAgICBpZihwaGkocCkgPCBncm91bmRfY29sbGlzaW9uX2Rpc3Qpe1xcbiAgICAgICAgLy8vLyBZb3VyIGltcGxlbWVudGF0aW9uIHN0YXJ0c1xcbiAgICAgICAgZmxvYXQgZ3JhZF94ID0gLTAuMiAqIFBJICogY29zKDIuMCAqIFBJICogcC54KTtcXG4gICAgICAgIGZsb2F0IGdyYWRfeSA9IDEuMDtcXG4gICAgICAgIHJldHVybiB2ZWMyKGdyYWRfeCwgZ3JhZF95KTsgXFxuICAgICAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbiAgICB9XFxuICAgIGVsc2V7XFxuICAgICAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XFxuICAgIH1cXG59XFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLy8vIFN0ZXAgMy4zOiBTb2x2aW5nIGEgc2luZ2xlIGdyb3VuZCBjb25zdHJhaW50XFxuLy8vLyBJdCBzb2x2ZXMgZm9yIHRoZSBncm91bmQgY29uc3RyYWludCBmb3IgcGFydGljbGUgaS5cXG4vLy8vIENhbGN1bGF0ZSB0aGUgbnVtZXJhdG9yIGFuZCBkZW5vbWluYXRvciBmb3IgdGhlIExhZ3JhbmdpYW4gbXVsdGlwbGllciB1cGRhdGUuXFxuLy8vLyBZb3Ugd2lsbCBjYWxjdWxhdGUgdGhlIG51bWVyL2Rlbm9tIGZvciBQQkQgdXBkYXRlcy5cXG4vLy8vIFRoZSBMYWdyYW5naWFuIG11bHRpcGxpZXIgdXBkYXRlIGlzIGNhbGN1bGF0ZWQgd2l0aCBsYW1iZGE9KG51bWVyL2Rlbm9tKVxcbi8vLy8gU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG52b2lkIHNvbHZlX2dyb3VuZF9jb25zdHJhaW50KGludCBpLCBmbG9hdCBncm91bmRfY29sbGlzaW9uX2Rpc3QsIGZsb2F0IGR0KXtcXG4gICAgLy8gQ29tcHV0ZSB0aGUgZ3JvdW5kIGNvbnN0cmFpbnQgZm9yIHBhcnRpY2xlIGkuXFxuICAgIGZsb2F0IG51bWVyID0gMC4wO1xcbiAgICBmbG9hdCBkZW5vbSA9IDAuMDtcXG5cXG4gICAgLy8vLyBZb3VyIGltcGxlbWVudGF0aW9uIHN0YXJ0c1xcbiAgICB2ZWMyIHBfaSA9IHBhcnRpY2xlc1tpXS5wb3M7XFxuICAgIHZlYzIgZ3JhZCA9IGdyb3VuZF9jb25zdHJhaW50X2dyYWRpZW50KHBfaSwgZ3JvdW5kX2NvbGxpc2lvbl9kaXN0KTtcXG4gICAgXFxuICAgIG51bWVyID0gLWdyb3VuZF9jb25zdHJhaW50KHBfaSwgZ3JvdW5kX2NvbGxpc2lvbl9kaXN0KTtcXG4gICAgZGVub20gPSBwYXJ0aWNsZXNbaV0uaW52X21hc3MgKiBkb3QoZ3JhZCwgZ3JhZCk7XFxuXFxuICAgIC8vLy8gWW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxuXFxuICAgIC8vUEJEIGlmIHlvdSBjb21tZW50IG91dCB0aGUgZm9sbG93aW5nIGxpbmUsIHdoaWNoIGlzIGZhc3RlclxcbiAgICBkZW5vbSArPSAoMS4gLyAxMDAwLikgLyAoZHQgKiBkdCk7XFxuXFxuICAgIGlmIChkZW5vbSA9PSAwLjApIHJldHVybjtcXG4gICAgZmxvYXQgbGFtYmRhID0gbnVtZXIgLyBkZW5vbTtcXG4gICAgcGFydGljbGVzW2ldLnBvcyArPSBsYW1iZGEgKiBwYXJ0aWNsZXNbaV0uaW52X21hc3MgKiBncmFkO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gU3RlcCAxMDogU29sdmluZyBhbGwgY29uc3RyYWludHNcXG4vLy8vIFlvdSBuZWVkIHRvIHNvbHZlIGZvciBhbGwgMyB0eXBlcyBvZiBjb25zdHJhaW50cyB1c2luZyBwcmV2aW91c2x5IGRlZmluZWQgZnVuY3Rpb25zOlxcbi8vLy8gMS4gU3ByaW5nIGNvbnN0cmFpbnRzIGRlZmluZWQgYnkgc3ByaW5nc1sxXSB0byBzcHJpbmdzW25fc3ByaW5ncy0xXVxcbi8vLy8gMi4gR3JvdW5kIGNvbnN0cmFpbnRzIGZvciBhbGwgcGFydGljbGVzIChleGNlcHQgdGhlIG1vdXNlIHBhcnRpY2xlIDApLlxcbi8vLy8gMy4gQ29sbGlzaW9uIGNvbnN0cmFpbnRzIGZvciBhbGwgcGFpcnMgb2YgcGFydGljbGVzIChleGNlcHQgdGhlIG1vdXNlIHBhcnRpY2xlIDApLlxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxudm9pZCBzb2x2ZV9jb25zdHJhaW50cyhmbG9hdCBkdCkge1xcbiAgICAvL0lmIGxlZnQgbW91c2UgaXMgcHJlc3NlZCwgY2FsY3VsYXRlIHRoZSBzcHJpbmcgY29uc3RyYWludCBmb3IgdGhlIG1vdXNlIHBhcnRpY2xlIHRvIHRoZSBmaXJzdCByb3BlIHBhcnRpY2xlLlxcbiAgICBpZihpTW91c2UueiA9PSAxLil7XFxuICAgICAgICBzb2x2ZV9zcHJpbmcoc3ByaW5nc1swXSwgZHQpOyAvLyBtb3VzZSBwYXJ0aWNsZSB0byBmaXJzdCByb3BlIHBhcnRpY2xlXFxuICAgIH1cXG5cXG4gICAgLy8gU29sdmUgYWxsIGNvbnN0cmFpbnRzXFxuXFxuICAgIC8vLy8gWW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG5cXG4gICAgLy8gU3ByaW5nIENvbnN0cmFpbnRzXFxuICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbl9zcHJpbmdzOyBpKyspIHtcXG4gICAgICAgIHNvbHZlX3NwcmluZyhzcHJpbmdzW2ldLCBkdCk7XFxuICAgIH1cXG4gICAgLy8gQ29sbGlzaW9uIENvbnN0cmFpbnRzIGJldHdlZW4gZXZlcnkgcGFpciBvZiBwYXJ0aWNsZXNcXG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuX3BhcnRpY2xlczsgaSsrKSB7XFxuICAgICAgICBmb3IgKGludCBqID0gaSArIDE7IGogPCBuX3BhcnRpY2xlczsgaisrKSB7XFxuICAgICAgICAgICAgc29sdmVfY29sbGlzaW9uX2NvbnN0cmFpbnQoaSwgaiwgY29sbGlzaW9uX2Rpc3QsIGR0KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvLyBHcm91bmQgQ29uc3RyYWludHNcXG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuX3BhcnRpY2xlczsgaSsrKSB7XFxuICAgICAgICBzb2x2ZV9ncm91bmRfY29uc3RyYWludChpLCBncm91bmRfY29sbGlzaW9uX2Rpc3QsIGR0KTtcXG4gICAgfVxcblxcbiAgICAvLy8vIFlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbn1cXG5cXG5mbG9hdCBkaXN0X3RvX3NlZ21lbnQodmVjMiBwLCB2ZWMyIGEsIHZlYzIgYikge1xcbiAgICB2ZWMyIHBhID0gcCAtIGE7XFxuICAgIHZlYzIgYmEgPSBiIC0gYTtcXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJvamVjdGlvbiBmYWN0b3IgYW5kIGNsYW1wIGl0IGJldHdlZW4gMCBhbmQgMS5cXG4gICAgZmxvYXQgaCA9IGNsYW1wKGRvdChwYSwgYmEpIC8gZG90KGJhLCBiYSksIDAuMCwgMS4wKTtcXG4gICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSBmcm9tIHAgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnQuXFxuICAgIHJldHVybiBsZW5ndGgocGEgLSBoICogYmEpO1xcbn1cXG5cXG4vLyBxdWFkcmF0aWMgcG9seW5vbWlhbCBzbW9vdGhlZCBtaW5pbXVtOiBodHRwczovL2lxdWlsZXpsZXMub3JnL2FydGljbGVzL3NtaW4vXFxuZmxvYXQgc21pbiggZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgayApXFxue1xcbiAgICBrICo9IDQuMDtcXG4gICAgZmxvYXQgaCA9IG1heCggay1hYnMoYS1iKSwgMC4wICkvaztcXG4gICAgcmV0dXJuIG1pbihhLGIpIC0gaCpoKmsqKDEuMC80LjApO1xcbn1cXG5cXG52ZWMzIHJlbmRlcl9zY2VuZSh2ZWMyIHBpeGVsX3h5KSB7XFxuICAgIGZsb2F0IHBoaSA9IHBoaShwaXhlbF94eSk7XFxuICAgIHZlYzMgY29sO1xcbiAgICBpZihwaGkgPCAwLjApIHtcXG4gICAgICAgIGZsb2F0IHQgPSByZW1hcDAxKHBoaSwgMC4wLCAtMS4wKTtcXG4gICAgICAgIHZlYzMgY29sb3IxID0gdmVjMygwLjgyKTsgLy8gbGlnaHQgYmx1ZVxcbiAgICAgICAgdmVjMyBjb2xvcjIgPSB2ZWMzKDAuMzQsIDAuMzUsIDAuMzUpOyAvLyBkYXJrIGJsdWVcXG4gICAgICAgIHZlYzMgY29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIHQpO1xcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xcbiAgICB9XFxuICAgIGVsc2V7XFxuICAgICAgICAvLyBjb2wgPSB2ZWMzKDIyOSwgMjQyLCAyNTApIC8gMjU1LjsgLy8gYmFja2dyb3VuZCBjb2xvclxcbiAgICAgICAgLy8gUmVuZGVyIGEgZ3JhZGllbnQgYmFja2dyb3VuZFxcbiAgICAgICAgZmxvYXQgdCA9IHJlbWFwMDEocGl4ZWxfeHkueSwgMC4wLCAxLjApO1xcbiAgICAgICAgdmVjMyBjb2xvcjEgPSB2ZWMzKDAuOSwgMC42OSwgMC40Nik7IC8vIGxpZ2h0IGJsdWVcXG4gICAgICAgIHZlYzMgY29sb3IyID0gdmVjMygwLjk3LCAwLjczLCAxLjApOyAvLyBkYXJrIGJsdWVcXG4gICAgICAgIGNvbCA9IG1peChjb2xvcjEsIGNvbG9yMiwgdCk7XFxuICAgIH1cXG4gICAgXFxuICAgIGZsb2F0IHBpeGVsX3NpemUgPSAyLjAgLyBpUmVzb2x1dGlvbi55O1xcbiAgICBcXG4gICAgLy8gSWYgc3RpbGwgaW5pdGlhbGl6aW5nLCByZXR1cm4gdGhlIGJhY2tncm91bmQgY29sb3IuXFxuICAgIGlmIChpc19pbml0aWFsaXppbmcoKSkge1xcbiAgICAgICAgcmV0dXJuIGNvbDtcXG4gICAgfVxcblxcbiAgICAvLyBSZW5kZXIgZmx1aWQgcGFydGljbGVzXFxuICAgIHtcXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlID0gbGVuZ3RoKHBpeGVsX3h5IC0gcGFydGljbGVzWzFdLnBvcyk7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gaW5pdGlhbF9wYXJ0aWNsZXM7IGkgPCBuX3BhcnRpY2xlczsgaSsrKSB7XFxuICAgICAgICAgICAgZGlzdGFuY2UgPSBzbWluKGRpc3RhbmNlLCBsZW5ndGgocGl4ZWxfeHkgLSBwYXJ0aWNsZXNbaV0ucG9zKSwgUkFESVVTKTtcXG4gICAgICAgICAgICAvLyBpZiAoZGlzdGFuY2UgPCBSQURJVVMpIHtcXG4gICAgICAgICAgICAvLyAgICAgZmxvYXQgdCA9IHJlbWFwMDEoZGlzdGFuY2UsIFJBRElVUyAqIDAuNywgUkFESVVTICogMi4pO1xcbiAgICAgICAgICAgIC8vICAgICB2ZWMzIGNvbG9yMSA9IHZlYzMoMC4xNywgMC43MSwgMS4wKTsgLy8gbGlnaHQgYmx1ZVxcbiAgICAgICAgICAgIC8vICAgICB2ZWMzIGNvbG9yMiA9IHZlYzMoMS4wKTsgLy8gZGFyayBibHVlXFxuICAgICAgICAgICAgLy8gICAgIHZlYzMgY29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIHQpO1xcbiAgICAgICAgICAgIC8vICAgICAvLyB2ZWMzIGNvbG9yID0gdmVjMygwLjQ5LCAwLjY5LCAwLjkyKTtcXG4gICAgICAgICAgICAvLyAgICAgY29sID0gY29sb3I7XFxuICAgICAgICAgICAgLy8gICAgIC8vIGJyZWFrO1xcbiAgICAgICAgICAgIC8vIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChkaXN0YW5jZSA8IFJBRElVUykge1xcbiAgICAgICAgICAgIGZsb2F0IHQgPSByZW1hcDAxKGRpc3RhbmNlLCBSQURJVVMgKiAwLjgsIFJBRElVUyAqIDEuMSk7XFxuICAgICAgICAgICAgdmVjMyBjb2xvcjEgPSB2ZWMzKDAuNDUsIDAuODEsIDEuMCk7IC8vIGxpZ2h0IGJsdWVcXG4gICAgICAgICAgICB2ZWMzIGNvbG9yMiA9IHZlYzMoMS4wKTsgLy8gZGFyayBibHVlXFxuICAgICAgICAgICAgdmVjMyBjb2xvciA9IG1peChjb2xvcjEsIGNvbG9yMiwgdCk7XFxuICAgICAgICAgICAgLy8gdmVjMyBjb2xvciA9IHZlYzMoMC40OSwgMC42OSwgMC45Mik7XFxuICAgICAgICAgICAgY29sID0gY29sb3I7XFxuICAgICAgICAgICAgLy8gYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgXFxuICAgIC8vIFJlbmRlciBBbGwgc3ByaW5nc1xcbiAgICB7XFxuICAgICAgICBmbG9hdCBtaW5fZGlzdCA9IDFlOTtcXG5cXG4gICAgICAgIGlmKGlNb3VzZS56ID09IDEuKXtcXG4gICAgICAgICAgICBtaW5fZGlzdCA9IGRpc3RfdG9fc2VnbWVudChwaXhlbF94eSwgcGFydGljbGVzWzBdLnBvcywgcGFydGljbGVzW3NlbGVjdGVkX3BhcnRpY2xlXS5wb3MpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuX3NwcmluZ3M7IGkrKykge1xcbiAgICAgICAgICAgIGludCBhID0gc3ByaW5nc1tpXS5hO1xcbiAgICAgICAgICAgIGludCBiID0gc3ByaW5nc1tpXS5iO1xcbiAgICAgICAgICAgIG1pbl9kaXN0ID0gbWluKG1pbl9kaXN0LCBkaXN0X3RvX3NlZ21lbnQocGl4ZWxfeHksIHBhcnRpY2xlc1thXS5wb3MsIHBhcnRpY2xlc1tiXS5wb3MpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IHRoaWNrbmVzcyA9IFJBRElVUztcXG4gICAgICAgIGlmIChtaW5fZGlzdCA8IHRoaWNrbmVzcykge1xcbiAgICAgICAgICAgIGZsb2F0IHQgPSByZW1hcDAxKG1pbl9kaXN0LCAwLjAsIHRoaWNrbmVzcyAqIDIuKTtcXG4gICAgICAgICAgICB2ZWMzIGNvbG9yMSA9IHZlYzMoMC44NSk7XFxuICAgICAgICAgICAgdmVjMyBjb2xvcjIgPSB2ZWMzKDAuNTgpO1xcbiAgICAgICAgICAgIHZlYzMgY29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIHQpO1xcbiAgICAgICAgICAgIGNvbCA9IGNvbG9yO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIGNvbC56ID0gMS4wO1xcbiAgICByZXR1cm4gY29sO1xcbn1cXG5cXG52ZWM0IG91dHB1dF9jb2xvcih2ZWMyIHBpeGVsX2lqKXtcXG4gICAgaW50IGkgPSBpbnQocGl4ZWxfaWoueCk7XFxuICAgIGludCBqID0gaW50KHBpeGVsX2lqLnkpO1xcbiAgICBcXG4gICAgaWYoaiA9PSAwKXtcXG4gICAgICAgIC8vICgwLDApOiAobnVtX3BhcnRpY2xlcywgbnVtX3NwcmluZ3MsIHNlbGVjdGVkX3BhcnRpY2xlKVxcbiAgICAgICAgaWYoaT09MCl7XFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQoZmxvYXQobl9wYXJ0aWNsZXMpLCBmbG9hdChuX3NwcmluZ3MpLCBmbG9hdChzZWxlY3RlZF9wYXJ0aWNsZSksIGZsb2F0KGN1cnJlbnRfYWRkX3BhcnRpY2xlKSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmKGkgPCBuX3BhcnRpY2xlcyl7XFxuICAgICAgICAgICAgLy9hIHBhcnRpY2xlXFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQocGFydGljbGVzW2ldLnBvcywgcGFydGljbGVzW2ldLnZlbCk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNle1xcbiAgICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZWxzZSBpZihqID09IDEpe1xcbiAgICAgICAgaWYoaSA8IG5fc3ByaW5ncyl7XFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQoZmxvYXQoc3ByaW5nc1tpXS5hKSwgZmxvYXQoc3ByaW5nc1tpXS5iKSwgc3ByaW5nc1tpXS5yZXN0TGVuZ3RoLCBzcHJpbmdzW2ldLmludl9zdGlmZm5lc3MpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZXtcXG4gICAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGVsc2V7XFxuICAgICAgICB2ZWMyIHBpeGVsX3h5ID0gc2NyZWVuX3RvX3h5KHBpeGVsX2lqKTtcXG4gICAgICAgIHZlYzMgY29sb3IgPSByZW5kZXJfc2NlbmUocGl4ZWxfeHkpO1xcbiAgICAgICAgcmV0dXJuIHZlYzQoY29sb3IsIDEuMCk7XFxuICAgIH1cXG59XFxuXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gTWFpbiBmdW5jdGlvblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBwaXhlbF9paiA9IHZVdiAqIGlSZXNvbHV0aW9uLnh5O1xcbiAgICBpbnQgcGl4ZWxfaSA9IGludChwaXhlbF9pai54KTtcXG4gICAgaW50IHBpeGVsX2ogPSBpbnQocGl4ZWxfaWoueSk7XFxuXFxuICAgIGlmKGlzX2luaXRpYWxpemluZygpKXtcXG4gICAgICAgIGluaXRfc3RhdGUoKTtcXG4gICAgfVxcbiAgICBlbHNle1xcbiAgICAgICAgbG9hZF9zdGF0ZSgpO1xcbiAgICAgICAgaWYgKHBpeGVsX2ogPT0gMCkge1xcbiAgICAgICAgICAgIGlmIChwaXhlbF9pID49IG5fcGFydGljbGVzKSByZXR1cm47XFxuXFxuICAgICAgICAgICAgZmxvYXQgYWN0dWFsX2R0ID0gbWluKGlUaW1lRGVsdGEsIDAuMDIpO1xcbiAgICAgICAgICAgIGNvbnN0IGludCBuX3N0ZXBzID0gNTtcXG4gICAgICAgICAgICBmbG9hdCBkdCA9IGFjdHVhbF9kdCAvIGZsb2F0KG5fc3RlcHMpO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbl9zdGVwczsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByb3BlIHBhcnRpY2xlcyBvbmx5OyBza2lwIHVwZGF0aW5nIHRoZSBtb3VzZSBwYXJ0aWNsZSBzaW5jZSBpdCdzIGZpeGVkLlxcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG5fcGFydGljbGVzOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydGljbGVzW2pdLmlzX2ZpeGVkKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlc1tqXS52ZWwgKz0gZHQgKiBncmF2aXR5O1xcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGVzW2pdLnZlbCAqPSBleHAoLWRhbXAgKiBkdCk7XFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZXNbal0ucG9zX3ByZXYgPSBwYXJ0aWNsZXNbal0ucG9zO1xcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGVzW2pdLnBvcyArPSBkdCAqIHBhcnRpY2xlc1tqXS52ZWw7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgc29sdmVfY29uc3RyYWludHMoZHQpO1xcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdmVsb2NpdGllcyBmb3Igcm9wZSBwYXJ0aWNsZXMgb25seS5cXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBuX3BhcnRpY2xlczsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnRpY2xlc1tqXS5pc19maXhlZCl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGVzW2pdLnZlbCA9IChwYXJ0aWNsZXNbal0ucG9zIC0gcGFydGljbGVzW2pdLnBvc19wcmV2KSAvIGR0O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIG1vdXNlIHBhcnRpY2xlIGZpeGVkIGJ5IHJlYXNzaWduaW5nIGl0cyBwb3NpdGlvbiBlYWNoIHN0ZXAuXFxuICAgICAgICAgICAgICAgIGludCBtb3VzZV9pZHggPSAwO1xcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXNbbW91c2VfaWR4XS5wb3MgPSBzY3JlZW5fdG9feHkoaU1vdXNlLnh5KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gb3V0cHV0X2NvbG9yKHBpeGVsX2lqKTtcXG59XFxuXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_ce.glsl\n"));

/***/ })

});