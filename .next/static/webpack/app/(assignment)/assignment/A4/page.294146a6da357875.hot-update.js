"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(assignment)/assignment/A4/page",{

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A4/page.tsx":
/*!*****************************************************!*\
  !*** ./src/app/(assignment)/assignment/A4/page.tsx ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ XPBDRopePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _shaders_common_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/shaders/common/vertex.glsl */ \"(app-pages-browser)/./src/shaders/common/vertex.glsl\");\n/* harmony import */ var _fragment_final_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragment_final.glsl */ \"(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_final.glsl\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n // Simple vertex shader\n // Fragment shader\nconst XPBDRope = (param)=>{\n    let { dpr } = param;\n    _s();\n    const { viewport, gl, scene, camera } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)();\n    const uniforms = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        iTime: {\n            value: 0\n        },\n        iTimeDelta: {\n            value: 0\n        },\n        iFrame: {\n            value: 0\n        },\n        iResolution: {\n            value: new three__WEBPACK_IMPORTED_MODULE_5__.Vector2(window.innerWidth * dpr, window.innerHeight * dpr)\n        },\n        iMouse: {\n            value: new three__WEBPACK_IMPORTED_MODULE_5__.Vector4(0, 0, 0, 0)\n        },\n        iChannel0: {\n            value: new three__WEBPACK_IMPORTED_MODULE_5__.Texture()\n        }\n    }).current;\n    // Create double-buffered RenderTarget\n    const renderTargets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([\n        new three__WEBPACK_IMPORTED_MODULE_5__.WebGLRenderTarget(window.innerWidth * dpr, window.innerHeight * dpr, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            format: three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat,\n            type: three__WEBPACK_IMPORTED_MODULE_5__.FloatType\n        }),\n        new three__WEBPACK_IMPORTED_MODULE_5__.WebGLRenderTarget(window.innerWidth * dpr, window.innerHeight * dpr, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_5__.NearestFilter,\n            format: three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat,\n            type: three__WEBPACK_IMPORTED_MODULE_5__.FloatType\n        })\n    ]).current;\n    const bufferIndex = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    let lastTime = performance.now(); // Record the time of the previous frame\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(()=>{\n        const now = performance.now();\n        uniforms.iTimeDelta.value = (now - lastTime) / 1000; // Compute delta time in seconds\n        lastTime = now;\n        uniforms.iTime.value += uniforms.iTimeDelta.value;\n        uniforms.iFrame.value++; // Increment frame counter\n        uniforms.iResolution.value.set(window.innerWidth * dpr, window.innerHeight * dpr);\n        //console.log('Frame:', uniforms.iFrame.value);\n        //console.log('Time:', uniforms.iTime.value);\n        // Set the current frame input texture (using the other RenderTarget)\n        uniforms.iChannel0.value = renderTargets[1 - bufferIndex.current].texture;\n        gl.setRenderTarget(renderTargets[bufferIndex.current]);\n        gl.render(scene, camera);\n        gl.setRenderTarget(null); // Switch back to the default framebuffer\n        // Swap buffers\n        bufferIndex.current = 1 - bufferIndex.current;\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleMouseMove = (event)=>{\n            uniforms.iMouse.value.x = event.clientX * dpr;\n            uniforms.iMouse.value.y = (window.innerHeight - event.clientY) * dpr; // Flip Y-axis\n        };\n        const handleMouseDown = (event)=>{\n            if (event.button === 0) {\n                uniforms.iMouse.value.z = 1; // 左键按下\n            }\n        };\n        const handleMouseUp = (event)=>{\n            if (event.button === 0) {\n                uniforms.iMouse.value.z = 0; // 左键释放\n            } else if (event.button === 2) {\n                uniforms.iMouse.value.z = 2; // 右键释放的瞬间\n                requestAnimationFrame(()=>{\n                    uniforms.iMouse.value.z = 0; // 下一帧恢复为 0\n                });\n            }\n        };\n        window.addEventListener(\"mousemove\", handleMouseMove);\n        window.addEventListener(\"mousedown\", handleMouseDown);\n        window.addEventListener(\"mouseup\", handleMouseUp);\n        window.addEventListener(\"contextmenu\", (e)=>e.preventDefault()); // 阻止右键菜单\n        return ()=>{\n            window.removeEventListener(\"mousemove\", handleMouseMove);\n            window.removeEventListener(\"mousedown\", handleMouseDown);\n            window.removeEventListener(\"mouseup\", handleMouseUp);\n        };\n    }, [\n        dpr\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n        scale: [\n            viewport.width,\n            viewport.height,\n            1\n        ],\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                args: [\n                    1,\n                    1\n                ]\n            }, void 0, false, {\n                fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n                lineNumber: 103,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"shaderMaterial\", {\n                fragmentShader: _fragment_final_glsl__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n                vertexShader: _shaders_common_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n                uniforms: uniforms\n            }, void 0, false, {\n                fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n                lineNumber: 104,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n        lineNumber: 102,\n        columnNumber: 5\n    }, undefined);\n};\n_s(XPBDRope, \"e8OySB1Ty5yM23xsuElxkkKaiAI=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F\n    ];\n});\n_c = XPBDRope;\nfunction XPBDRopePage() {\n    const dpr = 1;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_6__.Canvas, {\n        dpr: dpr,\n        orthographic: true,\n        camera: {\n            position: [\n                0,\n                0,\n                6\n            ]\n        },\n        style: {\n            position: \"fixed\",\n            top: 0,\n            left: 0,\n            width: \"100vw\",\n            height: \"100vh\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n            fallback: null,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(XPBDRope, {\n                dpr: dpr\n            }, void 0, false, {\n                fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n                lineNumber: 129,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n            lineNumber: 128,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/bir/code/cgai_final/CGA-Final/src/app/(assignment)/assignment/A4/page.tsx\",\n        lineNumber: 116,\n        columnNumber: 5\n    }, this);\n}\n_c1 = XPBDRopePage;\nvar _c, _c1;\n$RefreshReg$(_c, \"XPBDRope\");\n$RefreshReg$(_c1, \"XPBDRopePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFFb0Q7QUFDWTtBQUNqQztBQUV5QixDQUFDLHVCQUF1QjtBQUM3QixDQUFDLGtCQUFrQjtBQUV0RSxNQUFNUyxXQUFXO1FBQUMsRUFBRUMsR0FBRyxFQUFtQjs7SUFDeEMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLEVBQUUsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR1QscURBQVFBO0lBRWhELE1BQU1VLFdBQVdkLDZDQUFNQSxDQUFDO1FBQ3RCZSxPQUFPO1lBQUVDLE9BQU87UUFBRTtRQUNsQkMsWUFBWTtZQUFFRCxPQUFPO1FBQUU7UUFDdkJFLFFBQVE7WUFBRUYsT0FBTztRQUFFO1FBQ25CRyxhQUFhO1lBQ1hILE9BQU8sSUFBSVgsMENBQWEsQ0FBQ2dCLE9BQU9DLFVBQVUsR0FBR2IsS0FBS1ksT0FBT0UsV0FBVyxHQUFHZDtRQUN6RTtRQUNBZSxRQUFRO1lBQUVSLE9BQU8sSUFBSVgsMENBQWEsQ0FBQyxHQUFHLEdBQUcsR0FBRztRQUFHO1FBQy9DcUIsV0FBVztZQUFFVixPQUFPLElBQUlYLDBDQUFhO1FBQUc7SUFDMUMsR0FBR3VCLE9BQU87SUFFVixzQ0FBc0M7SUFDdEMsTUFBTUMsZ0JBQWdCN0IsNkNBQU1BLENBQUM7UUFDM0IsSUFBSUssb0RBQXVCLENBQUNnQixPQUFPQyxVQUFVLEdBQUdiLEtBQUtZLE9BQU9FLFdBQVcsR0FBR2QsS0FBSztZQUM3RXNCLFdBQVcxQixnREFBbUI7WUFDOUI0QixXQUFXNUIsZ0RBQW1CO1lBQzlCNkIsUUFBUTdCLDZDQUFnQjtZQUN4QitCLE1BQU0vQiw0Q0FBZTtRQUN2QjtRQUNBLElBQUlBLG9EQUF1QixDQUFDZ0IsT0FBT0MsVUFBVSxHQUFHYixLQUFLWSxPQUFPRSxXQUFXLEdBQUdkLEtBQUs7WUFDN0VzQixXQUFXMUIsZ0RBQW1C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L0MsOERBQUNDO2dCQUFjQyxNQUFNO29CQUFDO29CQUFHO2lCQUFFOzs7Ozs7MEJBQzNCLDhEQUFDQztnQkFDQzVELGdCQUFnQkEsNERBQWNBO2dCQUM5QkQsY0FBY0EsbUVBQVlBO2dCQUMxQlEsVUFBVUE7Ozs7Ozs7Ozs7OztBQUlsQjtHQXJHTU47O1FBQ29DSixpREFBUUE7UUFnQ2hERCxpREFBUUE7OztLQWpDSks7QUF1R1MsU0FBUzREO0lBQ3RCLE1BQU0zRCxNQUFNO0lBQ1oscUJBQ0UsOERBQUNQLHNEQUFNQTtRQUNMTyxLQUFLQTtRQUNMNEQsWUFBWTtRQUNaeEQsUUFBUTtZQUFFeUQsVUFBVTtnQkFBQztnQkFBRztnQkFBRzthQUFFO1FBQUM7UUFDOUJDLE9BQU87WUFDTEQsVUFBVTtZQUNWRSxLQUFLO1lBQ0xDLE1BQU07WUFDTlYsT0FBTztZQUNQQyxRQUFRO1FBQ1Y7a0JBRUEsNEVBQUNqRSwyQ0FBUUE7WUFBQzJFLFVBQVU7c0JBQ2xCLDRFQUFDbEU7Z0JBQVNDLEtBQUtBOzs7Ozs7Ozs7Ozs7Ozs7O0FBSXZCO01BcEJ3QjJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvcGFnZS50c3g/MWNiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IFN1c3BlbnNlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENhbnZhcywgdXNlRnJhbWUsIHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHZlcnRleFNoYWRlciBmcm9tICdAL3NoYWRlcnMvY29tbW9uL3ZlcnRleC5nbHNsJzsgLy8gU2ltcGxlIHZlcnRleCBzaGFkZXJcbmltcG9ydCBmcmFnbWVudFNoYWRlciBmcm9tICcuL2ZyYWdtZW50X2ZpbmFsLmdsc2wnOyAvLyBGcmFnbWVudCBzaGFkZXJcblxuY29uc3QgWFBCRFJvcGUgPSAoeyBkcHIgfTogeyBkcHI6IG51bWJlciB9KSA9PiB7XG4gIGNvbnN0IHsgdmlld3BvcnQsIGdsLCBzY2VuZSwgY2FtZXJhIH0gPSB1c2VUaHJlZSgpO1xuXG4gIGNvbnN0IHVuaWZvcm1zID0gdXNlUmVmKHtcbiAgICBpVGltZTogeyB2YWx1ZTogMCB9LFxuICAgIGlUaW1lRGVsdGE6IHsgdmFsdWU6IDAgfSwgLy8gRGVsdGEgdGltZSBiZXR3ZWVuIGZyYW1lc1xuICAgIGlGcmFtZTogeyB2YWx1ZTogMCB9LCAvLyBDdXJyZW50IGZyYW1lIG51bWJlclxuICAgIGlSZXNvbHV0aW9uOiB7XG4gICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIod2luZG93LmlubmVyV2lkdGggKiBkcHIsIHdpbmRvdy5pbm5lckhlaWdodCAqIGRwciksXG4gICAgfSxcbiAgICBpTW91c2U6IHsgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KDAsIDAsIDAsIDApIH0sXG4gICAgaUNoYW5uZWwwOiB7IHZhbHVlOiBuZXcgVEhSRUUuVGV4dHVyZSgpIH0sIC8vIElucHV0IHRleHR1cmVcbiAgfSkuY3VycmVudDtcblxuICAvLyBDcmVhdGUgZG91YmxlLWJ1ZmZlcmVkIFJlbmRlclRhcmdldFxuICBjb25zdCByZW5kZXJUYXJnZXRzID0gdXNlUmVmKFtcbiAgICBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQod2luZG93LmlubmVyV2lkdGggKiBkcHIsIHdpbmRvdy5pbm5lckhlaWdodCAqIGRwciwge1xuICAgICAgbWluRmlsdGVyOiBUSFJFRS5OZWFyZXN0RmlsdGVyLFxuICAgICAgbWFnRmlsdGVyOiBUSFJFRS5OZWFyZXN0RmlsdGVyLFxuICAgICAgZm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0LFxuICAgICAgdHlwZTogVEhSRUUuRmxvYXRUeXBlLFxuICAgIH0pLFxuICAgIG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCh3aW5kb3cuaW5uZXJXaWR0aCAqIGRwciwgd2luZG93LmlubmVySGVpZ2h0ICogZHByLCB7XG4gICAgICBtaW5GaWx0ZXI6IFRIUkVFLk5lYXJlc3RGaWx0ZXIsXG4gICAgICBtYWdGaWx0ZXI6IFRIUkVFLk5lYXJlc3RGaWx0ZXIsXG4gICAgICBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQsXG4gICAgICB0eXBlOiBUSFJFRS5GbG9hdFR5cGUsXG4gICAgfSksXG4gIF0pLmN1cnJlbnQ7XG5cbiAgY29uc3QgYnVmZmVySW5kZXggPSB1c2VSZWYoMCk7XG4gIGxldCBsYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBSZWNvcmQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzIGZyYW1lXG5cbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHVuaWZvcm1zLmlUaW1lRGVsdGEudmFsdWUgPSAobm93IC0gbGFzdFRpbWUpIC8gMTAwMDsgLy8gQ29tcHV0ZSBkZWx0YSB0aW1lIGluIHNlY29uZHNcbiAgICBsYXN0VGltZSA9IG5vdztcblxuICAgIHVuaWZvcm1zLmlUaW1lLnZhbHVlICs9IHVuaWZvcm1zLmlUaW1lRGVsdGEudmFsdWU7XG4gICAgdW5pZm9ybXMuaUZyYW1lLnZhbHVlKys7IC8vIEluY3JlbWVudCBmcmFtZSBjb3VudGVyXG4gICAgdW5pZm9ybXMuaVJlc29sdXRpb24udmFsdWUuc2V0KHdpbmRvdy5pbm5lcldpZHRoICogZHByLCB3aW5kb3cuaW5uZXJIZWlnaHQgKiBkcHIpO1xuXG4gICAgLy9jb25zb2xlLmxvZygnRnJhbWU6JywgdW5pZm9ybXMuaUZyYW1lLnZhbHVlKTtcbiAgICAvL2NvbnNvbGUubG9nKCdUaW1lOicsIHVuaWZvcm1zLmlUaW1lLnZhbHVlKTtcblxuICAgIC8vIFNldCB0aGUgY3VycmVudCBmcmFtZSBpbnB1dCB0ZXh0dXJlICh1c2luZyB0aGUgb3RoZXIgUmVuZGVyVGFyZ2V0KVxuICAgIHVuaWZvcm1zLmlDaGFubmVsMC52YWx1ZSA9IHJlbmRlclRhcmdldHNbMSAtIGJ1ZmZlckluZGV4LmN1cnJlbnRdLnRleHR1cmU7XG5cbiAgICBnbC5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0c1tidWZmZXJJbmRleC5jdXJyZW50XSk7XG4gICAgZ2wucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIGdsLnNldFJlbmRlclRhcmdldChudWxsKTsgLy8gU3dpdGNoIGJhY2sgdG8gdGhlIGRlZmF1bHQgZnJhbWVidWZmZXJcblxuICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgIGJ1ZmZlckluZGV4LmN1cnJlbnQgPSAxIC0gYnVmZmVySW5kZXguY3VycmVudDtcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIHVuaWZvcm1zLmlNb3VzZS52YWx1ZS54ID0gZXZlbnQuY2xpZW50WCAqIGRwcjtcbiAgICAgIHVuaWZvcm1zLmlNb3VzZS52YWx1ZS55ID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGV2ZW50LmNsaWVudFkpICogZHByOyAvLyBGbGlwIFktYXhpc1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZURvd24gPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5idXR0b24gPT09IDApIHtcbiAgICAgICAgdW5pZm9ybXMuaU1vdXNlLnZhbHVlLnogPSAxOyAvLyDlt6bplK7mjInkuItcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VVcCA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB1bmlmb3Jtcy5pTW91c2UudmFsdWUueiA9IDA7IC8vIOW3pumUrumHiuaUvlxuICAgICAgfSBlbHNlIGlmIChldmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgdW5pZm9ybXMuaU1vdXNlLnZhbHVlLnogPSAyOyAvLyDlj7PplK7ph4rmlL7nmoTnnqzpl7RcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB1bmlmb3Jtcy5pTW91c2UudmFsdWUueiA9IDA7IC8vIOS4i+S4gOW4p+aBouWkjeS4uiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpOyAvLyDpmLvmraLlj7PplK7oj5zljZVcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgICB9O1xuICB9LCBbZHByXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8bWVzaCBzY2FsZT17W3ZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQsIDFdfT5cbiAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1sxLCAxXX0gLz5cbiAgICAgIDxzaGFkZXJNYXRlcmlhbFxuICAgICAgICBmcmFnbWVudFNoYWRlcj17ZnJhZ21lbnRTaGFkZXJ9XG4gICAgICAgIHZlcnRleFNoYWRlcj17dmVydGV4U2hhZGVyfVxuICAgICAgICB1bmlmb3Jtcz17dW5pZm9ybXN9XG4gICAgICAvPlxuICAgIDwvbWVzaD5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFhQQkRSb3BlUGFnZSgpIHtcbiAgY29uc3QgZHByID0gMTtcbiAgcmV0dXJuIChcbiAgICA8Q2FudmFzXG4gICAgICBkcHI9e2Rwcn1cbiAgICAgIG9ydGhvZ3JhcGhpY1xuICAgICAgY2FtZXJhPXt7IHBvc2l0aW9uOiBbMCwgMCwgNl0gfX1cbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiAnMTAwdncnLFxuICAgICAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgICB9fVxuICAgID5cbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17bnVsbH0+XG4gICAgICAgIDxYUEJEUm9wZSBkcHI9e2Rwcn0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgPC9DYW52YXM+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiU3VzcGVuc2UiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJDYW52YXMiLCJ1c2VGcmFtZSIsInVzZVRocmVlIiwiVEhSRUUiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsIlhQQkRSb3BlIiwiZHByIiwidmlld3BvcnQiLCJnbCIsInNjZW5lIiwiY2FtZXJhIiwidW5pZm9ybXMiLCJpVGltZSIsInZhbHVlIiwiaVRpbWVEZWx0YSIsImlGcmFtZSIsImlSZXNvbHV0aW9uIiwiVmVjdG9yMiIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImlNb3VzZSIsIlZlY3RvcjQiLCJpQ2hhbm5lbDAiLCJUZXh0dXJlIiwiY3VycmVudCIsInJlbmRlclRhcmdldHMiLCJXZWJHTFJlbmRlclRhcmdldCIsIm1pbkZpbHRlciIsIk5lYXJlc3RGaWx0ZXIiLCJtYWdGaWx0ZXIiLCJmb3JtYXQiLCJSR0JBRm9ybWF0IiwidHlwZSIsIkZsb2F0VHlwZSIsImJ1ZmZlckluZGV4IiwibGFzdFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInNldCIsInRleHR1cmUiLCJzZXRSZW5kZXJUYXJnZXQiLCJyZW5kZXIiLCJoYW5kbGVNb3VzZU1vdmUiLCJldmVudCIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJoYW5kbGVNb3VzZURvd24iLCJidXR0b24iLCJ6IiwiaGFuZGxlTW91c2VVcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibWVzaCIsInNjYWxlIiwid2lkdGgiLCJoZWlnaHQiLCJwbGFuZUdlb21ldHJ5IiwiYXJncyIsInNoYWRlck1hdGVyaWFsIiwiWFBCRFJvcGVQYWdlIiwib3J0aG9ncmFwaGljIiwicG9zaXRpb24iLCJzdHlsZSIsInRvcCIsImxlZnQiLCJmYWxsYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A4/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_final.glsl":
/*!****************************************************************!*\
  !*** ./src/app/(assignment)/assignment/A4/fragment_final.glsl ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"precision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vUv;\\n\\nuniform float iTime;\\nuniform float iTimeDelta;\\nuniform float iFrame;\\nuniform vec2  iResolution;\\nuniform vec4  iMouse;\\nuniform sampler2D iChannel0; // previous frame state\\n\\n// ------------------------------------------------------------------------\\n// 1) YOUR ORIGINAL PBD SIMULATION (2D) -----------------------------------\\n// ------------------------------------------------------------------------\\n\\nfloat remap01(float inp, float a, float b) {\\n    return clamp((inp - a) / (b - a), 0.0, 1.0);\\n}\\nfloat dist_sqr(vec2 A, vec2 B) {\\n    vec2 d = A - B;\\n    return dot(d,d);\\n}\\n\\nconst float RADIUS = 0.015;\\nconst float damp = 2.0;\\nconst float collision_dist = RADIUS * 1.5;\\nconst float ground_collision_dist = collision_dist * 0.1;\\nconst vec2 gravity = vec2(0.0, -1.0);\\nconst float PI = 3.14159265359;\\n\\nstruct Particle { vec2 pos, pos_prev, vel; float inv_mass; bool fixed; };\\nstruct Spring   { int a, b; float restLength, inv_stiffness; };\\n\\nconst int MAX_PARTICLES = 100;\\nconst int MAX_SPRINGS   =  40;\\nconst int initial_particles = 40;\\n\\nint   n_particles, n_springs, selected_particle, current_add_particle;\\nParticle particles[MAX_PARTICLES];\\nSpring   springs[MAX_SPRINGS];\\n\\nSpring add_spring(int a, int b, float inv_k) {\\n    Spring s;\\n    s.a = a; s.b = b;\\n    s.restLength = length(particles[a].pos - particles[b].pos);\\n    s.inv_stiffness = inv_k;\\n    return s;\\n}\\n\\nvec2 screen_to_xy(vec2 uv) {\\n    return (uv - 0.5 * iResolution.xy) * 2.0 / iResolution.y;\\n}\\nbool is_init() {\\n    return (iTime < 0.06) || (iFrame < 2.0);\\n}\\n\\nvoid init_state() {\\n    n_particles = initial_particles;\\n    n_springs   = initial_particles - 1;\\n    float xs = -0.9, xe = -0.3, ys =  0.4, ye = -0.3;\\n    for(int i=1;i<initial_particles;i++){\\n        float t = float(i-1)/float(initial_particles-2);\\n        particles[i].pos = mix(vec2(xs,ys), vec2(xe,ye), t);\\n        particles[i].vel = vec2(0.0);\\n        particles[i].inv_mass = (i==1||i==initial_particles-1)?0.0:1.0;\\n        particles[i].fixed    = (i==1||i==initial_particles-1);\\n    }\\n    current_add_particle = initial_particles;\\n    for(int i=1;i<initial_particles-1;i++){\\n        springs[i] = add_spring(i, i+1, 1.0/80000.0);\\n    }\\n}\\n\\nint nearest_particle(vec2 p){\\n    int idx=1; float md=1e9;\\n    for(int i=1;i<n_particles;i++){\\n        float d = dist_sqr(p, particles[i].pos);\\n        if(d<md){ md=d; idx=i; }\\n    }\\n    return idx;\\n}\\n\\nvoid load_state(){\\n    // (0,0) holds: n_particles, n_springs, selected, current_add\\n    vec4 d00 = texelFetch(iChannel0, ivec2(0,0),0);\\n    n_particles       = int(d00.x);\\n    n_springs         = int(d00.y);\\n    selected_particle = int(d00.z);\\n    current_add_particle = int(d00.w);\\n\\n    // mouse particle at idx=0\\n    particles[0].pos       = screen_to_xy(iMouse.xy);\\n    particles[0].vel       = vec2(0.0);\\n    particles[0].inv_mass  = 0.0;\\n    particles[0].fixed     = true;\\n\\n    // load other particles\\n    for(int i=1;i<n_particles;i++){\\n        vec4 d = texelFetch(iChannel0, ivec2(i,0),0);\\n        particles[i].pos      = d.xy;\\n        particles[i].vel      = d.zw;\\n        particles[i].inv_mass = 1.0;\\n        particles[i].fixed    = false;\\n        if(i==1||i==initial_particles-1){\\n            particles[i].inv_mass = 0.0;\\n            particles[i].fixed    = true;\\n        }\\n    }\\n\\n    // spring[0] = mouse to selected\\n    springs[0] = add_spring(0, selected_particle, 1.0/100.0);\\n\\n    // load rest\\n    for(int i=1;i<n_springs;i++){\\n        vec4 d = texelFetch(iChannel0, ivec2(i,1),0);\\n        springs[i].a = int(d.x);\\n        springs[i].b = int(d.y);\\n        springs[i].restLength   = d.z;\\n        springs[i].inv_stiffness= d.w;\\n    }\\n\\n    // pick/drag logic\\n    if(iMouse.z==1.0){\\n        if(selected_particle<0){\\n            selected_particle = nearest_particle(particles[0].pos);\\n        }\\n    } else selected_particle = -1;\\n\\n    if(iMouse.z==2.0 && selected_particle>=0){\\n        // add a new spring from selected to a new particle\\n        if(current_add_particle<MAX_PARTICLES){\\n            particles[current_add_particle].pos      = screen_to_xy(iMouse.xy);\\n            particles[current_add_particle].vel      = vec2(0.0);\\n            particles[current_add_particle].inv_mass = 1.0;\\n            particles[current_add_particle].fixed    = false;\\n            n_particles = max(n_particles, current_add_particle+1);\\n            springs[n_springs++] = add_spring(selected_particle, current_add_particle, 1.0/80000.0);\\n            current_add_particle++;\\n        }\\n    }\\n}\\n\\nfloat spring_C(Spring s){\\n    return length(particles[s.a].pos - particles[s.b].pos) - s.restLength;\\n}\\nvec2 grad_C(vec2 a, vec2 b){\\n    vec2 d = a-b; float L=length(d);\\n    return (L<1e-6) ? vec2(0.0) : d/L;\\n}\\nvec2 spring_grad(Spring s, int idx){\\n    vec2 g = grad_C(particles[s.a].pos, particles[s.b].pos);\\n    return (idx==s.a ? +g : -g);\\n}\\nvoid solve_spring(Spring s, float dt){\\n    float C = spring_C(s);\\n    vec2 ga = spring_grad(s, s.a);\\n    vec2 gb = spring_grad(s, s.b);\\n    float invMa = particles[s.a].inv_mass * dot(ga,ga);\\n    float invMb = particles[s.b].inv_mass * dot(gb,gb);\\n    float denom = invMa+invMb + s.inv_stiffness/(dt*dt);\\n    if(denom<1e-6) return;\\n    float λ = -C/denom;\\n    particles[s.a].pos += λ * particles[s.a].inv_mass * ga;\\n    particles[s.b].pos += λ * particles[s.b].inv_mass * gb;\\n}\\n\\nfloat col_C(vec2 a, vec2 b){\\n    float d=length(a-b);\\n    return (d<collision_dist) ? (d-collision_dist) : 0.0;\\n}\\nvec2 col_grad(vec2 a, vec2 b){\\n    return (a==b) ? vec2(0.0) : normalize(a-b);\\n}\\nvoid solve_collision(int i,int j,float dt){\\n    vec2 a=particles[i].pos, b=particles[j].pos;\\n    vec2 g = col_grad(a,b);\\n    if(length(g)<1e-6) return;\\n    float C = col_C(a,b);\\n    float invMi = particles[i].inv_mass * dot(g,g);\\n    float invMj = particles[j].inv_mass * dot(g,g);\\n    float denom = invMi+invMj + 1.0/1000.0/(dt*dt);\\n    float λ = -C/denom;\\n    particles[i].pos += λ * particles[i].inv_mass * g;\\n    particles[j].pos -= λ * particles[j].inv_mass * g;\\n}\\n\\nfloat φ2d(vec2 p){\\n    return p.y - (0.1*sin(p.x*2.0*PI) - 0.5);\\n}\\nfloat ground_C(vec2 p){\\n    float v = φ2d(p);\\n    return (v<ground_collision_dist) ? (v-ground_collision_dist) : 0.0;\\n}\\nvec2 ground_grad(vec2 p){\\n    float gx = -0.2*PI*cos(2.0*PI*p.x);\\n    return vec2(gx,1.0);\\n}\\nvoid solve_ground(int i,float dt){\\n    vec2 p = particles[i].pos;\\n    vec2 g = ground_grad(p);\\n    float C = ground_C(p);\\n    float denom = particles[i].inv_mass*dot(g,g) + 1.0/1000.0/(dt*dt);\\n    float λ = -C/denom;\\n    particles[i].pos += λ * particles[i].inv_mass * g;\\n}\\n\\nvoid solve_all(float dt){\\n    if(iMouse.z==1.0) solve_spring(springs[0], dt);\\n    for(int i=1;i<n_springs;i++) solve_spring(springs[i], dt);\\n    for(int i=1;i<n_particles;i++){\\n        for(int j=i+1;j<n_particles;j++) solve_collision(i,j,dt);\\n    }\\n    for(int i=1;i<n_particles;i++) solve_ground(i,dt);\\n}\\n\\nvoid simulate(){\\n    float dt = min(iTimeDelta,0.02) / 5.0;\\n    for(int s=0;s<5;s++){\\n        for(int i=0;i<n_particles;i++){\\n            if(!particles[i].fixed){\\n                particles[i].vel += dt*gravity;\\n                particles[i].vel *= exp(-damp*dt);\\n            }\\n            particles[i].pos_prev = particles[i].pos;\\n            particles[i].pos += dt * particles[i].vel;\\n        }\\n        solve_all(dt);\\n        for(int i=0;i<n_particles;i++){\\n            if(!particles[i].fixed)\\n                particles[i].vel = (particles[i].pos - particles[i].pos_prev)/dt;\\n        }\\n        particles[0].pos = screen_to_xy(iMouse.xy); // keep mouse fixed\\n    }\\n}\\n\\n// ------------------------------------------------------------------------\\n// 2) A 3D SDF SCENE & PHONG SHADING --------------------------------------\\n// ------------------------------------------------------------------------\\n\\n// capsule SDF between A,B with radius r\\nfloat sdCapsule(vec3 p, vec3 A, vec3 B, float r){\\n    vec3 pa = p - A;\\n    vec3 ba = B - A;\\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\\n    return length(pa - ba*h) - r;\\n}\\n// sphere SDF\\nfloat sdSphere(vec3 p, vec3 C, float r){\\n    return length(p-C) - r;\\n}\\n// wavy ground plane\\nfloat sdGround(vec3 p){\\n    float w = 0.1 * sin(p.x*2.0*PI) - 0.5;\\n    return p.y - w;\\n}\\n\\n// scene SDF: ground ∪ fluid spheres ∪ rope capsules\\nfloat sceneSDF(vec3 p){\\n    float d = sdGround(p);\\n\\n    // fluid particles as spheres\\n    for(int i=initial_particles;i<n_particles;i++){\\n        vec3 pc = vec3(particles[i].pos, 0.0);\\n        d = min(d, sdSphere(p, pc, RADIUS));\\n    }\\n    // rope springs as capsules\\n    for(int i=1;i<n_springs;i++){\\n        vec3 A = vec3(particles[springs[i].a].pos, 0.0);\\n        vec3 B = vec3(particles[springs[i].b].pos, 0.0);\\n        d = min(d, sdCapsule(p, A, B, RADIUS*0.6));\\n    }\\n    // mouse–first spring link\\n    {\\n        vec3 A = vec3(particles[0].pos,0.0);\\n        vec3 B = vec3(particles[selected_particle].pos,0.0);\\n        d = min(d, sdCapsule(p, A, B, RADIUS*0.6));\\n    }\\n\\n    return d;\\n}\\n\\n// ray direction from camera\\nvec3 rayDir(vec2 uv){\\n    vec2 p = (uv - 0.5)*2.0;\\n    p.x *= iResolution.x/iResolution.y;\\n    return normalize(vec3(p, -1.0));\\n}\\n\\n// ray march\\nvec3 rayMarch(vec3 ro, vec3 rd){\\n    float t = 0.0;\\n    for(int i=0;i<128;i++){\\n        vec3 pos = ro + rd * t;\\n        float d = sceneSDF(pos);\\n        if(d<0.001) return pos;\\n        if(t>50.0) break;\\n        t += d;\\n    }\\n    return vec3(0.0, -1.0, 0.0); // miss: below ground\\n}\\n\\n// normal via numeric gradient\\nvec3 estimateNormal(vec3 p){\\n    float h = 0.0005;\\n    return normalize(vec3(\\n        sceneSDF(p + vec3(h,0,0)) - sceneSDF(p - vec3(h,0,0)),\\n        sceneSDF(p + vec3(0,h,0)) - sceneSDF(p - vec3(0,h,0)),\\n        sceneSDF(p + vec3(0,0,h)) - sceneSDF(p - vec3(0,0,h))\\n    ));\\n}\\n\\n// Phong shading\\nvec3 phong(vec3 p, vec3 ro, vec3 N){\\n    vec3 lightPos = vec3(2.0,2.0,2.0);\\n    vec3 L = normalize(lightPos - p);\\n    vec3 V = normalize(ro - p);\\n    vec3 H = normalize(L+V);\\n    float diff = max(dot(N,L),0.0);\\n    float spec = pow(max(dot(N,H),0.0), 64.0);\\n    vec3 ambient = vec3(0.1);\\n    vec3 base    = vec3(0.4,0.7,1.0);\\n    return ambient + diff*base + spec*vec3(1.0);\\n}\\n\\n// ------------------------------------------------------------------------\\n// 3) MAIN: PACK SIM & RENDER ---------------------------------------------\\n// ------------------------------------------------------------------------\\nvoid main(){\\n    vec2 pix = vUv * iResolution.xy;\\n    int i = int(pix.x);\\n    int j = int(pix.y);\\n\\n    // --- row 0: particles state ---  \\n    if(j==0){\\n        if(i==0){\\n            gl_FragColor = vec4(\\n                float(n_particles),\\n                float(n_springs),\\n                float(selected_particle),\\n                float(current_add_particle)\\n            );\\n        }\\n        else if(i < n_particles){\\n            Particle P = particles[i];\\n            gl_FragColor = vec4(P.pos, P.vel);\\n        } else {\\n            gl_FragColor = vec4(0.0,0.0,0.0,1.0);\\n        }\\n        return;\\n    }\\n\\n    // --- row 1: springs state ---\\n    if(j==1){\\n        if(i < n_springs){\\n            Spring s = springs[i];\\n            gl_FragColor = vec4(\\n                float(s.a), float(s.b),\\n                s.restLength, s.inv_stiffness\\n            );\\n        } else {\\n            gl_FragColor = vec4(0.0,0.0,0.0,1.0);\\n        }\\n        return;\\n    }\\n\\n    // --- all other rows: do sim + render ---\\n    if(is_init()){\\n        init_state();\\n    } else {\\n        load_state();\\n        simulate();\\n    }\\n\\n    // map pixel to [0,1] in the render region offset by 2 scanlines\\n    float H = iResolution.y - 2.0;\\n    vec2 uv = vec2(\\n        pix.x / iResolution.x,\\n        (pix.y - 2.0) / H\\n    );\\n\\n    // camera setup\\n    vec3 ro = vec3(0.0, 0.0, 5.0);\\n    vec3 rd = rayDir(uv);\\n\\n    vec3 hit = rayMarch(ro, rd);\\n    vec3 N   = estimateNormal(hit);\\n    vec3 col = phong(hit, ro, N);\\n\\n    gl_FragColor = vec4(col,1.0);\\n}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTQvZnJhZ21lbnRfZmluYWwuZ2xzbCIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsdUJBQXVCLHNDQUFzQyx3QkFBd0IsMkJBQTJCLHVCQUF1Qiw0QkFBNEIsdUJBQXVCLCtCQUErQixnVEFBZ1Qsa0RBQWtELEdBQUcsa0NBQWtDLHFCQUFxQixzQkFBc0IsR0FBRywrQkFBK0IseUJBQXlCLDRDQUE0QywyREFBMkQsdUNBQXVDLGlDQUFpQyxzQkFBc0IseUJBQXlCLGdCQUFnQixjQUFjLG9CQUFvQixVQUFVLG1DQUFtQyxrQ0FBa0MsZ0NBQWdDLG1DQUFtQywwRUFBMEUsb0NBQW9DLGdDQUFnQyxrREFBa0QsZUFBZSxlQUFlLFFBQVEsaUVBQWlFLDhCQUE4QixlQUFlLEdBQUcsZ0NBQWdDLCtEQUErRCxHQUFHLGtCQUFrQiw4Q0FBOEMsR0FBRyx1QkFBdUIsc0NBQXNDLDBDQUEwQyx1REFBdUQsa0JBQWtCLG9CQUFvQixLQUFLLDBEQUEwRCw4REFBOEQsdUNBQXVDLHlFQUF5RSxpRUFBaUUsT0FBTywrQ0FBK0Msa0JBQWtCLHNCQUFzQixLQUFLLHVEQUF1RCxPQUFPLEdBQUcsaUNBQWlDLGlCQUFpQixhQUFhLGtCQUFrQixjQUFjLEtBQUssa0RBQWtELG9CQUFvQixNQUFNLFFBQVEsT0FBTyxpQkFBaUIsR0FBRyxzQkFBc0Isd0hBQXdILHFDQUFxQyxxQ0FBcUMscUNBQXFDLHdDQUF3Qyx5RkFBeUYseUNBQXlDLG1DQUFtQyxvQ0FBb0MsaURBQWlELGNBQWMsS0FBSyx1REFBdUQsdUNBQXVDLHVDQUF1QyxzQ0FBc0Msd0NBQXdDLDJDQUEyQywwQ0FBMEMsMkNBQTJDLFdBQVcsT0FBTyx1R0FBdUcsc0NBQXNDLFlBQVksS0FBSyx1REFBdUQsa0NBQWtDLGtDQUFrQyx3Q0FBd0Msd0NBQXdDLE9BQU8sa0RBQWtELGtDQUFrQyxxRUFBcUUsV0FBVyxRQUFRLDRCQUE0QixrREFBa0QsOEdBQThHLGlGQUFpRixtRUFBbUUsNkRBQTZELCtEQUErRCxxRUFBcUUsc0dBQXNHLHFDQUFxQyxXQUFXLE9BQU8sR0FBRyw2QkFBNkIsNEVBQTRFLEdBQUcsOEJBQThCLG9CQUFvQixrQkFBa0Isd0NBQXdDLEdBQUcsc0NBQXNDLDhEQUE4RCxrQ0FBa0MsR0FBRyx3Q0FBd0MsNEJBQTRCLG9DQUFvQyxvQ0FBb0MseURBQXlELHlEQUF5RCwwREFBMEQsNEJBQTRCLHlCQUF5Qiw2REFBNkQsNkRBQTZELEdBQUcsZ0NBQWdDLDBCQUEwQiwyREFBMkQsR0FBRyxnQ0FBZ0MsaURBQWlELEdBQUcsNkNBQTZDLGtEQUFrRCw2QkFBNkIsZ0NBQWdDLDJCQUEyQixxREFBcUQscURBQXFELHFEQUFxRCx5QkFBeUIsd0RBQXdELHdEQUF3RCxHQUFHLHNCQUFzQiwrQ0FBK0MsR0FBRyx5QkFBeUIsdUJBQXVCLHlFQUF5RSxHQUFHLDJCQUEyQix5Q0FBeUMsMEJBQTBCLEdBQUcsb0NBQW9DLGdDQUFnQyw4QkFBOEIsNEJBQTRCLHdFQUF3RSx5QkFBeUIsd0RBQXdELEdBQUcsNkJBQTZCLHFEQUFxRCxrQkFBa0IsWUFBWSxrQ0FBa0Msa0JBQWtCLGNBQWMsS0FBSyx3QkFBd0IsY0FBYyw2QkFBNkIsT0FBTyxrQkFBa0IsY0FBYyx3QkFBd0IsR0FBRyxvQkFBb0IsNENBQTRDLGtCQUFrQixJQUFJLEtBQUssc0JBQXNCLGNBQWMsS0FBSyxzQ0FBc0MsaURBQWlELG9EQUFvRCxlQUFlLHVEQUF1RCx3REFBd0QsV0FBVyx3QkFBd0Isc0JBQXNCLGNBQWMsS0FBSyx3SEFBd0gsV0FBVyxzREFBc0QsMEJBQTBCLEdBQUcsd1VBQXdVLHNCQUFzQixzQkFBc0IsdURBQXVELG1DQUFtQyxHQUFHLHlEQUF5RCw2QkFBNkIsR0FBRywrQ0FBK0MsNENBQTRDLHFCQUFxQixHQUFHLGlGQUFpRiw0QkFBNEIsdUVBQXVFLGNBQWMsS0FBSyxnREFBZ0QsOENBQThDLE9BQU8sbURBQW1ELFlBQVksS0FBSywwREFBMEQsMERBQTBELHFEQUFxRCxPQUFPLHVDQUF1Qyw4Q0FBOEMsOERBQThELHFEQUFxRCxPQUFPLGlCQUFpQixHQUFHLHVEQUF1RCw4QkFBOEIseUNBQXlDLHNDQUFzQyxHQUFHLGtEQUFrRCxvQkFBb0Isa0JBQWtCLE1BQU0sS0FBSyxpQ0FBaUMsa0NBQWtDLGlDQUFpQywyQkFBMkIsaUJBQWlCLE9BQU8sbUNBQW1DLHdCQUF3QixnRUFBZ0UsdUJBQXVCLG9PQUFvTyxHQUFHLDBEQUEwRCx3Q0FBd0MsdUNBQXVDLGlDQUFpQyw4QkFBOEIscUNBQXFDLGdEQUFnRCwrQkFBK0IsdUNBQXVDLGtEQUFrRCxHQUFHLHVQQUF1UCxzQ0FBc0MseUJBQXlCLHlCQUF5QiwwREFBMEQsbUJBQW1CLGtOQUFrTixXQUFXLG1DQUFtQyx3Q0FBd0MsZ0RBQWdELFlBQVksTUFBTSxtREFBbUQsV0FBVyxpQkFBaUIsT0FBTyxzREFBc0QsNEJBQTRCLG9DQUFvQywwSUFBMEksWUFBWSxNQUFNLG1EQUFtRCxXQUFXLGlCQUFpQixPQUFPLHNFQUFzRSx1QkFBdUIsUUFBUSxNQUFNLHVCQUF1QixxQkFBcUIsT0FBTyw0R0FBNEcsd0ZBQXdGLDJEQUEyRCwyQkFBMkIsb0NBQW9DLHFDQUFxQyxtQ0FBbUMscUNBQXFDLEdBQUcsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwLyhhc3NpZ25tZW50KS9hc3NpZ25tZW50L0E0L2ZyYWdtZW50X2ZpbmFsLmdsc2w/ZTI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxudW5pZm9ybSBmbG9hdCBpVGltZTtcXG51bmlmb3JtIGZsb2F0IGlUaW1lRGVsdGE7XFxudW5pZm9ybSBmbG9hdCBpRnJhbWU7XFxudW5pZm9ybSB2ZWMyICBpUmVzb2x1dGlvbjtcXG51bmlmb3JtIHZlYzQgIGlNb3VzZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBpQ2hhbm5lbDA7IC8vIHByZXZpb3VzIGZyYW1lIHN0YXRlXFxuXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gMSkgWU9VUiBPUklHSU5BTCBQQkQgU0lNVUxBVElPTiAoMkQpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuZmxvYXQgcmVtYXAwMShmbG9hdCBpbnAsIGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGNsYW1wKChpbnAgLSBhKSAvIChiIC0gYSksIDAuMCwgMS4wKTtcXG59XFxuZmxvYXQgZGlzdF9zcXIodmVjMiBBLCB2ZWMyIEIpIHtcXG4gICAgdmVjMiBkID0gQSAtIEI7XFxuICAgIHJldHVybiBkb3QoZCxkKTtcXG59XFxuXFxuY29uc3QgZmxvYXQgUkFESVVTID0gMC4wMTU7XFxuY29uc3QgZmxvYXQgZGFtcCA9IDIuMDtcXG5jb25zdCBmbG9hdCBjb2xsaXNpb25fZGlzdCA9IFJBRElVUyAqIDEuNTtcXG5jb25zdCBmbG9hdCBncm91bmRfY29sbGlzaW9uX2Rpc3QgPSBjb2xsaXNpb25fZGlzdCAqIDAuMTtcXG5jb25zdCB2ZWMyIGdyYXZpdHkgPSB2ZWMyKDAuMCwgLTEuMCk7XFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU5O1xcblxcbnN0cnVjdCBQYXJ0aWNsZSB7IHZlYzIgcG9zLCBwb3NfcHJldiwgdmVsOyBmbG9hdCBpbnZfbWFzczsgYm9vbCBmaXhlZDsgfTtcXG5zdHJ1Y3QgU3ByaW5nICAgeyBpbnQgYSwgYjsgZmxvYXQgcmVzdExlbmd0aCwgaW52X3N0aWZmbmVzczsgfTtcXG5cXG5jb25zdCBpbnQgTUFYX1BBUlRJQ0xFUyA9IDEwMDtcXG5jb25zdCBpbnQgTUFYX1NQUklOR1MgICA9ICA0MDtcXG5jb25zdCBpbnQgaW5pdGlhbF9wYXJ0aWNsZXMgPSA0MDtcXG5cXG5pbnQgICBuX3BhcnRpY2xlcywgbl9zcHJpbmdzLCBzZWxlY3RlZF9wYXJ0aWNsZSwgY3VycmVudF9hZGRfcGFydGljbGU7XFxuUGFydGljbGUgcGFydGljbGVzW01BWF9QQVJUSUNMRVNdO1xcblNwcmluZyAgIHNwcmluZ3NbTUFYX1NQUklOR1NdO1xcblxcblNwcmluZyBhZGRfc3ByaW5nKGludCBhLCBpbnQgYiwgZmxvYXQgaW52X2spIHtcXG4gICAgU3ByaW5nIHM7XFxuICAgIHMuYSA9IGE7IHMuYiA9IGI7XFxuICAgIHMucmVzdExlbmd0aCA9IGxlbmd0aChwYXJ0aWNsZXNbYV0ucG9zIC0gcGFydGljbGVzW2JdLnBvcyk7XFxuICAgIHMuaW52X3N0aWZmbmVzcyA9IGludl9rO1xcbiAgICByZXR1cm4gcztcXG59XFxuXFxudmVjMiBzY3JlZW5fdG9feHkodmVjMiB1dikge1xcbiAgICByZXR1cm4gKHV2IC0gMC41ICogaVJlc29sdXRpb24ueHkpICogMi4wIC8gaVJlc29sdXRpb24ueTtcXG59XFxuYm9vbCBpc19pbml0KCkge1xcbiAgICByZXR1cm4gKGlUaW1lIDwgMC4wNikgfHwgKGlGcmFtZSA8IDIuMCk7XFxufVxcblxcbnZvaWQgaW5pdF9zdGF0ZSgpIHtcXG4gICAgbl9wYXJ0aWNsZXMgPSBpbml0aWFsX3BhcnRpY2xlcztcXG4gICAgbl9zcHJpbmdzICAgPSBpbml0aWFsX3BhcnRpY2xlcyAtIDE7XFxuICAgIGZsb2F0IHhzID0gLTAuOSwgeGUgPSAtMC4zLCB5cyA9ICAwLjQsIHllID0gLTAuMztcXG4gICAgZm9yKGludCBpPTE7aTxpbml0aWFsX3BhcnRpY2xlcztpKyspe1xcbiAgICAgICAgZmxvYXQgdCA9IGZsb2F0KGktMSkvZmxvYXQoaW5pdGlhbF9wYXJ0aWNsZXMtMik7XFxuICAgICAgICBwYXJ0aWNsZXNbaV0ucG9zID0gbWl4KHZlYzIoeHMseXMpLCB2ZWMyKHhlLHllKSwgdCk7XFxuICAgICAgICBwYXJ0aWNsZXNbaV0udmVsID0gdmVjMigwLjApO1xcbiAgICAgICAgcGFydGljbGVzW2ldLmludl9tYXNzID0gKGk9PTF8fGk9PWluaXRpYWxfcGFydGljbGVzLTEpPzAuMDoxLjA7XFxuICAgICAgICBwYXJ0aWNsZXNbaV0uZml4ZWQgICAgPSAoaT09MXx8aT09aW5pdGlhbF9wYXJ0aWNsZXMtMSk7XFxuICAgIH1cXG4gICAgY3VycmVudF9hZGRfcGFydGljbGUgPSBpbml0aWFsX3BhcnRpY2xlcztcXG4gICAgZm9yKGludCBpPTE7aTxpbml0aWFsX3BhcnRpY2xlcy0xO2krKyl7XFxuICAgICAgICBzcHJpbmdzW2ldID0gYWRkX3NwcmluZyhpLCBpKzEsIDEuMC84MDAwMC4wKTtcXG4gICAgfVxcbn1cXG5cXG5pbnQgbmVhcmVzdF9wYXJ0aWNsZSh2ZWMyIHApe1xcbiAgICBpbnQgaWR4PTE7IGZsb2F0IG1kPTFlOTtcXG4gICAgZm9yKGludCBpPTE7aTxuX3BhcnRpY2xlcztpKyspe1xcbiAgICAgICAgZmxvYXQgZCA9IGRpc3Rfc3FyKHAsIHBhcnRpY2xlc1tpXS5wb3MpO1xcbiAgICAgICAgaWYoZDxtZCl7IG1kPWQ7IGlkeD1pOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGlkeDtcXG59XFxuXFxudm9pZCBsb2FkX3N0YXRlKCl7XFxuICAgIC8vICgwLDApIGhvbGRzOiBuX3BhcnRpY2xlcywgbl9zcHJpbmdzLCBzZWxlY3RlZCwgY3VycmVudF9hZGRcXG4gICAgdmVjNCBkMDAgPSB0ZXhlbEZldGNoKGlDaGFubmVsMCwgaXZlYzIoMCwwKSwwKTtcXG4gICAgbl9wYXJ0aWNsZXMgICAgICAgPSBpbnQoZDAwLngpO1xcbiAgICBuX3NwcmluZ3MgICAgICAgICA9IGludChkMDAueSk7XFxuICAgIHNlbGVjdGVkX3BhcnRpY2xlID0gaW50KGQwMC56KTtcXG4gICAgY3VycmVudF9hZGRfcGFydGljbGUgPSBpbnQoZDAwLncpO1xcblxcbiAgICAvLyBtb3VzZSBwYXJ0aWNsZSBhdCBpZHg9MFxcbiAgICBwYXJ0aWNsZXNbMF0ucG9zICAgICAgID0gc2NyZWVuX3RvX3h5KGlNb3VzZS54eSk7XFxuICAgIHBhcnRpY2xlc1swXS52ZWwgICAgICAgPSB2ZWMyKDAuMCk7XFxuICAgIHBhcnRpY2xlc1swXS5pbnZfbWFzcyAgPSAwLjA7XFxuICAgIHBhcnRpY2xlc1swXS5maXhlZCAgICAgPSB0cnVlO1xcblxcbiAgICAvLyBsb2FkIG90aGVyIHBhcnRpY2xlc1xcbiAgICBmb3IoaW50IGk9MTtpPG5fcGFydGljbGVzO2krKyl7XFxuICAgICAgICB2ZWM0IGQgPSB0ZXhlbEZldGNoKGlDaGFubmVsMCwgaXZlYzIoaSwwKSwwKTtcXG4gICAgICAgIHBhcnRpY2xlc1tpXS5wb3MgICAgICA9IGQueHk7XFxuICAgICAgICBwYXJ0aWNsZXNbaV0udmVsICAgICAgPSBkLnp3O1xcbiAgICAgICAgcGFydGljbGVzW2ldLmludl9tYXNzID0gMS4wO1xcbiAgICAgICAgcGFydGljbGVzW2ldLmZpeGVkICAgID0gZmFsc2U7XFxuICAgICAgICBpZihpPT0xfHxpPT1pbml0aWFsX3BhcnRpY2xlcy0xKXtcXG4gICAgICAgICAgICBwYXJ0aWNsZXNbaV0uaW52X21hc3MgPSAwLjA7XFxuICAgICAgICAgICAgcGFydGljbGVzW2ldLmZpeGVkICAgID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBzcHJpbmdbMF0gPSBtb3VzZSB0byBzZWxlY3RlZFxcbiAgICBzcHJpbmdzWzBdID0gYWRkX3NwcmluZygwLCBzZWxlY3RlZF9wYXJ0aWNsZSwgMS4wLzEwMC4wKTtcXG5cXG4gICAgLy8gbG9hZCByZXN0XFxuICAgIGZvcihpbnQgaT0xO2k8bl9zcHJpbmdzO2krKyl7XFxuICAgICAgICB2ZWM0IGQgPSB0ZXhlbEZldGNoKGlDaGFubmVsMCwgaXZlYzIoaSwxKSwwKTtcXG4gICAgICAgIHNwcmluZ3NbaV0uYSA9IGludChkLngpO1xcbiAgICAgICAgc3ByaW5nc1tpXS5iID0gaW50KGQueSk7XFxuICAgICAgICBzcHJpbmdzW2ldLnJlc3RMZW5ndGggICA9IGQuejtcXG4gICAgICAgIHNwcmluZ3NbaV0uaW52X3N0aWZmbmVzcz0gZC53O1xcbiAgICB9XFxuXFxuICAgIC8vIHBpY2svZHJhZyBsb2dpY1xcbiAgICBpZihpTW91c2Uuej09MS4wKXtcXG4gICAgICAgIGlmKHNlbGVjdGVkX3BhcnRpY2xlPDApe1xcbiAgICAgICAgICAgIHNlbGVjdGVkX3BhcnRpY2xlID0gbmVhcmVzdF9wYXJ0aWNsZShwYXJ0aWNsZXNbMF0ucG9zKTtcXG4gICAgICAgIH1cXG4gICAgfSBlbHNlIHNlbGVjdGVkX3BhcnRpY2xlID0gLTE7XFxuXFxuICAgIGlmKGlNb3VzZS56PT0yLjAgJiYgc2VsZWN0ZWRfcGFydGljbGU+PTApe1xcbiAgICAgICAgLy8gYWRkIGEgbmV3IHNwcmluZyBmcm9tIHNlbGVjdGVkIHRvIGEgbmV3IHBhcnRpY2xlXFxuICAgICAgICBpZihjdXJyZW50X2FkZF9wYXJ0aWNsZTxNQVhfUEFSVElDTEVTKXtcXG4gICAgICAgICAgICBwYXJ0aWNsZXNbY3VycmVudF9hZGRfcGFydGljbGVdLnBvcyAgICAgID0gc2NyZWVuX3RvX3h5KGlNb3VzZS54eSk7XFxuICAgICAgICAgICAgcGFydGljbGVzW2N1cnJlbnRfYWRkX3BhcnRpY2xlXS52ZWwgICAgICA9IHZlYzIoMC4wKTtcXG4gICAgICAgICAgICBwYXJ0aWNsZXNbY3VycmVudF9hZGRfcGFydGljbGVdLmludl9tYXNzID0gMS4wO1xcbiAgICAgICAgICAgIHBhcnRpY2xlc1tjdXJyZW50X2FkZF9wYXJ0aWNsZV0uZml4ZWQgICAgPSBmYWxzZTtcXG4gICAgICAgICAgICBuX3BhcnRpY2xlcyA9IG1heChuX3BhcnRpY2xlcywgY3VycmVudF9hZGRfcGFydGljbGUrMSk7XFxuICAgICAgICAgICAgc3ByaW5nc1tuX3NwcmluZ3MrK10gPSBhZGRfc3ByaW5nKHNlbGVjdGVkX3BhcnRpY2xlLCBjdXJyZW50X2FkZF9wYXJ0aWNsZSwgMS4wLzgwMDAwLjApO1xcbiAgICAgICAgICAgIGN1cnJlbnRfYWRkX3BhcnRpY2xlKys7XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXFxuZmxvYXQgc3ByaW5nX0MoU3ByaW5nIHMpe1xcbiAgICByZXR1cm4gbGVuZ3RoKHBhcnRpY2xlc1tzLmFdLnBvcyAtIHBhcnRpY2xlc1tzLmJdLnBvcykgLSBzLnJlc3RMZW5ndGg7XFxufVxcbnZlYzIgZ3JhZF9DKHZlYzIgYSwgdmVjMiBiKXtcXG4gICAgdmVjMiBkID0gYS1iOyBmbG9hdCBMPWxlbmd0aChkKTtcXG4gICAgcmV0dXJuIChMPDFlLTYpID8gdmVjMigwLjApIDogZC9MO1xcbn1cXG52ZWMyIHNwcmluZ19ncmFkKFNwcmluZyBzLCBpbnQgaWR4KXtcXG4gICAgdmVjMiBnID0gZ3JhZF9DKHBhcnRpY2xlc1tzLmFdLnBvcywgcGFydGljbGVzW3MuYl0ucG9zKTtcXG4gICAgcmV0dXJuIChpZHg9PXMuYSA/ICtnIDogLWcpO1xcbn1cXG52b2lkIHNvbHZlX3NwcmluZyhTcHJpbmcgcywgZmxvYXQgZHQpe1xcbiAgICBmbG9hdCBDID0gc3ByaW5nX0Mocyk7XFxuICAgIHZlYzIgZ2EgPSBzcHJpbmdfZ3JhZChzLCBzLmEpO1xcbiAgICB2ZWMyIGdiID0gc3ByaW5nX2dyYWQocywgcy5iKTtcXG4gICAgZmxvYXQgaW52TWEgPSBwYXJ0aWNsZXNbcy5hXS5pbnZfbWFzcyAqIGRvdChnYSxnYSk7XFxuICAgIGZsb2F0IGludk1iID0gcGFydGljbGVzW3MuYl0uaW52X21hc3MgKiBkb3QoZ2IsZ2IpO1xcbiAgICBmbG9hdCBkZW5vbSA9IGludk1hK2ludk1iICsgcy5pbnZfc3RpZmZuZXNzLyhkdCpkdCk7XFxuICAgIGlmKGRlbm9tPDFlLTYpIHJldHVybjtcXG4gICAgZmxvYXQgzrsgPSAtQy9kZW5vbTtcXG4gICAgcGFydGljbGVzW3MuYV0ucG9zICs9IM67ICogcGFydGljbGVzW3MuYV0uaW52X21hc3MgKiBnYTtcXG4gICAgcGFydGljbGVzW3MuYl0ucG9zICs9IM67ICogcGFydGljbGVzW3MuYl0uaW52X21hc3MgKiBnYjtcXG59XFxuXFxuZmxvYXQgY29sX0ModmVjMiBhLCB2ZWMyIGIpe1xcbiAgICBmbG9hdCBkPWxlbmd0aChhLWIpO1xcbiAgICByZXR1cm4gKGQ8Y29sbGlzaW9uX2Rpc3QpID8gKGQtY29sbGlzaW9uX2Rpc3QpIDogMC4wO1xcbn1cXG52ZWMyIGNvbF9ncmFkKHZlYzIgYSwgdmVjMiBiKXtcXG4gICAgcmV0dXJuIChhPT1iKSA/IHZlYzIoMC4wKSA6IG5vcm1hbGl6ZShhLWIpO1xcbn1cXG52b2lkIHNvbHZlX2NvbGxpc2lvbihpbnQgaSxpbnQgaixmbG9hdCBkdCl7XFxuICAgIHZlYzIgYT1wYXJ0aWNsZXNbaV0ucG9zLCBiPXBhcnRpY2xlc1tqXS5wb3M7XFxuICAgIHZlYzIgZyA9IGNvbF9ncmFkKGEsYik7XFxuICAgIGlmKGxlbmd0aChnKTwxZS02KSByZXR1cm47XFxuICAgIGZsb2F0IEMgPSBjb2xfQyhhLGIpO1xcbiAgICBmbG9hdCBpbnZNaSA9IHBhcnRpY2xlc1tpXS5pbnZfbWFzcyAqIGRvdChnLGcpO1xcbiAgICBmbG9hdCBpbnZNaiA9IHBhcnRpY2xlc1tqXS5pbnZfbWFzcyAqIGRvdChnLGcpO1xcbiAgICBmbG9hdCBkZW5vbSA9IGludk1pK2ludk1qICsgMS4wLzEwMDAuMC8oZHQqZHQpO1xcbiAgICBmbG9hdCDOuyA9IC1DL2Rlbm9tO1xcbiAgICBwYXJ0aWNsZXNbaV0ucG9zICs9IM67ICogcGFydGljbGVzW2ldLmludl9tYXNzICogZztcXG4gICAgcGFydGljbGVzW2pdLnBvcyAtPSDOuyAqIHBhcnRpY2xlc1tqXS5pbnZfbWFzcyAqIGc7XFxufVxcblxcbmZsb2F0IM+GMmQodmVjMiBwKXtcXG4gICAgcmV0dXJuIHAueSAtICgwLjEqc2luKHAueCoyLjAqUEkpIC0gMC41KTtcXG59XFxuZmxvYXQgZ3JvdW5kX0ModmVjMiBwKXtcXG4gICAgZmxvYXQgdiA9IM+GMmQocCk7XFxuICAgIHJldHVybiAodjxncm91bmRfY29sbGlzaW9uX2Rpc3QpID8gKHYtZ3JvdW5kX2NvbGxpc2lvbl9kaXN0KSA6IDAuMDtcXG59XFxudmVjMiBncm91bmRfZ3JhZCh2ZWMyIHApe1xcbiAgICBmbG9hdCBneCA9IC0wLjIqUEkqY29zKDIuMCpQSSpwLngpO1xcbiAgICByZXR1cm4gdmVjMihneCwxLjApO1xcbn1cXG52b2lkIHNvbHZlX2dyb3VuZChpbnQgaSxmbG9hdCBkdCl7XFxuICAgIHZlYzIgcCA9IHBhcnRpY2xlc1tpXS5wb3M7XFxuICAgIHZlYzIgZyA9IGdyb3VuZF9ncmFkKHApO1xcbiAgICBmbG9hdCBDID0gZ3JvdW5kX0MocCk7XFxuICAgIGZsb2F0IGRlbm9tID0gcGFydGljbGVzW2ldLmludl9tYXNzKmRvdChnLGcpICsgMS4wLzEwMDAuMC8oZHQqZHQpO1xcbiAgICBmbG9hdCDOuyA9IC1DL2Rlbm9tO1xcbiAgICBwYXJ0aWNsZXNbaV0ucG9zICs9IM67ICogcGFydGljbGVzW2ldLmludl9tYXNzICogZztcXG59XFxuXFxudm9pZCBzb2x2ZV9hbGwoZmxvYXQgZHQpe1xcbiAgICBpZihpTW91c2Uuej09MS4wKSBzb2x2ZV9zcHJpbmcoc3ByaW5nc1swXSwgZHQpO1xcbiAgICBmb3IoaW50IGk9MTtpPG5fc3ByaW5ncztpKyspIHNvbHZlX3NwcmluZyhzcHJpbmdzW2ldLCBkdCk7XFxuICAgIGZvcihpbnQgaT0xO2k8bl9wYXJ0aWNsZXM7aSsrKXtcXG4gICAgICAgIGZvcihpbnQgaj1pKzE7ajxuX3BhcnRpY2xlcztqKyspIHNvbHZlX2NvbGxpc2lvbihpLGosZHQpO1xcbiAgICB9XFxuICAgIGZvcihpbnQgaT0xO2k8bl9wYXJ0aWNsZXM7aSsrKSBzb2x2ZV9ncm91bmQoaSxkdCk7XFxufVxcblxcbnZvaWQgc2ltdWxhdGUoKXtcXG4gICAgZmxvYXQgZHQgPSBtaW4oaVRpbWVEZWx0YSwwLjAyKSAvIDUuMDtcXG4gICAgZm9yKGludCBzPTA7czw1O3MrKyl7XFxuICAgICAgICBmb3IoaW50IGk9MDtpPG5fcGFydGljbGVzO2krKyl7XFxuICAgICAgICAgICAgaWYoIXBhcnRpY2xlc1tpXS5maXhlZCl7XFxuICAgICAgICAgICAgICAgIHBhcnRpY2xlc1tpXS52ZWwgKz0gZHQqZ3Jhdml0eTtcXG4gICAgICAgICAgICAgICAgcGFydGljbGVzW2ldLnZlbCAqPSBleHAoLWRhbXAqZHQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwYXJ0aWNsZXNbaV0ucG9zX3ByZXYgPSBwYXJ0aWNsZXNbaV0ucG9zO1xcbiAgICAgICAgICAgIHBhcnRpY2xlc1tpXS5wb3MgKz0gZHQgKiBwYXJ0aWNsZXNbaV0udmVsO1xcbiAgICAgICAgfVxcbiAgICAgICAgc29sdmVfYWxsKGR0KTtcXG4gICAgICAgIGZvcihpbnQgaT0wO2k8bl9wYXJ0aWNsZXM7aSsrKXtcXG4gICAgICAgICAgICBpZighcGFydGljbGVzW2ldLmZpeGVkKVxcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXNbaV0udmVsID0gKHBhcnRpY2xlc1tpXS5wb3MgLSBwYXJ0aWNsZXNbaV0ucG9zX3ByZXYpL2R0O1xcbiAgICAgICAgfVxcbiAgICAgICAgcGFydGljbGVzWzBdLnBvcyA9IHNjcmVlbl90b194eShpTW91c2UueHkpOyAvLyBrZWVwIG1vdXNlIGZpeGVkXFxuICAgIH1cXG59XFxuXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gMikgQSAzRCBTREYgU0NFTkUgJiBQSE9ORyBTSEFESU5HIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuLy8gY2Fwc3VsZSBTREYgYmV0d2VlbiBBLEIgd2l0aCByYWRpdXMgclxcbmZsb2F0IHNkQ2Fwc3VsZSh2ZWMzIHAsIHZlYzMgQSwgdmVjMyBCLCBmbG9hdCByKXtcXG4gICAgdmVjMyBwYSA9IHAgLSBBO1xcbiAgICB2ZWMzIGJhID0gQiAtIEE7XFxuICAgIGZsb2F0IGggPSBjbGFtcChkb3QocGEsYmEpL2RvdChiYSxiYSksIDAuMCwgMS4wKTtcXG4gICAgcmV0dXJuIGxlbmd0aChwYSAtIGJhKmgpIC0gcjtcXG59XFxuLy8gc3BoZXJlIFNERlxcbmZsb2F0IHNkU3BoZXJlKHZlYzMgcCwgdmVjMyBDLCBmbG9hdCByKXtcXG4gICAgcmV0dXJuIGxlbmd0aChwLUMpIC0gcjtcXG59XFxuLy8gd2F2eSBncm91bmQgcGxhbmVcXG5mbG9hdCBzZEdyb3VuZCh2ZWMzIHApe1xcbiAgICBmbG9hdCB3ID0gMC4xICogc2luKHAueCoyLjAqUEkpIC0gMC41O1xcbiAgICByZXR1cm4gcC55IC0gdztcXG59XFxuXFxuLy8gc2NlbmUgU0RGOiBncm91bmQg4oiqIGZsdWlkIHNwaGVyZXMg4oiqIHJvcGUgY2Fwc3VsZXNcXG5mbG9hdCBzY2VuZVNERih2ZWMzIHApe1xcbiAgICBmbG9hdCBkID0gc2RHcm91bmQocCk7XFxuXFxuICAgIC8vIGZsdWlkIHBhcnRpY2xlcyBhcyBzcGhlcmVzXFxuICAgIGZvcihpbnQgaT1pbml0aWFsX3BhcnRpY2xlcztpPG5fcGFydGljbGVzO2krKyl7XFxuICAgICAgICB2ZWMzIHBjID0gdmVjMyhwYXJ0aWNsZXNbaV0ucG9zLCAwLjApO1xcbiAgICAgICAgZCA9IG1pbihkLCBzZFNwaGVyZShwLCBwYywgUkFESVVTKSk7XFxuICAgIH1cXG4gICAgLy8gcm9wZSBzcHJpbmdzIGFzIGNhcHN1bGVzXFxuICAgIGZvcihpbnQgaT0xO2k8bl9zcHJpbmdzO2krKyl7XFxuICAgICAgICB2ZWMzIEEgPSB2ZWMzKHBhcnRpY2xlc1tzcHJpbmdzW2ldLmFdLnBvcywgMC4wKTtcXG4gICAgICAgIHZlYzMgQiA9IHZlYzMocGFydGljbGVzW3NwcmluZ3NbaV0uYl0ucG9zLCAwLjApO1xcbiAgICAgICAgZCA9IG1pbihkLCBzZENhcHN1bGUocCwgQSwgQiwgUkFESVVTKjAuNikpO1xcbiAgICB9XFxuICAgIC8vIG1vdXNl4oCTZmlyc3Qgc3ByaW5nIGxpbmtcXG4gICAge1xcbiAgICAgICAgdmVjMyBBID0gdmVjMyhwYXJ0aWNsZXNbMF0ucG9zLDAuMCk7XFxuICAgICAgICB2ZWMzIEIgPSB2ZWMzKHBhcnRpY2xlc1tzZWxlY3RlZF9wYXJ0aWNsZV0ucG9zLDAuMCk7XFxuICAgICAgICBkID0gbWluKGQsIHNkQ2Fwc3VsZShwLCBBLCBCLCBSQURJVVMqMC42KSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGQ7XFxufVxcblxcbi8vIHJheSBkaXJlY3Rpb24gZnJvbSBjYW1lcmFcXG52ZWMzIHJheURpcih2ZWMyIHV2KXtcXG4gICAgdmVjMiBwID0gKHV2IC0gMC41KSoyLjA7XFxuICAgIHAueCAqPSBpUmVzb2x1dGlvbi54L2lSZXNvbHV0aW9uLnk7XFxuICAgIHJldHVybiBub3JtYWxpemUodmVjMyhwLCAtMS4wKSk7XFxufVxcblxcbi8vIHJheSBtYXJjaFxcbnZlYzMgcmF5TWFyY2godmVjMyBybywgdmVjMyByZCl7XFxuICAgIGZsb2F0IHQgPSAwLjA7XFxuICAgIGZvcihpbnQgaT0wO2k8MTI4O2krKyl7XFxuICAgICAgICB2ZWMzIHBvcyA9IHJvICsgcmQgKiB0O1xcbiAgICAgICAgZmxvYXQgZCA9IHNjZW5lU0RGKHBvcyk7XFxuICAgICAgICBpZihkPDAuMDAxKSByZXR1cm4gcG9zO1xcbiAgICAgICAgaWYodD41MC4wKSBicmVhaztcXG4gICAgICAgIHQgKz0gZDtcXG4gICAgfVxcbiAgICByZXR1cm4gdmVjMygwLjAsIC0xLjAsIDAuMCk7IC8vIG1pc3M6IGJlbG93IGdyb3VuZFxcbn1cXG5cXG4vLyBub3JtYWwgdmlhIG51bWVyaWMgZ3JhZGllbnRcXG52ZWMzIGVzdGltYXRlTm9ybWFsKHZlYzMgcCl7XFxuICAgIGZsb2F0IGggPSAwLjAwMDU7XFxuICAgIHJldHVybiBub3JtYWxpemUodmVjMyhcXG4gICAgICAgIHNjZW5lU0RGKHAgKyB2ZWMzKGgsMCwwKSkgLSBzY2VuZVNERihwIC0gdmVjMyhoLDAsMCkpLFxcbiAgICAgICAgc2NlbmVTREYocCArIHZlYzMoMCxoLDApKSAtIHNjZW5lU0RGKHAgLSB2ZWMzKDAsaCwwKSksXFxuICAgICAgICBzY2VuZVNERihwICsgdmVjMygwLDAsaCkpIC0gc2NlbmVTREYocCAtIHZlYzMoMCwwLGgpKVxcbiAgICApKTtcXG59XFxuXFxuLy8gUGhvbmcgc2hhZGluZ1xcbnZlYzMgcGhvbmcodmVjMyBwLCB2ZWMzIHJvLCB2ZWMzIE4pe1xcbiAgICB2ZWMzIGxpZ2h0UG9zID0gdmVjMygyLjAsMi4wLDIuMCk7XFxuICAgIHZlYzMgTCA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIHApO1xcbiAgICB2ZWMzIFYgPSBub3JtYWxpemUocm8gLSBwKTtcXG4gICAgdmVjMyBIID0gbm9ybWFsaXplKEwrVik7XFxuICAgIGZsb2F0IGRpZmYgPSBtYXgoZG90KE4sTCksMC4wKTtcXG4gICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KE4sSCksMC4wKSwgNjQuMCk7XFxuICAgIHZlYzMgYW1iaWVudCA9IHZlYzMoMC4xKTtcXG4gICAgdmVjMyBiYXNlICAgID0gdmVjMygwLjQsMC43LDEuMCk7XFxuICAgIHJldHVybiBhbWJpZW50ICsgZGlmZipiYXNlICsgc3BlYyp2ZWMzKDEuMCk7XFxufVxcblxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbi8vIDMpIE1BSU46IFBBQ0sgU0lNICYgUkVOREVSIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbnZvaWQgbWFpbigpe1xcbiAgICB2ZWMyIHBpeCA9IHZVdiAqIGlSZXNvbHV0aW9uLnh5O1xcbiAgICBpbnQgaSA9IGludChwaXgueCk7XFxuICAgIGludCBqID0gaW50KHBpeC55KTtcXG5cXG4gICAgLy8gLS0tIHJvdyAwOiBwYXJ0aWNsZXMgc3RhdGUgLS0tICBcXG4gICAgaWYoaj09MCl7XFxuICAgICAgICBpZihpPT0wKXtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBmbG9hdChuX3BhcnRpY2xlcyksXFxuICAgICAgICAgICAgICAgIGZsb2F0KG5fc3ByaW5ncyksXFxuICAgICAgICAgICAgICAgIGZsb2F0KHNlbGVjdGVkX3BhcnRpY2xlKSxcXG4gICAgICAgICAgICAgICAgZmxvYXQoY3VycmVudF9hZGRfcGFydGljbGUpXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYoaSA8IG5fcGFydGljbGVzKXtcXG4gICAgICAgICAgICBQYXJ0aWNsZSBQID0gcGFydGljbGVzW2ldO1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoUC5wb3MsIFAudmVsKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsMC4wLDAuMCwxLjApO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIC0tLSByb3cgMTogc3ByaW5ncyBzdGF0ZSAtLS1cXG4gICAgaWYoaj09MSl7XFxuICAgICAgICBpZihpIDwgbl9zcHJpbmdzKXtcXG4gICAgICAgICAgICBTcHJpbmcgcyA9IHNwcmluZ3NbaV07XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZmxvYXQocy5hKSwgZmxvYXQocy5iKSxcXG4gICAgICAgICAgICAgICAgcy5yZXN0TGVuZ3RoLCBzLmludl9zdGlmZm5lc3NcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwwLjAsMC4wLDEuMCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gLS0tIGFsbCBvdGhlciByb3dzOiBkbyBzaW0gKyByZW5kZXIgLS0tXFxuICAgIGlmKGlzX2luaXQoKSl7XFxuICAgICAgICBpbml0X3N0YXRlKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBsb2FkX3N0YXRlKCk7XFxuICAgICAgICBzaW11bGF0ZSgpO1xcbiAgICB9XFxuXFxuICAgIC8vIG1hcCBwaXhlbCB0byBbMCwxXSBpbiB0aGUgcmVuZGVyIHJlZ2lvbiBvZmZzZXQgYnkgMiBzY2FubGluZXNcXG4gICAgZmxvYXQgSCA9IGlSZXNvbHV0aW9uLnkgLSAyLjA7XFxuICAgIHZlYzIgdXYgPSB2ZWMyKFxcbiAgICAgICAgcGl4LnggLyBpUmVzb2x1dGlvbi54LFxcbiAgICAgICAgKHBpeC55IC0gMi4wKSAvIEhcXG4gICAgKTtcXG5cXG4gICAgLy8gY2FtZXJhIHNldHVwXFxuICAgIHZlYzMgcm8gPSB2ZWMzKDAuMCwgMC4wLCA1LjApO1xcbiAgICB2ZWMzIHJkID0gcmF5RGlyKHV2KTtcXG5cXG4gICAgdmVjMyBoaXQgPSByYXlNYXJjaChybywgcmQpO1xcbiAgICB2ZWMzIE4gICA9IGVzdGltYXRlTm9ybWFsKGhpdCk7XFxuICAgIHZlYzMgY29sID0gcGhvbmcoaGl0LCBybywgTik7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLDEuMCk7XFxufVwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A4/fragment_final.glsl\n"));

/***/ })

});