"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(assignment)/assignment/A1a/page",{

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A1a/fragment_water.glsl":
/*!*****************************************************************!*\
  !*** ./src/app/(assignment)/assignment/A1a/fragment_water.glsl ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"/////////////////////////////////////////////////////\\n//// CS 8803/4803 CGAI: Computer Graphics in AI Era\\n//// Assignment 1A: SDF and Ray Marching\\n/////////////////////////////////////////////////////\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n              //// set default precision of float variables to high precision\\n\\nvarying vec2 vUv;                   //// screen uv coordinates (varying, from vertex shader)\\nuniform vec2 iResolution;           //// screen resolution (uniform, from CPU)\\nuniform float iTime;                //// time elapsed (uniform, from CPU)\\n\\n#define ITERATIONS_NORMAL 36.0\\n\\nconst vec3 CAM_POS = vec3(-0.35, 1.0, -3.0); //// camera position\\n\\n// Global variables\\nstruct HitID {\\n    float dist;\\n    int id;\\n};\\nHitID hit_id = HitID(2000.0, -1);\\n\\n/////////////////////////////////////////////////////\\n//// sdf functions\\n/////////////////////////////////////////////////////\\n\\n/////////////////////////////////////////////////////\\n//// Step 1: sdf primitives\\n//// You are asked to implement sdf primitive functions for sphere, plane, and box.\\n//// In each function, you will calculate the sdf value based on the function arguments.\\n/////////////////////////////////////////////////////\\n\\n//// sphere: p - query point; c - sphere center; r - sphere radius\\nfloat sdfSphere(vec3 p, vec3 c, float r)\\n{\\n    //// your implementation starts\\n    \\n    return length(p - c) - r;\\n    \\n    //// your implementation ends\\n}\\n\\n//// plane: p - query point; h - height\\nfloat sdfPlane(vec3 p, float h)\\n{\\n    //// your implementation starts\\n    \\n    return p.y - h;\\n    \\n    //// your implementation ends\\n}\\n\\n//// box: p - query point; c - box center; b - box half size (i.e., the box size is (2*b.x, 2*b.y, 2*b.z))\\nfloat sdfBox(vec3 p, vec3 c, vec3 b)\\n{\\n    //// your implementation starts\\n\\n    vec3 d = abs(p - c) - b;\\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\\n    \\n    //// your implementation ends\\n}\\n\\n/////////////////////////////////////////////////////\\n//// boolean operations\\n/////////////////////////////////////////////////////\\n\\n/////////////////////////////////////////////////////\\n//// Step 2: sdf boolean operations\\n//// You are asked to implement sdf boolean operations for intersection, union, and subtraction.\\n/////////////////////////////////////////////////////\\n\\nfloat sdfIntersection(float s1, float s2)\\n{\\n    //// your implementation starts\\n    \\n    return max(s1, s2);\\n\\n    //// your implementation ends\\n}\\n\\nfloat sdfUnion(float s1, float s2)\\n{\\n    //// your implementation starts\\n    \\n    return min(s1, s2);\\n\\n    //// your implementation ends\\n}\\n\\nfloat sdfSubtraction(float s1, float s2)\\n{\\n    //// your implementation starts\\n    \\n    return max(s1, -s2);\\n\\n    //// your implementation ends\\n}\\n\\n/////////////////////////////////////////////////////\\n//// sdf calculation\\n/////////////////////////////////////////////////////\\n\\n/////////////////////////////////////////////////////\\n//// Step 3: scene sdf\\n//// You are asked to use the implemented sdf boolean operations to draw the following objects in the scene by calculating their CSG operations.\\n/////////////////////////////////////////////////////\\n\\n//// sdf: p - query point\\nfloat sdf(vec3 p)\\n{\\n    float s = 0.;\\n\\n    //// 1st object: plane\\n    float plane1_h = -0.1;\\n    \\n    //// 2nd object: sphere\\n    vec3 sphere1_c = vec3(-2.0, 1.0, 0.0);\\n    float sphere1_r = 0.25;\\n\\n    //// 3rd object: box\\n    vec3 box1_c = vec3(-1.0, 1.0, 0.0);\\n    vec3 box1_b = vec3(0.2, 0.2, 0.2);\\n\\n    //// 4th object: box-sphere subtraction\\n    vec3 box2_c = vec3(0.0, 1.0, 0.0);\\n    vec3 box2_b = vec3(0.3, 0.3, 0.3);\\n\\n    vec3 sphere2_c = vec3(0.0, 1.0, 0.0);\\n    float sphere2_r = 0.4;\\n\\n    //// 5th object: sphere-sphere intersection\\n    vec3 sphere3_c = vec3(1.0, 1.0, 0.0);\\n    float sphere3_r = 0.4;\\n\\n    vec3 sphere4_c = vec3(1.3, 1.0, 0.0);\\n    float sphere4_r = 0.3;\\n\\n    //// calculate the sdf based on all objects in the scene\\n    \\n    //// your implementation starts\\n\\n    // Calculate the SDF for each 5 objects\\n    float s1 = sdfPlane(p, plane1_h);\\n\\n    float s2 = sdfSphere(p, sphere1_c, sphere1_r);\\n\\n    float s3 = sdfBox(p, box1_c, box1_b);\\n\\n    float s4_1 = sdfBox(p, box2_c, box2_b);\\n    float s4_2 = sdfSphere(p, sphere2_c, sphere2_r);\\n    float s4 = sdfSubtraction(s4_1, s4_2);\\n\\n    float s5_1 = sdfSphere(p, sphere3_c, sphere3_r);\\n    float s5_2 = sdfSphere(p, sphere4_c, sphere4_r);\\n    float s5 = sdfIntersection(s5_1, s5_2);\\n\\n    // Combine the SDF for all objects\\n    float objects[] = float[](\\n        s1, \\n        s2, \\n        s3, \\n        s4, \\n        s5);\\n    int object_ids[] = int[](\\n        1, \\n        2, \\n        3, \\n        4, \\n        5);\\n    s = 1000.0; // set a large initial distance for union\\n    for (int i = 0; i < objects.length(); i++) {\\n        s = sdfUnion(s, objects[i]);\\n        if (s < hit_id.dist) {\\n            hit_id.dist = s;\\n            hit_id.id = object_ids[i]; // Record object hit\\n        } \\n    }\\n\\n    //// your implementation ends\\n\\n    return s;\\n}\\n\\n/////////////////////////////////////////////////////\\n//// ray marching\\n/////////////////////////////////////////////////////\\n\\n/////////////////////////////////////////////////////\\n//// Step 4: ray marching\\n//// You are asked to implement the ray marching algorithm within the following for-loop.\\n/////////////////////////////////////////////////////\\n\\n//// ray marching: origin - ray origin; dir - ray direction \\nfloat rayMarching(vec3 origin, vec3 dir)\\n{\\n    float s = 0.0; // distance\\n    for(int i = 0; i < 100; i++)\\n    {\\n        //// your implementation starts\\n        vec3 p = origin + dir * s;\\n        float dist = sdf(p); // sdf value in p\\n        s += dist; // update the distance\\n        if (s > 100.0 || dist < 0.001) {\\n            break;\\n        }\\n        //// your implementation ends\\n    }\\n    \\n    return s;\\n}\\n\\n/////////////////////////////////////////////////////\\n//// normal calculation\\n/////////////////////////////////////////////////////\\n\\n/////////////////////////////////////////////////////\\n//// Step 5: normal calculation\\n//// You are asked to calculate the sdf normal based on finite difference.\\n/////////////////////////////////////////////////////\\n\\n//// normal: p - query point\\nvec3 normal(vec3 p)\\n{\\n    float s = sdf(p);          //// sdf value in p\\n    float dx = 0.01;           //// step size for finite difference\\n\\n    //// your implementation starts\\n    \\n    return normalize(vec3(\\n        sdf(p + vec3(dx, 0.0, 0.0)) - sdf(p - vec3(dx, 0.0, 0.0)), // dsx\\n        sdf(p + vec3(0.0, dx, 0.0)) - sdf(p - vec3(0.0, dx, 0.0)), // dsy\\n        sdf(p + vec3(0.0, 0.0, dx)) - sdf(p - vec3(0.0, 0.0, dx))  // dsz\\n    ));\\n\\n    // your implementation ends\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Phong shading\\n/////////////////////////////////////////////////////\\n\\n/////////////////////////////////////////////////////\\n//// Step 6: lighting and coloring\\n//// You are asked to specify the color for each object in the scene.\\n//// Each object must have a separate color without mixing.\\n//// Notice that we have implemented the default Phong shading model for you.\\n/////////////////////////////////////////////////////\\n\\nvec3 phong_shading(vec3 p, vec3 n)\\n{\\n    //// background\\n    if(p.z > 10.0){\\n        return vec3(0.9, 0.6, 0.2);\\n    }\\n\\n    //// phong shading\\n    vec3 lightPos = vec3(4.*sin(iTime), 4., 4.*cos(iTime));  \\n    vec3 l = normalize(lightPos - p);               \\n    float amb = 0.1;\\n    float dif = max(dot(n, l), 0.) * 0.7;\\n    vec3 eye = CAM_POS;\\n    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.9;\\n\\n    vec3 sunDir = vec3(0, 1, -1);\\n    float sunDif = max(dot(n, sunDir), 0.) * 0.2;\\n\\n    //// your implementation for coloring starts\\n    vec3 color = vec3(1.0, 1.0, 1.0);\\n    if (hit_id.id == 1) {\\n        color = vec3(0.13, 0.72, 0.0);\\n    } else if (hit_id.id == 2) {\\n        color = vec3(1.0, 0.0, 0.0);\\n    } else if (hit_id.id == 3) {\\n        color = vec3(0.65, 1.0, 0.0);\\n    } else if (hit_id.id == 4) {\\n        color = vec3(0.5, 0.0, 1.0);\\n    } else if (hit_id.id == 5) {\\n        color = vec3(0.0, 0.52, 1.0);\\n    }\\n    //// your implementation for coloring ends\\n\\n    //// shadow\\n    float s = rayMarching(p + n * 0.02, l);\\n    if(s < length(lightPos - p)) dif *= .2; // shadow\\n\\n    return (amb + dif + spec + sunDif) * color;\\n}\\n\\n/////////////////////////////////////////////////////\\n//// Step 7: creative expression\\n//// You will create your customized sdf scene with new primitives and CSG operations in the sdf2 function.\\n//// Call sdf2 in your ray marching function to render your customized scene.\\n/////////////////////////////////////////////////////\\n\\n/**\\n * Return a float value between 0.0(0s) and 1.0(10s) that represents a 10s cycle\\n * Used for time-based animations\\n */\\nfloat getSyncedTimeCycle() \\n{\\n    return float(int(iTime * 60.0) % 600) / 600.0; // 10s cycle\\n}\\n\\n/**\\n * SDF for a curvy ground of sin and cos waves\\n * With larger waves for hills and smaller waves for texture\\n * @param p: query point\\n * @param h: height of the ground\\n * @return SDF value\\n */\\nfloat sdfCurvyGround(vec3 p, float h) \\n{\\n    p -= vec3(0.0, 0.0, 0.0);\\n    float wave = 0.3 * sin(0.5 * p.x) * cos(1.0 * p.z); // Hills and Valleys\\n    float texture = 0.02 * sin(40.0 * p.x) * sin(80.0 * p.z); // Texture\\n    return p.y - (h + wave + texture);\\n}\\n\\nfloat sdfUnionSmooth(float s1, float s2, float k)\\n{\\n    return -k * log(exp(-s1 / k) + exp(-s2 / k));\\n}\\n\\nfloat sdfSubtractionSmooth(float s1, float s2, float k)\\n{\\n    return -sdfUnionSmooth(-s1, s2, k);\\n}\\n\\nfloat sdfEllipsoid(vec3 p, vec3 c, vec3 r)\\n{\\n    p = p - c;\\n    float k0 = length(p / r);\\n    float k1 = length(p / (r * r));\\n    return k0 * (k0 - 1.0) / k1;\\n}\\n\\n/**\\n * Rotate a point around a center point with given angles\\n * @param p: point to rotate\\n * @param c: center point\\n * @param angles: rotation angles in degrees\\n * @return rotated point\\n */\\nvec3 rotateXYZ(vec3 p, vec3 c, vec3 angles)\\n{   \\n    p -= c; // Translate to origin\\n    angles = radians(angles);\\n    float c1 = cos(angles.x), s1 = sin(angles.x);\\n    float c2 = cos(angles.y), s2 = sin(angles.y);\\n    float c3 = cos(angles.z), s3 = sin(angles.z);\\n\\n    mat3 m = mat3(\\n        c1 * c3 + s1 * s2 * s3, c2 * s3, -s1 * c3 + c1 * s2 * s3,\\n        -c1 * s3 + s1 * s2 * c3, c2 * c3, s1 * s3 + c1 * s2 * c3,\\n        s1 * c2, -s2, c1 * c2\\n    );\\n\\n    return m * p + c; // Rotate and translate back\\n}\\n\\nfloat sdfBorb(vec3 p, vec3 c, float angle, bool birbHair)\\n{\\n    \\n    // Rotate around the Y-axis\\n    float birb_move1 = 3.0 * sin(iTime * 3.0);\\n    float birb_move2 = 3.0 * cos(iTime * 1.0);\\n    vec3 local_p = rotateXYZ(p, c, vec3(angle, birb_move1, birb_move2));\\n\\n    // Define the borb components\\n    float r = 0.2;\\n    vec3 head_c  = c + r * vec3(-0.1, 1.5, 0.0);\\n    vec3 body_c  = c + r * vec3(0.0, 0.0, 0.0);\\n    vec3 tail_c  = c + r * vec3(1.5, -0.3, 0.0);\\n    vec3 wingL_c = c + r * vec3(0.0, 0.1, -1.0);\\n    vec3 wingR_c = c + r * vec3(0.0, 0.1, 1.0);\\n    vec3 peak_c  = c + r * vec3(-1.2, 1.4, 0.0);\\n    vec3 eyeL_c  = c + r * vec3(-0.7, 1.6, -0.95);\\n    vec3 eyeR_c  = c + r * vec3(-0.7, 1.6, 0.95);\\n    vec3 hair1_c = c + r * vec3(-0.5, 2.6, 0.0);\\n    vec3 hair2_c = c + r * vec3(-0.45, 2.7, -0.2);\\n    vec3 hair3_c = c + r * vec3(-0.45, 2.7, 0.2);\\n\\n    // Compute SDF for each part\\n    float head = sdfSphere(local_p, head_c, 0.9 * r);\\n    float body = sdfSphere(local_p, body_c, 1.3 * r);\\n    float tail = sdfEllipsoid(local_p, tail_c, vec3(1.2 * r, 0.6 * r, 0.6 * r));\\n    vec3 local_p_wing = rotateXYZ(local_p, wingL_c, vec3(0.0, 0.0, -20.0));\\n    float wingL = sdfEllipsoid(local_p_wing, wingL_c, vec3(0.6 * r, 1.0 * r, 1.0 * r));\\n    float wingR = sdfEllipsoid(local_p_wing, wingR_c, vec3(0.6 * r, 1.0 * r, 1.0 * r));\\n    float peak = sdfEllipsoid(local_p, peak_c, vec3(0.25 * r, 0.4 * r, 0.2 * r));\\n    float eyeL = sdfSphere(local_p, eyeL_c, 0.15 * r);\\n    float eyeR = sdfSphere(local_p, eyeR_c, 0.15 * r);\\n\\n    vec3 local_p_hair = rotateXYZ(local_p, hair1_c, vec3(0.0, 0.0, 30.0));\\n    float hair1 = sdfEllipsoid(local_p_hair, hair1_c, vec3(0.08, 0.3, 0.2) * r * 1.7);\\n    local_p_hair = rotateXYZ(local_p, hair1_c, vec3(0.0, 45.0, 30.0));\\n    float hair2 = sdfEllipsoid(local_p_hair, hair2_c, vec3(0.08, 0.3, 0.2) * r * 1.7);\\n    local_p_hair = rotateXYZ(local_p, hair1_c, vec3(0.0, -45.0, 30.0));\\n    float hair3 = sdfEllipsoid(local_p_hair, hair3_c, vec3(0.08, 0.3, 0.2) * r * 1.7);\\n\\n    // Combine the parts smoothly\\n    body = sdfUnionSmooth(sdfUnionSmooth(head, body, .1), tail, .1);\\n    float wings = sdfUnion(wingL, wingR);\\n    body = sdfUnion(body, peak);\\n    body = sdfSubtraction(body, eyeL);\\n    body = sdfSubtraction(body, eyeR);\\n    \\n    if (birbHair) {\\n        float hair = sdfUnion(sdfUnion(hair1, hair2), hair3);\\n        body = sdfUnionSmooth(body, hair, .01);\\n    }   \\n    return sdfUnion(body, wings);\\n}\\n\\nfloat sdfCloud(vec3 p, vec3 c)\\n{\\n    float r = 0.8;\\n    float space = 0.8;\\n    float s1 = sdfSphere(p, c, r);\\n    float s2 = sdfSphere(p, c + r * vec3(1, 1.4, 0.0) * space, r);\\n    float s3 = sdfSphere(p, c + r * vec3(2, 0.0, 0.0) * space, r);\\n    float s4 = sdfSphere(p, c + r * vec3(3, 1.4, 0.0) * space, r);\\n    float s5 = sdfSphere(p, c + r * vec3(4, 0.0, 0.0) * space, r);\\n    // return sdfUnion(sdfUnion(sdfUnion(sdfUnion(s1, s2), s3), s4), s5);\\n    return sdfUnionSmooth(sdfUnionSmooth(sdfUnionSmooth(sdfUnionSmooth(s1, s2, 0.1), s3, 0.1), s4, 0.1), s5, 0.1);\\n}\\n\\nvec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\\n    float x = dot(direction, position) * frequency + timeshift;\\n    float wave = exp(sin(x) - 1.0);\\n    float dx = wave * cos(x);\\n    return vec2(wave, -dx);\\n}\\n\\nfloat getwaves(vec2 position, int iterations) {\\n    float wavePhaseShift = length(position) * 0.1;\\n    float iter = 0.0;\\n    float frequency = 1.0;\\n    float timeMultiplier = 2.0;\\n    float weight = 1.0;\\n    float sumOfValues = 0.0;\\n    float sumOfWeights = 0.0;\\n    for(int i=0; i < iterations; i++) {\\n        vec2 p = vec2(sin(iter), cos(iter));\\n        vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);\\n        position += p * res.y * weight * 0.38; // DRAG_MULT 可自定义\\n        sumOfValues += res.x * weight;\\n        sumOfWeights += weight;\\n        weight = mix(weight, 0.0, 0.2);\\n        frequency *= 1.18;\\n        timeMultiplier *= 1.07;\\n        iter += 1232.399963;\\n    }\\n    return sumOfValues / sumOfWeights;\\n}\\n\\nfloat sdfRiver(vec3 p)\\n{\\n    float riverbody = sdfBox(p, vec3(0.0, -0.65, 0.0), vec3(2.0, 0.1, 100.0));\\n    // float t = getSyncedTimeCycle();\\n    // // float wave = 0.0015 * cos(8.0 * p.z - t * 15.0); // Curvy wave effect\\n    float wave = getwaves(p.xy, 36)*0.05; \\n    return riverbody + wave;\\n}\\n\\n//// sdf2: p - query point\\nfloat sdf2(vec3 p, bool record_hit)\\n{\\n    float s = 0.;\\n\\n    // Calculate the SDF for each 5 objects\\n    float ground = sdfCurvyGround(p, -0.1);\\n    float mountain1 = sdfSphere(p, vec3(-5.0, -1.0, 20.0), 2.0);\\n    float mountain2 = sdfSphere(p, vec3(-10.0, -1.5, 30.0), 4.0);\\n    float mountain3 = sdfSphere(p, vec3(-15.0, -2.0, 25.0), 6.0);\\n    float mountain4 = sdfSphere(p, vec3(-7.0, -1.0, 15.0), 2.0);\\n    float mountain5 = sdfSphere(p, vec3(10.0, -1.0, 20.0), 2.0);\\n    float mountain6 = sdfSphere(p, vec3(13.0, -2.0, 15.0), 4.0);\\n    ground = sdfUnionSmooth(ground, mountain1, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain2, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain3, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain4, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain5, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain6, 0.5);\\n\\n    // change p for riverbed with respect to p.z\\n    vec3 riverbed_p = p + vec3(sin(p.z * 0.2), 0.0, 0.0);\\n    float riverbed = sdfBox(riverbed_p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.5, 100.0));\\n    ground = sdfSubtractionSmooth(ground, riverbed, 0.5);\\n    float riverbody = sdfRiver(p);\\n\\n    // float birb_move = 0.03 * sin(iTime / 2.0);\\n    float birb_move = getwaves(p.xz, ITERATIONS_NORMAL) * 0.1;\\n    float brib1 = sdfBorb(p, vec3(0.5, -0.4 - 0.2 + birb_move, -0.65 + 1.), -80.0, true);\\n    float brib2 = sdfBorb(p, vec3(-0.2, -0.3 - 0.2 + birb_move, 0.0 + 1.), 160.0, true);\\n    float brib3 = sdfBorb(p, vec3(0.6, -0.3 - 0.2 + birb_move, 0.5 + 1.), 40.0 , true);\\n\\n    float background = sdfBox(p, vec3(0.0, 0.0, 50.0), vec3(100.0, 100.0, 1.0));\\n\\n    // float sun_move = float(int(iTime * 60.0) % 600) / 240.0;\\n    float sun_move = getSyncedTimeCycle() * 3.0;\\n    float sun = sdfSphere(p, vec3(1.0, sun_move, 50.0), 2.5);\\n    \\n    float cloud_move = 0.2 * sin(iTime / 1.0);\\n    float cloud1 = sdfCloud(p, vec3(-10.0, 10.0, 20.0) + vec3(0.0, cloud_move, 0.0));\\n    float cloud2 = sdfCloud(p, vec3(-15.0, 4.0, 15.0) + vec3(0.0, -cloud_move, 0.0));\\n    float cloud3 = sdfCloud(p, vec3(12.0, 5.0, 17.0) + vec3(0.0, cloud_move, 0.0));\\n    float cloud4 = sdfCloud(p, vec3(3.0, 10.0, 20.0) + vec3(0.0, -cloud_move, 0.0));\\n    float cloud5 = sdfCloud(p, vec3(8.0, 3.0, 15.0) + vec3(0.0, cloud_move, 0.0));\\n    float cloud6 = sdfCloud(p, vec3(10.0, 7.0, 30.0) + vec3(0.0, -cloud_move, 0.0));\\n    float cloud7 = sdfCloud(p, vec3(-3.0, 8.0, 40.0) + vec3(0.0, cloud_move, 0.0));\\n\\n    // Combine the SDF for all objects\\n    float objects[] = float[](\\n        ground,\\n        brib1,\\n        brib2, \\n        brib3,\\n        background,\\n        sun,\\n        cloud1, cloud2, cloud3, cloud4, cloud5, cloud6, cloud7,\\n        riverbody\\n    );\\n    // Assign object ids for coloring\\n    int object_ids[] = int[](\\n        1,\\n        2,\\n        3, \\n        4,\\n        5,\\n        6,\\n        7, 7, 7, 7, 7, 7, 7,\\n        8\\n    );\\n    s = 1000.0; // set a large initial distance for union\\n    for (int i = 0; i < objects.length(); i++) {\\n        s = sdfUnion(s, objects[i]);\\n        // Record the closest object hit\\n        if (record_hit && s < hit_id.dist) {\\n            hit_id.dist = s;\\n            hit_id.id = object_ids[i];\\n        }\\n    }\\n\\n    return s;\\n}\\n\\n/** \\n * Overload sdf2 without hit_id update\\n * E.g. we don't need to know what the object is in normal calculation\\n */\\nfloat sdf2(vec3 p)\\n{\\n    bool record_hit = true; // TODO: Should be false,\\n                            // but if I disable hit_id in normal calculation, \\n                            // there will be artifacts in reflection... Don't know why yet\\n    return sdf2(p, record_hit);\\n}\\n\\n//// ray marching: origin - ray origin; dir - ray direction \\nfloat rayMarching2(vec3 origin, vec3 dir)\\n{\\n    float s = 0.0; // distance\\n    for(int i = 0; i < 1000; i++)\\n    {\\n        vec3 p = origin + dir * s;\\n        float dist = sdf2(p, true); // sdf value in p\\n        s += dist; // update the distance\\n        if (s > 200.0 || abs(dist) < 0.0001) {\\n            break;\\n        }\\n    }\\n    \\n    return s;\\n}\\n\\n/**\\n * Normal calculation for SDF2 Scene\\n * @param p: intersection point query\\n * @return norm: normal at the intersection point\\n */\\nvec3 normal2(vec3 p)\\n{\\n    // float s = sdf2(p); // sdf value in p\\n    // float dx = 0.011; // Can't get smaller than this.. \\n    //                   // 0.010 will produce wired artifacts in reflection... Don't know why yet\\n\\n    // vec3 norm = vec3(\\n    //     sdf2(p + vec3(dx, 0.0, 0.0)) - s, // dsx\\n    //     sdf2(p + vec3(0.0, dx, 0.0)) - s, // dsy\\n    //     sdf2(p + vec3(0.0, 0.0, dx)) - s  // dsz\\n    // );\\n\\n    // if (hit_id.id == 8) { // River\\n    //     float e = 0.01;\\n    //     vec2 ex = vec2(e, 0.0);\\n    //     float H = getwaves(p.xz, int(ITERATIONS_WAVE_NORMAL));\\n    //     vec3 a = vec3(p.x, H, p.z);\\n    //     vec3 b = vec3(p.x - e, getwaves(p.xz - ex.xy, int(ITERATIONS_WAVE_NORMAL)), p.z);\\n    //     vec3 c = vec3(p.x, getwaves(p.xz + ex.yx, int(ITERATIONS_WAVE_NORMAL)), p.z + e);\\n    //     return normalize(cross(a - b, a - c));\\n    // } else {\\n    //     float s = sdf2(p);\\n    //     vec3 n = vec3(\\n    //         sdf2(p + vec3(dx, 0.0, 0.0)) - s,\\n    //         sdf2(p + vec3(0.0, dx, 0.0)) - s,\\n    //         sdf2(p + vec3(0.0, 0.0, dx)) - s\\n    //     );\\n    //     return normalize(n);\\n    // }\\n    // return normalize(norm);\\n    float s = sdf2(p);\\n    float dx = 0.011;\\n\\n    if (hit_id.id == 8) { // River\\n        float e = 0.01;\\n        vec2 ex = vec2(e, 0.0);\\n        float H = getwaves(p.xz, int(ITERATIONS_NORMAL));\\n        vec3 a = vec3(p.x, H, p.z);\\n        vec3 b = vec3(p.x - e, getwaves(p.xz - ex.xy, int(ITERATIONS_NORMAL)), p.z);\\n        vec3 c = vec3(p.x, getwaves(p.xz + ex.yx, int(ITERATIONS_NORMAL)), p.z + e);\\n        return normalize(cross(a - b, a - c));\\n    } else {\\n        \\n        vec3 n = vec3(\\n            sdf2(p + vec3(dx, 0.0, 0.0)) - s,\\n            sdf2(p + vec3(0.0, dx, 0.0)) - s,\\n            sdf2(p + vec3(0.0, 0.0, dx)) - s\\n        );\\n        return normalize(n);\\n    }\\n}\\n\\n/**\\n * A Copy of phong_shading2 for handling reflection.\\n * Because GLSL does not support recursive function calls.\\n * This is with further reflection part removed because we just need one bounce.\\n */\\nvec3 phong_shading_reflection(vec3 p, vec3 n, vec3 ray_dir, vec3 origin)\\n{\\n    //// phong shading\\n    float t = getSyncedTimeCycle() * 3.0;\\n    float brightness_scale = 0.6 + 0.20 * t; // Sun rise simulation\\n    vec3 lightPos = vec3(1.0, t + 5.0, 30.0);\\n    vec3 light_color = vec3(0.82, 0.67, 0.58) * 1.2;\\n    vec3 l = normalize(lightPos - p);               \\n    float amb = 0.3;\\n    float dif = max(dot(n, l), 0.) * 0.6;\\n    vec3 eye = origin;\\n    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.7;\\n\\n    vec3 sunDir = vec3(0, 1, -1);\\n    float sunDif = max(dot(n, sunDir), 0.) * 0.2;\\n\\n    //// Coloring\\n    float birb_brightness = 1.2;\\n    vec3 color = vec3(1.0, 1.0, 1.0);\\n\\n    switch (hit_id.id) {\\n        case 1: // Ground\\n            color = vec3(1.0) * 1.1;\\n            break;\\n        case 2: // Birb 1\\n            color = vec3(1.0, 0.89, 0.97) * birb_brightness;\\n            break;\\n        case 3: // Birb 2\\n            color = vec3(1.0, 0.61, 0.78) * birb_brightness;\\n            break;\\n        case 4: // Birb 3\\n            color = vec3(0.99, 0.79, 0.68) * birb_brightness;\\n            break;\\n        case 5: // Background Sky\\n            vec3 color1 = vec3(0.77, 0.67, 0.53);\\n            vec3 color2 = vec3(1.0, 0.25, 0.98);\\n            color = mix(color1, color2, (p.y + 5.0) / 100.0) * brightness_scale;\\n            return color;\\n        case 6: // Sun\\n            color = vec3(1.0, 0.29, 0.09);\\n            return color;\\n        case 7: // Cloud\\n            color = vec3(1.0);\\n            return (amb + sunDif + 0.2) * color * light_color * brightness_scale;\\n        case 8: // River\\n            color = vec3(0.79, 0.89, 1.0);\\n            break;\\n\\n        default: // Unexpected hit_id values\\n            color = vec3(0.0, 0.18, 1.0); // Blue for debugging reflection\\n            return color;\\n    }\\n\\n    //// shadow\\n    float s = rayMarching2(p + n * 0.02, l);\\n    if(s < length(lightPos - p)) dif *= .2; // shadow\\n\\n    //// Balance the color of the scene\\n    float fog = 1.0 - exp(-0.03 * p.z);\\n    vec3 fog_color = vec3(0.5);\\n    color = mix(color, fog_color, fog);\\n\\n    return (amb + dif + spec + sunDif) * brightness_scale * color * light_color;\\n}\\n\\n/**\\n * Phong Shading for SDF2 Scene\\n * @param p: intersection point\\n * @param n: normal at the intersection point\\n * @param ray_dir: ray direction\\n * @param origin: camera position\\n * @return color: phong shading color\\n *\\n * Note: Any changes to this function should be copied to phong_shading_reflection\\n */\\nvec3 phong_shading2(vec3 p, vec3 n, vec3 ray_dir, vec3 origin)\\n{\\n    //// phong shading\\n    float t = getSyncedTimeCycle() * 3.0;\\n    float brightness_scale = 0.6 + 0.20 * t; // Sun rise simulation\\n    vec3 lightPos = vec3(1.0, t + 5.0, 30.0);\\n    vec3 light_color = vec3(0.82, 0.67, 0.58) * 1.2;\\n    vec3 l = normalize(lightPos - p);               \\n    float amb = 0.3;\\n    float dif = max(dot(n, l), 0.) * 0.6;\\n    vec3 eye = origin;\\n    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.7;\\n\\n    vec3 sunDir = vec3(0, 1, -1);\\n    float sunDif = max(dot(n, sunDir), 0.) * 0.2;\\n\\n    //// Coloring\\n    float birb_brightness = 1.2;\\n    vec3 color = vec3(1.0, 1.0, 1.0);\\n\\n    switch (hit_id.id) {\\n        case 1: // Ground\\n            color = vec3(1.0) * 1.1;\\n            break;\\n        case 2: // Birb 1\\n            color = vec3(1.0, 0.89, 0.97) * birb_brightness;\\n            break;\\n        case 3: // Birb 2\\n            color = vec3(1.0, 0.61, 0.78) * birb_brightness;\\n            break;\\n        case 4: // Birb 3\\n            color = vec3(0.99, 0.79, 0.68) * birb_brightness;\\n            break;\\n        case 5: // Background Sky\\n            vec3 color1 = vec3(0.77, 0.67, 0.53);\\n            vec3 color2 = vec3(1.0, 0.25, 0.98);\\n            color = mix(color1, color2, (p.y + 5.0) / 100.0) * brightness_scale;\\n            return color;\\n        case 6: // Sun\\n            color = vec3(1.0, 0.29, 0.09);\\n            return color;\\n        case 7: // Cloud\\n            color = vec3(1.0);\\n            return (amb + sunDif + 0.2) * color * light_color * brightness_scale;\\n        case 8: // River\\n            vec3 water_color = vec3(0.79, 0.89, 1.0);\\n            // Reflection on water\\n            vec3 reflect_dir = reflect(ray_dir, n);\\n            float reflect_s = rayMarching2(p + n * 0.01, reflect_dir);\\n            // Get the reflection color\\n            vec3 reflect_p = p + reflect_dir * reflect_s;\\n            vec3 reflect_n = normal2(reflect_p);\\n            vec3 reflect_color = phong_shading_reflection(reflect_p, reflect_n, reflect_dir, p);\\n            return reflect_color * water_color * 0.9;\\n            // color = vec3(0.99, 0.79, 0.68);\\n            // break;\\n\\n        default: // Unexpected hit_id values\\n            color = vec3(0.13, 1.0, 0.0); // Green for debugging\\n            return color;\\n    }\\n\\n    //// shadow\\n    float s = rayMarching2(p + n * 0.02, l);\\n    if(s < length(lightPos - p)) dif *= .2;\\n\\n    //// Balance the color of the scene\\n    float fog = 1.0 - exp(-0.03 * p.z);\\n    vec3 fog_color = vec3(0.5);\\n    color = mix(color, fog_color, fog);\\n\\n    return (amb + dif + spec + sunDif) * brightness_scale * color * light_color;\\n}\\n\\n/////////////////////////////////////////////////////\\n//// main function\\n/////////////////////////////////////////////////////\\n\\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord)\\n{\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;           //// screen uv\\n    \\n    float cam_move = getSyncedTimeCycle();\\n    vec3 origin = CAM_POS + vec3(0.0, -0.5, 1.5) \\n                          + vec3(0.0, cam_move * 0.3, -cam_move * 2.0);          //// camera position \\n    // vec3 origin = CAM_POS;                                                 //// camera position\\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));                  //// camera direction\\n    float s = rayMarching2(origin, dir);                         //// ray marching\\n    vec3 p = origin + dir * s;                                               //// ray-sdf intersection\\n    vec3 n = normal2(p);                                                  //// sdf normal\\n    vec3 color = phong_shading2(p, n, dir, origin);    //// phong shading\\n    fragColor = vec4(color, 1.);                                     //// fragment color\\n}\\n\\nvoid mainImage1(out vec4 fragColor, in vec2 fragCoord)\\n{\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;           //// screen uv\\n\\n    vec3 origin = CAM_POS;                                                 //// camera position\\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));                  //// camera direction\\n    float s = rayMarching(origin, dir);                         //// ray marching\\n    vec3 p = origin + dir * s;                                               //// ray-sdf intersection\\n    vec3 n = normal(p);                                                  //// sdf normal\\n    vec3 color = phong_shading(p, n);    //// phong shading\\n    fragColor = vec4(color, 1.);                                     //// fragment color\\n}\\n\\nvoid main() \\n{\\n    ////--- Uncomment the following line to render the Base SDF1 scene ---////\\n    // mainImage1(gl_FragColor, gl_FragCoord.xy);\\n\\n    ////--- Uncomment the following line to render the Custom SDF2 scene ---////\\n    mainImage2(gl_FragColor, gl_FragCoord.xy);\\n}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTFhL2ZyYWdtZW50X3dhdGVyLmdsc2wiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLHNPQUFzTywwSUFBMEksOEZBQThGLGdGQUFnRix3SEFBd0gsMkRBQTJELGlCQUFpQixhQUFhLElBQUksbUNBQW1DLGtlQUFrZSxtQkFBbUIsOERBQThELDBFQUEwRSw0Q0FBNEMsaUNBQWlDLDhDQUE4QyxnRUFBZ0UsNENBQTRDLCtCQUErQixnQkFBZ0Isd0dBQXdHLHFFQUFxRSxxRUFBcUUsNENBQTRDLGdiQUFnYixvRUFBb0Usd0NBQXdDLHlDQUF5QyxvRUFBb0Usd0NBQXdDLCtDQUErQyxxRUFBcUUsd0NBQXdDLG1kQUFtZCxtQkFBbUIsMERBQTBELCtFQUErRSw2QkFBNkIscUVBQXFFLHdDQUF3Qyx1RkFBdUYsd0NBQXdDLDZDQUE2Qyw0QkFBNEIsOEZBQThGLDRCQUE0Qiw2Q0FBNkMsNEJBQTRCLGlNQUFpTSxzREFBc0QsNkNBQTZDLCtDQUErQyxzREFBc0QsNENBQTRDLHdEQUF3RCxzREFBc0QsNkNBQTZDLGdKQUFnSixnR0FBZ0csa0JBQWtCLCtEQUErRCxzQkFBc0IsTUFBTSxzQ0FBc0MsZ0NBQWdDLDhCQUE4Qix5Q0FBeUMsZ0NBQWdDLE9BQU8sc0RBQXNELEdBQUcscVpBQXFaLGlFQUFpRSxxQkFBcUIsZ0NBQWdDLFNBQVMsV0FBVyw2RUFBNkUsK0JBQStCLHNDQUFzQyxnRUFBZ0Usb0JBQW9CLFdBQVcsOENBQThDLHFCQUFxQixHQUFHLDhaQUE4WixpQ0FBaUMsb0RBQW9ELHVWQUF1VixzQ0FBc0Msb2hCQUFvaEIsMENBQTBDLHFDQUFxQyxPQUFPLHlGQUF5RixzREFBc0Qsc0JBQXNCLDJDQUEyQyx5QkFBeUIsdUZBQXVGLHFDQUFxQyxtREFBbUQsMkZBQTJGLDJCQUEyQix3Q0FBd0MsUUFBUSwwQkFBMEIsc0NBQXNDLFFBQVEsMEJBQTBCLHVDQUF1QyxRQUFRLDBCQUEwQixzQ0FBc0MsUUFBUSwwQkFBMEIsdUNBQXVDLE9BQU8sZ0hBQWdILDhDQUE4Qyw0REFBNEQsR0FBRywrZUFBK2UscURBQXFELGVBQWUsd1BBQXdQLCtCQUErQiwwREFBMEQsb0ZBQW9GLGtEQUFrRCxHQUFHLHdEQUF3RCxtREFBbUQsR0FBRyw4REFBOEQseUNBQXlDLEdBQUcsaURBQWlELGdCQUFnQiwrQkFBK0IscUNBQXFDLGtDQUFrQyxHQUFHLDJQQUEyUCxjQUFjLHFEQUFxRCxtREFBbUQsbURBQW1ELG1EQUFtRCxtTUFBbU0sMEJBQTBCLCtCQUErQixnRUFBZ0UsdUZBQXVGLGdEQUFnRCwwRUFBMEUseURBQXlELGtEQUFrRCxpREFBaUQsa0RBQWtELGtEQUFrRCxpREFBaUQsa0RBQWtELG9EQUFvRCxtREFBbUQsa0RBQWtELG9EQUFvRCxtREFBbUQsMkZBQTJGLHVEQUF1RCxrRkFBa0YsNkVBQTZFLHlGQUF5Rix5RkFBeUYsbUZBQW1GLHdEQUF3RCx3REFBd0QsOEVBQThFLHdGQUF3Rix3RUFBd0Usd0ZBQXdGLHlFQUF5RSx3RkFBd0YsMkdBQTJHLDJDQUEyQyxrQ0FBa0Msd0NBQXdDLHdDQUF3QywyQkFBMkIsK0RBQStELGlEQUFpRCxVQUFVLG1DQUFtQyxHQUFHLHFDQUFxQyxvQkFBb0Isd0JBQXdCLG9DQUFvQyxvRUFBb0Usb0VBQW9FLG9FQUFvRSxvRUFBb0UsMkVBQTJFLG9IQUFvSCxHQUFHLGtGQUFrRixpRUFBaUUscUNBQXFDLCtCQUErQiw2QkFBNkIsR0FBRyxtREFBbUQsb0RBQW9ELHVCQUF1Qiw0QkFBNEIsaUNBQWlDLHlCQUF5Qiw4QkFBOEIsK0JBQStCLG1CQUFtQixnQkFBZ0IsTUFBTSw4Q0FBOEMsNkZBQTZGLGlEQUFpRCx5REFBeUQsaUNBQWlDLHlDQUF5Qyw0QkFBNEIsaUNBQWlDLDhCQUE4QixPQUFPLHdDQUF3QyxHQUFHLDZCQUE2QixnRkFBZ0Ysd0NBQXdDLDZEQUE2RCxnRUFBZ0UsOEJBQThCLEdBQUcsc0VBQXNFLG1CQUFtQiw0RkFBNEYsa0VBQWtFLG1FQUFtRSxtRUFBbUUsa0VBQWtFLGtFQUFrRSxrRUFBa0Usc0RBQXNELHNEQUFzRCxzREFBc0Qsc0RBQXNELHNEQUFzRCxzREFBc0QsK0dBQStHLHNGQUFzRiwyREFBMkQsb0NBQW9DLHFEQUFxRCxnRUFBZ0UsMkZBQTJGLDBGQUEwRix5RkFBeUYsb0ZBQW9GLG1FQUFtRSxrREFBa0QsK0RBQStELHNEQUFzRCx1RkFBdUYsdUZBQXVGLHFGQUFxRixzRkFBc0Ysb0ZBQW9GLHNGQUFzRixxRkFBcUYsMlFBQTJRLGdNQUFnTSxrQkFBa0IsK0RBQStELHNCQUFzQixNQUFNLHNDQUFzQyx3RkFBd0YsOEJBQThCLHdDQUF3QyxXQUFXLE9BQU8saUJBQWlCLEdBQUcsb0pBQW9KLDhCQUE4QixzT0FBc08sR0FBRyw0Q0FBNEMsa0VBQWtFLHFCQUFxQixnQ0FBZ0MsVUFBVSxXQUFXLG9DQUFvQyxzQ0FBc0Msc0NBQXNDLHNFQUFzRSxvQkFBb0IsV0FBVyxPQUFPLHFCQUFxQixHQUFHLHFLQUFxSyw0QkFBNEIsNENBQTRDLDJVQUEyVSxpQ0FBaUMsb0NBQW9DLG9DQUFvQyxtRUFBbUUsd0NBQXdDLDhGQUE4Riw4RkFBOEYsbURBQW1ELFdBQVcsTUFBTSwrQkFBK0IsK0xBQStMLGlDQUFpQyxVQUFVLGdDQUFnQyx3QkFBd0IsdUJBQXVCLDhCQUE4QixpQ0FBaUMsaUNBQWlDLDJEQUEyRCxxQ0FBcUMsc0ZBQXNGLHNGQUFzRixnREFBZ0QsUUFBUSxNQUFNLDBMQUEwTCw4QkFBOEIsT0FBTyxHQUFHLDZSQUE2UixtRUFBbUUsK0NBQStDLHFFQUFxRSxzREFBc0Qsc0RBQXNELHNCQUFzQiwyQ0FBMkMsd0JBQXdCLHVGQUF1RixxQ0FBcUMsbURBQW1ELHVEQUF1RCx1Q0FBdUMsNEJBQTRCLGlFQUFpRSxvQkFBb0IseUZBQXlGLG9CQUFvQix5RkFBeUYsb0JBQW9CLDBGQUEwRixvQkFBb0Isc0ZBQXNGLGtEQUFrRCxrRkFBa0YsMkJBQTJCLG9FQUFvRSwyQkFBMkIsMERBQTBELG1GQUFtRixzRUFBc0Usb0JBQW9CLDRGQUE0RiwyREFBMkQsT0FBTyxpRUFBaUUsOENBQThDLDZGQUE2RixpQ0FBaUMseUNBQXlDLG9GQUFvRixHQUFHLG9ZQUFvWSxtRUFBbUUsK0NBQStDLHFFQUFxRSxzREFBc0Qsc0RBQXNELHNCQUFzQiwyQ0FBMkMsd0JBQXdCLHVGQUF1RixxQ0FBcUMsbURBQW1ELHVEQUF1RCx1Q0FBdUMsNEJBQTRCLGlFQUFpRSxvQkFBb0IseUZBQXlGLG9CQUFvQix5RkFBeUYsb0JBQW9CLDBGQUEwRixvQkFBb0Isc0ZBQXNGLGtEQUFrRCxrRkFBa0YsMkJBQTJCLG9FQUFvRSwyQkFBMkIsMERBQTBELG1GQUFtRixpRkFBaUYseUZBQXlGLHdFQUF3RSxvR0FBb0csa0RBQWtELGtHQUFrRyx1REFBdUQsZ0RBQWdELHVCQUF1Qiw0RkFBNEYsaURBQWlELE9BQU8saUVBQWlFLDZDQUE2QyxvRkFBb0YsaUNBQWlDLHlDQUF5QyxvRkFBb0YsR0FBRyxpTUFBaU0sZ0ZBQWdGLGdFQUFnRSxzSUFBc0kscUdBQXFHLHNGQUFzRix3RkFBd0YsZ0dBQWdHLHFHQUFxRyx3RUFBd0UseUZBQXlGLHNCQUFzQiw2REFBNkQsZ0ZBQWdGLDZGQUE2RixzRkFBc0YsdUZBQXVGLGdHQUFnRyxvR0FBb0csMERBQTBELHlGQUF5RixzQkFBc0IsbUJBQW1CLG1JQUFtSSxvSUFBb0ksR0FBRyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTFhL2ZyYWdtZW50X3dhdGVyLmdsc2w/MzFkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBDUyA4ODAzLzQ4MDMgQ0dBSTogQ29tcHV0ZXIgR3JhcGhpY3MgaW4gQUkgRXJhXFxuLy8vLyBBc3NpZ25tZW50IDFBOiBTREYgYW5kIFJheSBNYXJjaGluZ1xcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgICAgICAgICAvLy8vIHNldCBkZWZhdWx0IHByZWNpc2lvbiBvZiBmbG9hdCB2YXJpYWJsZXMgdG8gaGlnaCBwcmVjaXNpb25cXG5cXG52YXJ5aW5nIHZlYzIgdlV2OyAgICAgICAgICAgICAgICAgICAvLy8vIHNjcmVlbiB1diBjb29yZGluYXRlcyAodmFyeWluZywgZnJvbSB2ZXJ0ZXggc2hhZGVyKVxcbnVuaWZvcm0gdmVjMiBpUmVzb2x1dGlvbjsgICAgICAgICAgIC8vLy8gc2NyZWVuIHJlc29sdXRpb24gKHVuaWZvcm0sIGZyb20gQ1BVKVxcbnVuaWZvcm0gZmxvYXQgaVRpbWU7ICAgICAgICAgICAgICAgIC8vLy8gdGltZSBlbGFwc2VkICh1bmlmb3JtLCBmcm9tIENQVSlcXG5cXG4jZGVmaW5lIElURVJBVElPTlNfTk9STUFMIDM2LjBcXG5cXG5jb25zdCB2ZWMzIENBTV9QT1MgPSB2ZWMzKC0wLjM1LCAxLjAsIC0zLjApOyAvLy8vIGNhbWVyYSBwb3NpdGlvblxcblxcbi8vIEdsb2JhbCB2YXJpYWJsZXNcXG5zdHJ1Y3QgSGl0SUQge1xcbiAgICBmbG9hdCBkaXN0O1xcbiAgICBpbnQgaWQ7XFxufTtcXG5IaXRJRCBoaXRfaWQgPSBIaXRJRCgyMDAwLjAsIC0xKTtcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gc2RmIGZ1bmN0aW9uc1xcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLy8vIFN0ZXAgMTogc2RmIHByaW1pdGl2ZXNcXG4vLy8vIFlvdSBhcmUgYXNrZWQgdG8gaW1wbGVtZW50IHNkZiBwcmltaXRpdmUgZnVuY3Rpb25zIGZvciBzcGhlcmUsIHBsYW5lLCBhbmQgYm94Llxcbi8vLy8gSW4gZWFjaCBmdW5jdGlvbiwgeW91IHdpbGwgY2FsY3VsYXRlIHRoZSBzZGYgdmFsdWUgYmFzZWQgb24gdGhlIGZ1bmN0aW9uIGFyZ3VtZW50cy5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcblxcbi8vLy8gc3BoZXJlOiBwIC0gcXVlcnkgcG9pbnQ7IGMgLSBzcGhlcmUgY2VudGVyOyByIC0gc3BoZXJlIHJhZGl1c1xcbmZsb2F0IHNkZlNwaGVyZSh2ZWMzIHAsIHZlYzMgYywgZmxvYXQgcilcXG57XFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG4gICAgXFxuICAgIHJldHVybiBsZW5ndGgocCAtIGMpIC0gcjtcXG4gICAgXFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxufVxcblxcbi8vLy8gcGxhbmU6IHAgLSBxdWVyeSBwb2ludDsgaCAtIGhlaWdodFxcbmZsb2F0IHNkZlBsYW5lKHZlYzMgcCwgZmxvYXQgaClcXG57XFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG4gICAgXFxuICAgIHJldHVybiBwLnkgLSBoO1xcbiAgICBcXG4gICAgLy8vLyB5b3VyIGltcGxlbWVudGF0aW9uIGVuZHNcXG59XFxuXFxuLy8vLyBib3g6IHAgLSBxdWVyeSBwb2ludDsgYyAtIGJveCBjZW50ZXI7IGIgLSBib3ggaGFsZiBzaXplIChpLmUuLCB0aGUgYm94IHNpemUgaXMgKDIqYi54LCAyKmIueSwgMipiLnopKVxcbmZsb2F0IHNkZkJveCh2ZWMzIHAsIHZlYzMgYywgdmVjMyBiKVxcbntcXG4gICAgLy8vLyB5b3VyIGltcGxlbWVudGF0aW9uIHN0YXJ0c1xcblxcbiAgICB2ZWMzIGQgPSBhYnMocCAtIGMpIC0gYjtcXG4gICAgcmV0dXJuIGxlbmd0aChtYXgoZCwgMC4wKSkgKyBtaW4obWF4KGQueCwgbWF4KGQueSwgZC56KSksIDAuMCk7XFxuICAgIFxcbiAgICAvLy8vIHlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gYm9vbGVhbiBvcGVyYXRpb25zXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gU3RlcCAyOiBzZGYgYm9vbGVhbiBvcGVyYXRpb25zXFxuLy8vLyBZb3UgYXJlIGFza2VkIHRvIGltcGxlbWVudCBzZGYgYm9vbGVhbiBvcGVyYXRpb25zIGZvciBpbnRlcnNlY3Rpb24sIHVuaW9uLCBhbmQgc3VidHJhY3Rpb24uXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5cXG5mbG9hdCBzZGZJbnRlcnNlY3Rpb24oZmxvYXQgczEsIGZsb2F0IHMyKVxcbntcXG4gICAgLy8vLyB5b3VyIGltcGxlbWVudGF0aW9uIHN0YXJ0c1xcbiAgICBcXG4gICAgcmV0dXJuIG1heChzMSwgczIpO1xcblxcbiAgICAvLy8vIHlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbn1cXG5cXG5mbG9hdCBzZGZVbmlvbihmbG9hdCBzMSwgZmxvYXQgczIpXFxue1xcbiAgICAvLy8vIHlvdXIgaW1wbGVtZW50YXRpb24gc3RhcnRzXFxuICAgIFxcbiAgICByZXR1cm4gbWluKHMxLCBzMik7XFxuXFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxufVxcblxcbmZsb2F0IHNkZlN1YnRyYWN0aW9uKGZsb2F0IHMxLCBmbG9hdCBzMilcXG57XFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG4gICAgXFxuICAgIHJldHVybiBtYXgoczEsIC1zMik7XFxuXFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBzZGYgY2FsY3VsYXRpb25cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBTdGVwIDM6IHNjZW5lIHNkZlxcbi8vLy8gWW91IGFyZSBhc2tlZCB0byB1c2UgdGhlIGltcGxlbWVudGVkIHNkZiBib29sZWFuIG9wZXJhdGlvbnMgdG8gZHJhdyB0aGUgZm9sbG93aW5nIG9iamVjdHMgaW4gdGhlIHNjZW5lIGJ5IGNhbGN1bGF0aW5nIHRoZWlyIENTRyBvcGVyYXRpb25zLlxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxuLy8vLyBzZGY6IHAgLSBxdWVyeSBwb2ludFxcbmZsb2F0IHNkZih2ZWMzIHApXFxue1xcbiAgICBmbG9hdCBzID0gMC47XFxuXFxuICAgIC8vLy8gMXN0IG9iamVjdDogcGxhbmVcXG4gICAgZmxvYXQgcGxhbmUxX2ggPSAtMC4xO1xcbiAgICBcXG4gICAgLy8vLyAybmQgb2JqZWN0OiBzcGhlcmVcXG4gICAgdmVjMyBzcGhlcmUxX2MgPSB2ZWMzKC0yLjAsIDEuMCwgMC4wKTtcXG4gICAgZmxvYXQgc3BoZXJlMV9yID0gMC4yNTtcXG5cXG4gICAgLy8vLyAzcmQgb2JqZWN0OiBib3hcXG4gICAgdmVjMyBib3gxX2MgPSB2ZWMzKC0xLjAsIDEuMCwgMC4wKTtcXG4gICAgdmVjMyBib3gxX2IgPSB2ZWMzKDAuMiwgMC4yLCAwLjIpO1xcblxcbiAgICAvLy8vIDR0aCBvYmplY3Q6IGJveC1zcGhlcmUgc3VidHJhY3Rpb25cXG4gICAgdmVjMyBib3gyX2MgPSB2ZWMzKDAuMCwgMS4wLCAwLjApO1xcbiAgICB2ZWMzIGJveDJfYiA9IHZlYzMoMC4zLCAwLjMsIDAuMyk7XFxuXFxuICAgIHZlYzMgc3BoZXJlMl9jID0gdmVjMygwLjAsIDEuMCwgMC4wKTtcXG4gICAgZmxvYXQgc3BoZXJlMl9yID0gMC40O1xcblxcbiAgICAvLy8vIDV0aCBvYmplY3Q6IHNwaGVyZS1zcGhlcmUgaW50ZXJzZWN0aW9uXFxuICAgIHZlYzMgc3BoZXJlM19jID0gdmVjMygxLjAsIDEuMCwgMC4wKTtcXG4gICAgZmxvYXQgc3BoZXJlM19yID0gMC40O1xcblxcbiAgICB2ZWMzIHNwaGVyZTRfYyA9IHZlYzMoMS4zLCAxLjAsIDAuMCk7XFxuICAgIGZsb2F0IHNwaGVyZTRfciA9IDAuMztcXG5cXG4gICAgLy8vLyBjYWxjdWxhdGUgdGhlIHNkZiBiYXNlZCBvbiBhbGwgb2JqZWN0cyBpbiB0aGUgc2NlbmVcXG4gICAgXFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBTREYgZm9yIGVhY2ggNSBvYmplY3RzXFxuICAgIGZsb2F0IHMxID0gc2RmUGxhbmUocCwgcGxhbmUxX2gpO1xcblxcbiAgICBmbG9hdCBzMiA9IHNkZlNwaGVyZShwLCBzcGhlcmUxX2MsIHNwaGVyZTFfcik7XFxuXFxuICAgIGZsb2F0IHMzID0gc2RmQm94KHAsIGJveDFfYywgYm94MV9iKTtcXG5cXG4gICAgZmxvYXQgczRfMSA9IHNkZkJveChwLCBib3gyX2MsIGJveDJfYik7XFxuICAgIGZsb2F0IHM0XzIgPSBzZGZTcGhlcmUocCwgc3BoZXJlMl9jLCBzcGhlcmUyX3IpO1xcbiAgICBmbG9hdCBzNCA9IHNkZlN1YnRyYWN0aW9uKHM0XzEsIHM0XzIpO1xcblxcbiAgICBmbG9hdCBzNV8xID0gc2RmU3BoZXJlKHAsIHNwaGVyZTNfYywgc3BoZXJlM19yKTtcXG4gICAgZmxvYXQgczVfMiA9IHNkZlNwaGVyZShwLCBzcGhlcmU0X2MsIHNwaGVyZTRfcik7XFxuICAgIGZsb2F0IHM1ID0gc2RmSW50ZXJzZWN0aW9uKHM1XzEsIHM1XzIpO1xcblxcbiAgICAvLyBDb21iaW5lIHRoZSBTREYgZm9yIGFsbCBvYmplY3RzXFxuICAgIGZsb2F0IG9iamVjdHNbXSA9IGZsb2F0W10oXFxuICAgICAgICBzMSwgXFxuICAgICAgICBzMiwgXFxuICAgICAgICBzMywgXFxuICAgICAgICBzNCwgXFxuICAgICAgICBzNSk7XFxuICAgIGludCBvYmplY3RfaWRzW10gPSBpbnRbXShcXG4gICAgICAgIDEsIFxcbiAgICAgICAgMiwgXFxuICAgICAgICAzLCBcXG4gICAgICAgIDQsIFxcbiAgICAgICAgNSk7XFxuICAgIHMgPSAxMDAwLjA7IC8vIHNldCBhIGxhcmdlIGluaXRpYWwgZGlzdGFuY2UgZm9yIHVuaW9uXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGgoKTsgaSsrKSB7XFxuICAgICAgICBzID0gc2RmVW5pb24ocywgb2JqZWN0c1tpXSk7XFxuICAgICAgICBpZiAocyA8IGhpdF9pZC5kaXN0KSB7XFxuICAgICAgICAgICAgaGl0X2lkLmRpc3QgPSBzO1xcbiAgICAgICAgICAgIGhpdF9pZC5pZCA9IG9iamVjdF9pZHNbaV07IC8vIFJlY29yZCBvYmplY3QgaGl0XFxuICAgICAgICB9IFxcbiAgICB9XFxuXFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxuXFxuICAgIHJldHVybiBzO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gcmF5IG1hcmNoaW5nXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gU3RlcCA0OiByYXkgbWFyY2hpbmdcXG4vLy8vIFlvdSBhcmUgYXNrZWQgdG8gaW1wbGVtZW50IHRoZSByYXkgbWFyY2hpbmcgYWxnb3JpdGhtIHdpdGhpbiB0aGUgZm9sbG93aW5nIGZvci1sb29wLlxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxuLy8vLyByYXkgbWFyY2hpbmc6IG9yaWdpbiAtIHJheSBvcmlnaW47IGRpciAtIHJheSBkaXJlY3Rpb24gXFxuZmxvYXQgcmF5TWFyY2hpbmcodmVjMyBvcmlnaW4sIHZlYzMgZGlyKVxcbntcXG4gICAgZmxvYXQgcyA9IDAuMDsgLy8gZGlzdGFuY2VcXG4gICAgZm9yKGludCBpID0gMDsgaSA8IDEwMDsgaSsrKVxcbiAgICB7XFxuICAgICAgICAvLy8vIHlvdXIgaW1wbGVtZW50YXRpb24gc3RhcnRzXFxuICAgICAgICB2ZWMzIHAgPSBvcmlnaW4gKyBkaXIgKiBzO1xcbiAgICAgICAgZmxvYXQgZGlzdCA9IHNkZihwKTsgLy8gc2RmIHZhbHVlIGluIHBcXG4gICAgICAgIHMgKz0gZGlzdDsgLy8gdXBkYXRlIHRoZSBkaXN0YW5jZVxcbiAgICAgICAgaWYgKHMgPiAxMDAuMCB8fCBkaXN0IDwgMC4wMDEpIHtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBlbmRzXFxuICAgIH1cXG4gICAgXFxuICAgIHJldHVybiBzO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gbm9ybWFsIGNhbGN1bGF0aW9uXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gU3RlcCA1OiBub3JtYWwgY2FsY3VsYXRpb25cXG4vLy8vIFlvdSBhcmUgYXNrZWQgdG8gY2FsY3VsYXRlIHRoZSBzZGYgbm9ybWFsIGJhc2VkIG9uIGZpbml0ZSBkaWZmZXJlbmNlLlxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxuLy8vLyBub3JtYWw6IHAgLSBxdWVyeSBwb2ludFxcbnZlYzMgbm9ybWFsKHZlYzMgcClcXG57XFxuICAgIGZsb2F0IHMgPSBzZGYocCk7ICAgICAgICAgIC8vLy8gc2RmIHZhbHVlIGluIHBcXG4gICAgZmxvYXQgZHggPSAwLjAxOyAgICAgICAgICAgLy8vLyBzdGVwIHNpemUgZm9yIGZpbml0ZSBkaWZmZXJlbmNlXFxuXFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG4gICAgXFxuICAgIHJldHVybiBub3JtYWxpemUodmVjMyhcXG4gICAgICAgIHNkZihwICsgdmVjMyhkeCwgMC4wLCAwLjApKSAtIHNkZihwIC0gdmVjMyhkeCwgMC4wLCAwLjApKSwgLy8gZHN4XFxuICAgICAgICBzZGYocCArIHZlYzMoMC4wLCBkeCwgMC4wKSkgLSBzZGYocCAtIHZlYzMoMC4wLCBkeCwgMC4wKSksIC8vIGRzeVxcbiAgICAgICAgc2RmKHAgKyB2ZWMzKDAuMCwgMC4wLCBkeCkpIC0gc2RmKHAgLSB2ZWMzKDAuMCwgMC4wLCBkeCkpICAvLyBkc3pcXG4gICAgKSk7XFxuXFxuICAgIC8vIHlvdXIgaW1wbGVtZW50YXRpb24gZW5kc1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gUGhvbmcgc2hhZGluZ1xcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLy8vIFN0ZXAgNjogbGlnaHRpbmcgYW5kIGNvbG9yaW5nXFxuLy8vLyBZb3UgYXJlIGFza2VkIHRvIHNwZWNpZnkgdGhlIGNvbG9yIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgc2NlbmUuXFxuLy8vLyBFYWNoIG9iamVjdCBtdXN0IGhhdmUgYSBzZXBhcmF0ZSBjb2xvciB3aXRob3V0IG1peGluZy5cXG4vLy8vIE5vdGljZSB0aGF0IHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIGRlZmF1bHQgUGhvbmcgc2hhZGluZyBtb2RlbCBmb3IgeW91Llxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxudmVjMyBwaG9uZ19zaGFkaW5nKHZlYzMgcCwgdmVjMyBuKVxcbntcXG4gICAgLy8vLyBiYWNrZ3JvdW5kXFxuICAgIGlmKHAueiA+IDEwLjApe1xcbiAgICAgICAgcmV0dXJuIHZlYzMoMC45LCAwLjYsIDAuMik7XFxuICAgIH1cXG5cXG4gICAgLy8vLyBwaG9uZyBzaGFkaW5nXFxuICAgIHZlYzMgbGlnaHRQb3MgPSB2ZWMzKDQuKnNpbihpVGltZSksIDQuLCA0Lipjb3MoaVRpbWUpKTsgIFxcbiAgICB2ZWMzIGwgPSBub3JtYWxpemUobGlnaHRQb3MgLSBwKTsgICAgICAgICAgICAgICBcXG4gICAgZmxvYXQgYW1iID0gMC4xO1xcbiAgICBmbG9hdCBkaWYgPSBtYXgoZG90KG4sIGwpLCAwLikgKiAwLjc7XFxuICAgIHZlYzMgZXllID0gQ0FNX1BPUztcXG4gICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KHJlZmxlY3QoLWwsIG4pLCBub3JtYWxpemUoZXllIC0gcCkpLCAwLjApLCAxMjguMCkgKiAwLjk7XFxuXFxuICAgIHZlYzMgc3VuRGlyID0gdmVjMygwLCAxLCAtMSk7XFxuICAgIGZsb2F0IHN1bkRpZiA9IG1heChkb3Qobiwgc3VuRGlyKSwgMC4pICogMC4yO1xcblxcbiAgICAvLy8vIHlvdXIgaW1wbGVtZW50YXRpb24gZm9yIGNvbG9yaW5nIHN0YXJ0c1xcbiAgICB2ZWMzIGNvbG9yID0gdmVjMygxLjAsIDEuMCwgMS4wKTtcXG4gICAgaWYgKGhpdF9pZC5pZCA9PSAxKSB7XFxuICAgICAgICBjb2xvciA9IHZlYzMoMC4xMywgMC43MiwgMC4wKTtcXG4gICAgfSBlbHNlIGlmIChoaXRfaWQuaWQgPT0gMikge1xcbiAgICAgICAgY29sb3IgPSB2ZWMzKDEuMCwgMC4wLCAwLjApO1xcbiAgICB9IGVsc2UgaWYgKGhpdF9pZC5pZCA9PSAzKSB7XFxuICAgICAgICBjb2xvciA9IHZlYzMoMC42NSwgMS4wLCAwLjApO1xcbiAgICB9IGVsc2UgaWYgKGhpdF9pZC5pZCA9PSA0KSB7XFxuICAgICAgICBjb2xvciA9IHZlYzMoMC41LCAwLjAsIDEuMCk7XFxuICAgIH0gZWxzZSBpZiAoaGl0X2lkLmlkID09IDUpIHtcXG4gICAgICAgIGNvbG9yID0gdmVjMygwLjAsIDAuNTIsIDEuMCk7XFxuICAgIH1cXG4gICAgLy8vLyB5b3VyIGltcGxlbWVudGF0aW9uIGZvciBjb2xvcmluZyBlbmRzXFxuXFxuICAgIC8vLy8gc2hhZG93XFxuICAgIGZsb2F0IHMgPSByYXlNYXJjaGluZyhwICsgbiAqIDAuMDIsIGwpO1xcbiAgICBpZihzIDwgbGVuZ3RoKGxpZ2h0UG9zIC0gcCkpIGRpZiAqPSAuMjsgLy8gc2hhZG93XFxuXFxuICAgIHJldHVybiAoYW1iICsgZGlmICsgc3BlYyArIHN1bkRpZikgKiBjb2xvcjtcXG59XFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLy8vIFN0ZXAgNzogY3JlYXRpdmUgZXhwcmVzc2lvblxcbi8vLy8gWW91IHdpbGwgY3JlYXRlIHlvdXIgY3VzdG9taXplZCBzZGYgc2NlbmUgd2l0aCBuZXcgcHJpbWl0aXZlcyBhbmQgQ1NHIG9wZXJhdGlvbnMgaW4gdGhlIHNkZjIgZnVuY3Rpb24uXFxuLy8vLyBDYWxsIHNkZjIgaW4geW91ciByYXkgbWFyY2hpbmcgZnVuY3Rpb24gdG8gcmVuZGVyIHlvdXIgY3VzdG9taXplZCBzY2VuZS5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcblxcbi8qKlxcbiAqIFJldHVybiBhIGZsb2F0IHZhbHVlIGJldHdlZW4gMC4wKDBzKSBhbmQgMS4wKDEwcykgdGhhdCByZXByZXNlbnRzIGEgMTBzIGN5Y2xlXFxuICogVXNlZCBmb3IgdGltZS1iYXNlZCBhbmltYXRpb25zXFxuICovXFxuZmxvYXQgZ2V0U3luY2VkVGltZUN5Y2xlKCkgXFxue1xcbiAgICByZXR1cm4gZmxvYXQoaW50KGlUaW1lICogNjAuMCkgJSA2MDApIC8gNjAwLjA7IC8vIDEwcyBjeWNsZVxcbn1cXG5cXG4vKipcXG4gKiBTREYgZm9yIGEgY3VydnkgZ3JvdW5kIG9mIHNpbiBhbmQgY29zIHdhdmVzXFxuICogV2l0aCBsYXJnZXIgd2F2ZXMgZm9yIGhpbGxzIGFuZCBzbWFsbGVyIHdhdmVzIGZvciB0ZXh0dXJlXFxuICogQHBhcmFtIHA6IHF1ZXJ5IHBvaW50XFxuICogQHBhcmFtIGg6IGhlaWdodCBvZiB0aGUgZ3JvdW5kXFxuICogQHJldHVybiBTREYgdmFsdWVcXG4gKi9cXG5mbG9hdCBzZGZDdXJ2eUdyb3VuZCh2ZWMzIHAsIGZsb2F0IGgpIFxcbntcXG4gICAgcCAtPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcbiAgICBmbG9hdCB3YXZlID0gMC4zICogc2luKDAuNSAqIHAueCkgKiBjb3MoMS4wICogcC56KTsgLy8gSGlsbHMgYW5kIFZhbGxleXNcXG4gICAgZmxvYXQgdGV4dHVyZSA9IDAuMDIgKiBzaW4oNDAuMCAqIHAueCkgKiBzaW4oODAuMCAqIHAueik7IC8vIFRleHR1cmVcXG4gICAgcmV0dXJuIHAueSAtIChoICsgd2F2ZSArIHRleHR1cmUpO1xcbn1cXG5cXG5mbG9hdCBzZGZVbmlvblNtb290aChmbG9hdCBzMSwgZmxvYXQgczIsIGZsb2F0IGspXFxue1xcbiAgICByZXR1cm4gLWsgKiBsb2coZXhwKC1zMSAvIGspICsgZXhwKC1zMiAvIGspKTtcXG59XFxuXFxuZmxvYXQgc2RmU3VidHJhY3Rpb25TbW9vdGgoZmxvYXQgczEsIGZsb2F0IHMyLCBmbG9hdCBrKVxcbntcXG4gICAgcmV0dXJuIC1zZGZVbmlvblNtb290aCgtczEsIHMyLCBrKTtcXG59XFxuXFxuZmxvYXQgc2RmRWxsaXBzb2lkKHZlYzMgcCwgdmVjMyBjLCB2ZWMzIHIpXFxue1xcbiAgICBwID0gcCAtIGM7XFxuICAgIGZsb2F0IGswID0gbGVuZ3RoKHAgLyByKTtcXG4gICAgZmxvYXQgazEgPSBsZW5ndGgocCAvIChyICogcikpO1xcbiAgICByZXR1cm4gazAgKiAoazAgLSAxLjApIC8gazE7XFxufVxcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHBvaW50IGFyb3VuZCBhIGNlbnRlciBwb2ludCB3aXRoIGdpdmVuIGFuZ2xlc1xcbiAqIEBwYXJhbSBwOiBwb2ludCB0byByb3RhdGVcXG4gKiBAcGFyYW0gYzogY2VudGVyIHBvaW50XFxuICogQHBhcmFtIGFuZ2xlczogcm90YXRpb24gYW5nbGVzIGluIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHJvdGF0ZWQgcG9pbnRcXG4gKi9cXG52ZWMzIHJvdGF0ZVhZWih2ZWMzIHAsIHZlYzMgYywgdmVjMyBhbmdsZXMpXFxueyAgIFxcbiAgICBwIC09IGM7IC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cXG4gICAgYW5nbGVzID0gcmFkaWFucyhhbmdsZXMpO1xcbiAgICBmbG9hdCBjMSA9IGNvcyhhbmdsZXMueCksIHMxID0gc2luKGFuZ2xlcy54KTtcXG4gICAgZmxvYXQgYzIgPSBjb3MoYW5nbGVzLnkpLCBzMiA9IHNpbihhbmdsZXMueSk7XFxuICAgIGZsb2F0IGMzID0gY29zKGFuZ2xlcy56KSwgczMgPSBzaW4oYW5nbGVzLnopO1xcblxcbiAgICBtYXQzIG0gPSBtYXQzKFxcbiAgICAgICAgYzEgKiBjMyArIHMxICogczIgKiBzMywgYzIgKiBzMywgLXMxICogYzMgKyBjMSAqIHMyICogczMsXFxuICAgICAgICAtYzEgKiBzMyArIHMxICogczIgKiBjMywgYzIgKiBjMywgczEgKiBzMyArIGMxICogczIgKiBjMyxcXG4gICAgICAgIHMxICogYzIsIC1zMiwgYzEgKiBjMlxcbiAgICApO1xcblxcbiAgICByZXR1cm4gbSAqIHAgKyBjOyAvLyBSb3RhdGUgYW5kIHRyYW5zbGF0ZSBiYWNrXFxufVxcblxcbmZsb2F0IHNkZkJvcmIodmVjMyBwLCB2ZWMzIGMsIGZsb2F0IGFuZ2xlLCBib29sIGJpcmJIYWlyKVxcbntcXG4gICAgXFxuICAgIC8vIFJvdGF0ZSBhcm91bmQgdGhlIFktYXhpc1xcbiAgICBmbG9hdCBiaXJiX21vdmUxID0gMy4wICogc2luKGlUaW1lICogMy4wKTtcXG4gICAgZmxvYXQgYmlyYl9tb3ZlMiA9IDMuMCAqIGNvcyhpVGltZSAqIDEuMCk7XFxuICAgIHZlYzMgbG9jYWxfcCA9IHJvdGF0ZVhZWihwLCBjLCB2ZWMzKGFuZ2xlLCBiaXJiX21vdmUxLCBiaXJiX21vdmUyKSk7XFxuXFxuICAgIC8vIERlZmluZSB0aGUgYm9yYiBjb21wb25lbnRzXFxuICAgIGZsb2F0IHIgPSAwLjI7XFxuICAgIHZlYzMgaGVhZF9jICA9IGMgKyByICogdmVjMygtMC4xLCAxLjUsIDAuMCk7XFxuICAgIHZlYzMgYm9keV9jICA9IGMgKyByICogdmVjMygwLjAsIDAuMCwgMC4wKTtcXG4gICAgdmVjMyB0YWlsX2MgID0gYyArIHIgKiB2ZWMzKDEuNSwgLTAuMywgMC4wKTtcXG4gICAgdmVjMyB3aW5nTF9jID0gYyArIHIgKiB2ZWMzKDAuMCwgMC4xLCAtMS4wKTtcXG4gICAgdmVjMyB3aW5nUl9jID0gYyArIHIgKiB2ZWMzKDAuMCwgMC4xLCAxLjApO1xcbiAgICB2ZWMzIHBlYWtfYyAgPSBjICsgciAqIHZlYzMoLTEuMiwgMS40LCAwLjApO1xcbiAgICB2ZWMzIGV5ZUxfYyAgPSBjICsgciAqIHZlYzMoLTAuNywgMS42LCAtMC45NSk7XFxuICAgIHZlYzMgZXllUl9jICA9IGMgKyByICogdmVjMygtMC43LCAxLjYsIDAuOTUpO1xcbiAgICB2ZWMzIGhhaXIxX2MgPSBjICsgciAqIHZlYzMoLTAuNSwgMi42LCAwLjApO1xcbiAgICB2ZWMzIGhhaXIyX2MgPSBjICsgciAqIHZlYzMoLTAuNDUsIDIuNywgLTAuMik7XFxuICAgIHZlYzMgaGFpcjNfYyA9IGMgKyByICogdmVjMygtMC40NSwgMi43LCAwLjIpO1xcblxcbiAgICAvLyBDb21wdXRlIFNERiBmb3IgZWFjaCBwYXJ0XFxuICAgIGZsb2F0IGhlYWQgPSBzZGZTcGhlcmUobG9jYWxfcCwgaGVhZF9jLCAwLjkgKiByKTtcXG4gICAgZmxvYXQgYm9keSA9IHNkZlNwaGVyZShsb2NhbF9wLCBib2R5X2MsIDEuMyAqIHIpO1xcbiAgICBmbG9hdCB0YWlsID0gc2RmRWxsaXBzb2lkKGxvY2FsX3AsIHRhaWxfYywgdmVjMygxLjIgKiByLCAwLjYgKiByLCAwLjYgKiByKSk7XFxuICAgIHZlYzMgbG9jYWxfcF93aW5nID0gcm90YXRlWFlaKGxvY2FsX3AsIHdpbmdMX2MsIHZlYzMoMC4wLCAwLjAsIC0yMC4wKSk7XFxuICAgIGZsb2F0IHdpbmdMID0gc2RmRWxsaXBzb2lkKGxvY2FsX3Bfd2luZywgd2luZ0xfYywgdmVjMygwLjYgKiByLCAxLjAgKiByLCAxLjAgKiByKSk7XFxuICAgIGZsb2F0IHdpbmdSID0gc2RmRWxsaXBzb2lkKGxvY2FsX3Bfd2luZywgd2luZ1JfYywgdmVjMygwLjYgKiByLCAxLjAgKiByLCAxLjAgKiByKSk7XFxuICAgIGZsb2F0IHBlYWsgPSBzZGZFbGxpcHNvaWQobG9jYWxfcCwgcGVha19jLCB2ZWMzKDAuMjUgKiByLCAwLjQgKiByLCAwLjIgKiByKSk7XFxuICAgIGZsb2F0IGV5ZUwgPSBzZGZTcGhlcmUobG9jYWxfcCwgZXllTF9jLCAwLjE1ICogcik7XFxuICAgIGZsb2F0IGV5ZVIgPSBzZGZTcGhlcmUobG9jYWxfcCwgZXllUl9jLCAwLjE1ICogcik7XFxuXFxuICAgIHZlYzMgbG9jYWxfcF9oYWlyID0gcm90YXRlWFlaKGxvY2FsX3AsIGhhaXIxX2MsIHZlYzMoMC4wLCAwLjAsIDMwLjApKTtcXG4gICAgZmxvYXQgaGFpcjEgPSBzZGZFbGxpcHNvaWQobG9jYWxfcF9oYWlyLCBoYWlyMV9jLCB2ZWMzKDAuMDgsIDAuMywgMC4yKSAqIHIgKiAxLjcpO1xcbiAgICBsb2NhbF9wX2hhaXIgPSByb3RhdGVYWVoobG9jYWxfcCwgaGFpcjFfYywgdmVjMygwLjAsIDQ1LjAsIDMwLjApKTtcXG4gICAgZmxvYXQgaGFpcjIgPSBzZGZFbGxpcHNvaWQobG9jYWxfcF9oYWlyLCBoYWlyMl9jLCB2ZWMzKDAuMDgsIDAuMywgMC4yKSAqIHIgKiAxLjcpO1xcbiAgICBsb2NhbF9wX2hhaXIgPSByb3RhdGVYWVoobG9jYWxfcCwgaGFpcjFfYywgdmVjMygwLjAsIC00NS4wLCAzMC4wKSk7XFxuICAgIGZsb2F0IGhhaXIzID0gc2RmRWxsaXBzb2lkKGxvY2FsX3BfaGFpciwgaGFpcjNfYywgdmVjMygwLjA4LCAwLjMsIDAuMikgKiByICogMS43KTtcXG5cXG4gICAgLy8gQ29tYmluZSB0aGUgcGFydHMgc21vb3RobHlcXG4gICAgYm9keSA9IHNkZlVuaW9uU21vb3RoKHNkZlVuaW9uU21vb3RoKGhlYWQsIGJvZHksIC4xKSwgdGFpbCwgLjEpO1xcbiAgICBmbG9hdCB3aW5ncyA9IHNkZlVuaW9uKHdpbmdMLCB3aW5nUik7XFxuICAgIGJvZHkgPSBzZGZVbmlvbihib2R5LCBwZWFrKTtcXG4gICAgYm9keSA9IHNkZlN1YnRyYWN0aW9uKGJvZHksIGV5ZUwpO1xcbiAgICBib2R5ID0gc2RmU3VidHJhY3Rpb24oYm9keSwgZXllUik7XFxuICAgIFxcbiAgICBpZiAoYmlyYkhhaXIpIHtcXG4gICAgICAgIGZsb2F0IGhhaXIgPSBzZGZVbmlvbihzZGZVbmlvbihoYWlyMSwgaGFpcjIpLCBoYWlyMyk7XFxuICAgICAgICBib2R5ID0gc2RmVW5pb25TbW9vdGgoYm9keSwgaGFpciwgLjAxKTtcXG4gICAgfSAgIFxcbiAgICByZXR1cm4gc2RmVW5pb24oYm9keSwgd2luZ3MpO1xcbn1cXG5cXG5mbG9hdCBzZGZDbG91ZCh2ZWMzIHAsIHZlYzMgYylcXG57XFxuICAgIGZsb2F0IHIgPSAwLjg7XFxuICAgIGZsb2F0IHNwYWNlID0gMC44O1xcbiAgICBmbG9hdCBzMSA9IHNkZlNwaGVyZShwLCBjLCByKTtcXG4gICAgZmxvYXQgczIgPSBzZGZTcGhlcmUocCwgYyArIHIgKiB2ZWMzKDEsIDEuNCwgMC4wKSAqIHNwYWNlLCByKTtcXG4gICAgZmxvYXQgczMgPSBzZGZTcGhlcmUocCwgYyArIHIgKiB2ZWMzKDIsIDAuMCwgMC4wKSAqIHNwYWNlLCByKTtcXG4gICAgZmxvYXQgczQgPSBzZGZTcGhlcmUocCwgYyArIHIgKiB2ZWMzKDMsIDEuNCwgMC4wKSAqIHNwYWNlLCByKTtcXG4gICAgZmxvYXQgczUgPSBzZGZTcGhlcmUocCwgYyArIHIgKiB2ZWMzKDQsIDAuMCwgMC4wKSAqIHNwYWNlLCByKTtcXG4gICAgLy8gcmV0dXJuIHNkZlVuaW9uKHNkZlVuaW9uKHNkZlVuaW9uKHNkZlVuaW9uKHMxLCBzMiksIHMzKSwgczQpLCBzNSk7XFxuICAgIHJldHVybiBzZGZVbmlvblNtb290aChzZGZVbmlvblNtb290aChzZGZVbmlvblNtb290aChzZGZVbmlvblNtb290aChzMSwgczIsIDAuMSksIHMzLCAwLjEpLCBzNCwgMC4xKSwgczUsIDAuMSk7XFxufVxcblxcbnZlYzIgd2F2ZWR4KHZlYzIgcG9zaXRpb24sIHZlYzIgZGlyZWN0aW9uLCBmbG9hdCBmcmVxdWVuY3ksIGZsb2F0IHRpbWVzaGlmdCkge1xcbiAgICBmbG9hdCB4ID0gZG90KGRpcmVjdGlvbiwgcG9zaXRpb24pICogZnJlcXVlbmN5ICsgdGltZXNoaWZ0O1xcbiAgICBmbG9hdCB3YXZlID0gZXhwKHNpbih4KSAtIDEuMCk7XFxuICAgIGZsb2F0IGR4ID0gd2F2ZSAqIGNvcyh4KTtcXG4gICAgcmV0dXJuIHZlYzIod2F2ZSwgLWR4KTtcXG59XFxuXFxuZmxvYXQgZ2V0d2F2ZXModmVjMiBwb3NpdGlvbiwgaW50IGl0ZXJhdGlvbnMpIHtcXG4gICAgZmxvYXQgd2F2ZVBoYXNlU2hpZnQgPSBsZW5ndGgocG9zaXRpb24pICogMC4xO1xcbiAgICBmbG9hdCBpdGVyID0gMC4wO1xcbiAgICBmbG9hdCBmcmVxdWVuY3kgPSAxLjA7XFxuICAgIGZsb2F0IHRpbWVNdWx0aXBsaWVyID0gMi4wO1xcbiAgICBmbG9hdCB3ZWlnaHQgPSAxLjA7XFxuICAgIGZsb2F0IHN1bU9mVmFsdWVzID0gMC4wO1xcbiAgICBmbG9hdCBzdW1PZldlaWdodHMgPSAwLjA7XFxuICAgIGZvcihpbnQgaT0wOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XFxuICAgICAgICB2ZWMyIHAgPSB2ZWMyKHNpbihpdGVyKSwgY29zKGl0ZXIpKTtcXG4gICAgICAgIHZlYzIgcmVzID0gd2F2ZWR4KHBvc2l0aW9uLCBwLCBmcmVxdWVuY3ksIGlUaW1lICogdGltZU11bHRpcGxpZXIgKyB3YXZlUGhhc2VTaGlmdCk7XFxuICAgICAgICBwb3NpdGlvbiArPSBwICogcmVzLnkgKiB3ZWlnaHQgKiAwLjM4OyAvLyBEUkFHX01VTFQg5Y+v6Ieq5a6a5LmJXFxuICAgICAgICBzdW1PZlZhbHVlcyArPSByZXMueCAqIHdlaWdodDtcXG4gICAgICAgIHN1bU9mV2VpZ2h0cyArPSB3ZWlnaHQ7XFxuICAgICAgICB3ZWlnaHQgPSBtaXgod2VpZ2h0LCAwLjAsIDAuMik7XFxuICAgICAgICBmcmVxdWVuY3kgKj0gMS4xODtcXG4gICAgICAgIHRpbWVNdWx0aXBsaWVyICo9IDEuMDc7XFxuICAgICAgICBpdGVyICs9IDEyMzIuMzk5OTYzO1xcbiAgICB9XFxuICAgIHJldHVybiBzdW1PZlZhbHVlcyAvIHN1bU9mV2VpZ2h0cztcXG59XFxuXFxuZmxvYXQgc2RmUml2ZXIodmVjMyBwKVxcbntcXG4gICAgZmxvYXQgcml2ZXJib2R5ID0gc2RmQm94KHAsIHZlYzMoMC4wLCAtMC42NSwgMC4wKSwgdmVjMygyLjAsIDAuMSwgMTAwLjApKTtcXG4gICAgLy8gZmxvYXQgdCA9IGdldFN5bmNlZFRpbWVDeWNsZSgpO1xcbiAgICAvLyAvLyBmbG9hdCB3YXZlID0gMC4wMDE1ICogY29zKDguMCAqIHAueiAtIHQgKiAxNS4wKTsgLy8gQ3Vydnkgd2F2ZSBlZmZlY3RcXG4gICAgZmxvYXQgd2F2ZSA9IGdldHdhdmVzKHAueHksIDM2KSowLjA1OyBcXG4gICAgcmV0dXJuIHJpdmVyYm9keSArIHdhdmU7XFxufVxcblxcbi8vLy8gc2RmMjogcCAtIHF1ZXJ5IHBvaW50XFxuZmxvYXQgc2RmMih2ZWMzIHAsIGJvb2wgcmVjb3JkX2hpdClcXG57XFxuICAgIGZsb2F0IHMgPSAwLjtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBTREYgZm9yIGVhY2ggNSBvYmplY3RzXFxuICAgIGZsb2F0IGdyb3VuZCA9IHNkZkN1cnZ5R3JvdW5kKHAsIC0wLjEpO1xcbiAgICBmbG9hdCBtb3VudGFpbjEgPSBzZGZTcGhlcmUocCwgdmVjMygtNS4wLCAtMS4wLCAyMC4wKSwgMi4wKTtcXG4gICAgZmxvYXQgbW91bnRhaW4yID0gc2RmU3BoZXJlKHAsIHZlYzMoLTEwLjAsIC0xLjUsIDMwLjApLCA0LjApO1xcbiAgICBmbG9hdCBtb3VudGFpbjMgPSBzZGZTcGhlcmUocCwgdmVjMygtMTUuMCwgLTIuMCwgMjUuMCksIDYuMCk7XFxuICAgIGZsb2F0IG1vdW50YWluNCA9IHNkZlNwaGVyZShwLCB2ZWMzKC03LjAsIC0xLjAsIDE1LjApLCAyLjApO1xcbiAgICBmbG9hdCBtb3VudGFpbjUgPSBzZGZTcGhlcmUocCwgdmVjMygxMC4wLCAtMS4wLCAyMC4wKSwgMi4wKTtcXG4gICAgZmxvYXQgbW91bnRhaW42ID0gc2RmU3BoZXJlKHAsIHZlYzMoMTMuMCwgLTIuMCwgMTUuMCksIDQuMCk7XFxuICAgIGdyb3VuZCA9IHNkZlVuaW9uU21vb3RoKGdyb3VuZCwgbW91bnRhaW4xLCAwLjUpO1xcbiAgICBncm91bmQgPSBzZGZVbmlvblNtb290aChncm91bmQsIG1vdW50YWluMiwgMC41KTtcXG4gICAgZ3JvdW5kID0gc2RmVW5pb25TbW9vdGgoZ3JvdW5kLCBtb3VudGFpbjMsIDAuNSk7XFxuICAgIGdyb3VuZCA9IHNkZlVuaW9uU21vb3RoKGdyb3VuZCwgbW91bnRhaW40LCAwLjUpO1xcbiAgICBncm91bmQgPSBzZGZVbmlvblNtb290aChncm91bmQsIG1vdW50YWluNSwgMC41KTtcXG4gICAgZ3JvdW5kID0gc2RmVW5pb25TbW9vdGgoZ3JvdW5kLCBtb3VudGFpbjYsIDAuNSk7XFxuXFxuICAgIC8vIGNoYW5nZSBwIGZvciByaXZlcmJlZCB3aXRoIHJlc3BlY3QgdG8gcC56XFxuICAgIHZlYzMgcml2ZXJiZWRfcCA9IHAgKyB2ZWMzKHNpbihwLnogKiAwLjIpLCAwLjAsIDAuMCk7XFxuICAgIGZsb2F0IHJpdmVyYmVkID0gc2RmQm94KHJpdmVyYmVkX3AsIHZlYzMoMC4wLCAwLjAsIDAuMCksIHZlYzMoMS4wLCAwLjUsIDEwMC4wKSk7XFxuICAgIGdyb3VuZCA9IHNkZlN1YnRyYWN0aW9uU21vb3RoKGdyb3VuZCwgcml2ZXJiZWQsIDAuNSk7XFxuICAgIGZsb2F0IHJpdmVyYm9keSA9IHNkZlJpdmVyKHApO1xcblxcbiAgICAvLyBmbG9hdCBiaXJiX21vdmUgPSAwLjAzICogc2luKGlUaW1lIC8gMi4wKTtcXG4gICAgZmxvYXQgYmlyYl9tb3ZlID0gZ2V0d2F2ZXMocC54eiwgSVRFUkFUSU9OU19OT1JNQUwpICogMC4xO1xcbiAgICBmbG9hdCBicmliMSA9IHNkZkJvcmIocCwgdmVjMygwLjUsIC0wLjQgLSAwLjIgKyBiaXJiX21vdmUsIC0wLjY1ICsgMS4pLCAtODAuMCwgdHJ1ZSk7XFxuICAgIGZsb2F0IGJyaWIyID0gc2RmQm9yYihwLCB2ZWMzKC0wLjIsIC0wLjMgLSAwLjIgKyBiaXJiX21vdmUsIDAuMCArIDEuKSwgMTYwLjAsIHRydWUpO1xcbiAgICBmbG9hdCBicmliMyA9IHNkZkJvcmIocCwgdmVjMygwLjYsIC0wLjMgLSAwLjIgKyBiaXJiX21vdmUsIDAuNSArIDEuKSwgNDAuMCAsIHRydWUpO1xcblxcbiAgICBmbG9hdCBiYWNrZ3JvdW5kID0gc2RmQm94KHAsIHZlYzMoMC4wLCAwLjAsIDUwLjApLCB2ZWMzKDEwMC4wLCAxMDAuMCwgMS4wKSk7XFxuXFxuICAgIC8vIGZsb2F0IHN1bl9tb3ZlID0gZmxvYXQoaW50KGlUaW1lICogNjAuMCkgJSA2MDApIC8gMjQwLjA7XFxuICAgIGZsb2F0IHN1bl9tb3ZlID0gZ2V0U3luY2VkVGltZUN5Y2xlKCkgKiAzLjA7XFxuICAgIGZsb2F0IHN1biA9IHNkZlNwaGVyZShwLCB2ZWMzKDEuMCwgc3VuX21vdmUsIDUwLjApLCAyLjUpO1xcbiAgICBcXG4gICAgZmxvYXQgY2xvdWRfbW92ZSA9IDAuMiAqIHNpbihpVGltZSAvIDEuMCk7XFxuICAgIGZsb2F0IGNsb3VkMSA9IHNkZkNsb3VkKHAsIHZlYzMoLTEwLjAsIDEwLjAsIDIwLjApICsgdmVjMygwLjAsIGNsb3VkX21vdmUsIDAuMCkpO1xcbiAgICBmbG9hdCBjbG91ZDIgPSBzZGZDbG91ZChwLCB2ZWMzKC0xNS4wLCA0LjAsIDE1LjApICsgdmVjMygwLjAsIC1jbG91ZF9tb3ZlLCAwLjApKTtcXG4gICAgZmxvYXQgY2xvdWQzID0gc2RmQ2xvdWQocCwgdmVjMygxMi4wLCA1LjAsIDE3LjApICsgdmVjMygwLjAsIGNsb3VkX21vdmUsIDAuMCkpO1xcbiAgICBmbG9hdCBjbG91ZDQgPSBzZGZDbG91ZChwLCB2ZWMzKDMuMCwgMTAuMCwgMjAuMCkgKyB2ZWMzKDAuMCwgLWNsb3VkX21vdmUsIDAuMCkpO1xcbiAgICBmbG9hdCBjbG91ZDUgPSBzZGZDbG91ZChwLCB2ZWMzKDguMCwgMy4wLCAxNS4wKSArIHZlYzMoMC4wLCBjbG91ZF9tb3ZlLCAwLjApKTtcXG4gICAgZmxvYXQgY2xvdWQ2ID0gc2RmQ2xvdWQocCwgdmVjMygxMC4wLCA3LjAsIDMwLjApICsgdmVjMygwLjAsIC1jbG91ZF9tb3ZlLCAwLjApKTtcXG4gICAgZmxvYXQgY2xvdWQ3ID0gc2RmQ2xvdWQocCwgdmVjMygtMy4wLCA4LjAsIDQwLjApICsgdmVjMygwLjAsIGNsb3VkX21vdmUsIDAuMCkpO1xcblxcbiAgICAvLyBDb21iaW5lIHRoZSBTREYgZm9yIGFsbCBvYmplY3RzXFxuICAgIGZsb2F0IG9iamVjdHNbXSA9IGZsb2F0W10oXFxuICAgICAgICBncm91bmQsXFxuICAgICAgICBicmliMSxcXG4gICAgICAgIGJyaWIyLCBcXG4gICAgICAgIGJyaWIzLFxcbiAgICAgICAgYmFja2dyb3VuZCxcXG4gICAgICAgIHN1bixcXG4gICAgICAgIGNsb3VkMSwgY2xvdWQyLCBjbG91ZDMsIGNsb3VkNCwgY2xvdWQ1LCBjbG91ZDYsIGNsb3VkNyxcXG4gICAgICAgIHJpdmVyYm9keVxcbiAgICApO1xcbiAgICAvLyBBc3NpZ24gb2JqZWN0IGlkcyBmb3IgY29sb3JpbmdcXG4gICAgaW50IG9iamVjdF9pZHNbXSA9IGludFtdKFxcbiAgICAgICAgMSxcXG4gICAgICAgIDIsXFxuICAgICAgICAzLCBcXG4gICAgICAgIDQsXFxuICAgICAgICA1LFxcbiAgICAgICAgNixcXG4gICAgICAgIDcsIDcsIDcsIDcsIDcsIDcsIDcsXFxuICAgICAgICA4XFxuICAgICk7XFxuICAgIHMgPSAxMDAwLjA7IC8vIHNldCBhIGxhcmdlIGluaXRpYWwgZGlzdGFuY2UgZm9yIHVuaW9uXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGgoKTsgaSsrKSB7XFxuICAgICAgICBzID0gc2RmVW5pb24ocywgb2JqZWN0c1tpXSk7XFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNsb3Nlc3Qgb2JqZWN0IGhpdFxcbiAgICAgICAgaWYgKHJlY29yZF9oaXQgJiYgcyA8IGhpdF9pZC5kaXN0KSB7XFxuICAgICAgICAgICAgaGl0X2lkLmRpc3QgPSBzO1xcbiAgICAgICAgICAgIGhpdF9pZC5pZCA9IG9iamVjdF9pZHNbaV07XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHM7XFxufVxcblxcbi8qKiBcXG4gKiBPdmVybG9hZCBzZGYyIHdpdGhvdXQgaGl0X2lkIHVwZGF0ZVxcbiAqIEUuZy4gd2UgZG9uJ3QgbmVlZCB0byBrbm93IHdoYXQgdGhlIG9iamVjdCBpcyBpbiBub3JtYWwgY2FsY3VsYXRpb25cXG4gKi9cXG5mbG9hdCBzZGYyKHZlYzMgcClcXG57XFxuICAgIGJvb2wgcmVjb3JkX2hpdCA9IHRydWU7IC8vIFRPRE86IFNob3VsZCBiZSBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGlmIEkgZGlzYWJsZSBoaXRfaWQgaW4gbm9ybWFsIGNhbGN1bGF0aW9uLCBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgd2lsbCBiZSBhcnRpZmFjdHMgaW4gcmVmbGVjdGlvbi4uLiBEb24ndCBrbm93IHdoeSB5ZXRcXG4gICAgcmV0dXJuIHNkZjIocCwgcmVjb3JkX2hpdCk7XFxufVxcblxcbi8vLy8gcmF5IG1hcmNoaW5nOiBvcmlnaW4gLSByYXkgb3JpZ2luOyBkaXIgLSByYXkgZGlyZWN0aW9uIFxcbmZsb2F0IHJheU1hcmNoaW5nMih2ZWMzIG9yaWdpbiwgdmVjMyBkaXIpXFxue1xcbiAgICBmbG9hdCBzID0gMC4wOyAvLyBkaXN0YW5jZVxcbiAgICBmb3IoaW50IGkgPSAwOyBpIDwgMTAwMDsgaSsrKVxcbiAgICB7XFxuICAgICAgICB2ZWMzIHAgPSBvcmlnaW4gKyBkaXIgKiBzO1xcbiAgICAgICAgZmxvYXQgZGlzdCA9IHNkZjIocCwgdHJ1ZSk7IC8vIHNkZiB2YWx1ZSBpbiBwXFxuICAgICAgICBzICs9IGRpc3Q7IC8vIHVwZGF0ZSB0aGUgZGlzdGFuY2VcXG4gICAgICAgIGlmIChzID4gMjAwLjAgfHwgYWJzKGRpc3QpIDwgMC4wMDAxKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgXFxuICAgIHJldHVybiBzO1xcbn1cXG5cXG4vKipcXG4gKiBOb3JtYWwgY2FsY3VsYXRpb24gZm9yIFNERjIgU2NlbmVcXG4gKiBAcGFyYW0gcDogaW50ZXJzZWN0aW9uIHBvaW50IHF1ZXJ5XFxuICogQHJldHVybiBub3JtOiBub3JtYWwgYXQgdGhlIGludGVyc2VjdGlvbiBwb2ludFxcbiAqL1xcbnZlYzMgbm9ybWFsMih2ZWMzIHApXFxue1xcbiAgICAvLyBmbG9hdCBzID0gc2RmMihwKTsgLy8gc2RmIHZhbHVlIGluIHBcXG4gICAgLy8gZmxvYXQgZHggPSAwLjAxMTsgLy8gQ2FuJ3QgZ2V0IHNtYWxsZXIgdGhhbiB0aGlzLi4gXFxuICAgIC8vICAgICAgICAgICAgICAgICAgIC8vIDAuMDEwIHdpbGwgcHJvZHVjZSB3aXJlZCBhcnRpZmFjdHMgaW4gcmVmbGVjdGlvbi4uLiBEb24ndCBrbm93IHdoeSB5ZXRcXG5cXG4gICAgLy8gdmVjMyBub3JtID0gdmVjMyhcXG4gICAgLy8gICAgIHNkZjIocCArIHZlYzMoZHgsIDAuMCwgMC4wKSkgLSBzLCAvLyBkc3hcXG4gICAgLy8gICAgIHNkZjIocCArIHZlYzMoMC4wLCBkeCwgMC4wKSkgLSBzLCAvLyBkc3lcXG4gICAgLy8gICAgIHNkZjIocCArIHZlYzMoMC4wLCAwLjAsIGR4KSkgLSBzICAvLyBkc3pcXG4gICAgLy8gKTtcXG5cXG4gICAgLy8gaWYgKGhpdF9pZC5pZCA9PSA4KSB7IC8vIFJpdmVyXFxuICAgIC8vICAgICBmbG9hdCBlID0gMC4wMTtcXG4gICAgLy8gICAgIHZlYzIgZXggPSB2ZWMyKGUsIDAuMCk7XFxuICAgIC8vICAgICBmbG9hdCBIID0gZ2V0d2F2ZXMocC54eiwgaW50KElURVJBVElPTlNfV0FWRV9OT1JNQUwpKTtcXG4gICAgLy8gICAgIHZlYzMgYSA9IHZlYzMocC54LCBILCBwLnopO1xcbiAgICAvLyAgICAgdmVjMyBiID0gdmVjMyhwLnggLSBlLCBnZXR3YXZlcyhwLnh6IC0gZXgueHksIGludChJVEVSQVRJT05TX1dBVkVfTk9STUFMKSksIHAueik7XFxuICAgIC8vICAgICB2ZWMzIGMgPSB2ZWMzKHAueCwgZ2V0d2F2ZXMocC54eiArIGV4Lnl4LCBpbnQoSVRFUkFUSU9OU19XQVZFX05PUk1BTCkpLCBwLnogKyBlKTtcXG4gICAgLy8gICAgIHJldHVybiBub3JtYWxpemUoY3Jvc3MoYSAtIGIsIGEgLSBjKSk7XFxuICAgIC8vIH0gZWxzZSB7XFxuICAgIC8vICAgICBmbG9hdCBzID0gc2RmMihwKTtcXG4gICAgLy8gICAgIHZlYzMgbiA9IHZlYzMoXFxuICAgIC8vICAgICAgICAgc2RmMihwICsgdmVjMyhkeCwgMC4wLCAwLjApKSAtIHMsXFxuICAgIC8vICAgICAgICAgc2RmMihwICsgdmVjMygwLjAsIGR4LCAwLjApKSAtIHMsXFxuICAgIC8vICAgICAgICAgc2RmMihwICsgdmVjMygwLjAsIDAuMCwgZHgpKSAtIHNcXG4gICAgLy8gICAgICk7XFxuICAgIC8vICAgICByZXR1cm4gbm9ybWFsaXplKG4pO1xcbiAgICAvLyB9XFxuICAgIC8vIHJldHVybiBub3JtYWxpemUobm9ybSk7XFxuICAgIGZsb2F0IHMgPSBzZGYyKHApO1xcbiAgICBmbG9hdCBkeCA9IDAuMDExO1xcblxcbiAgICBpZiAoaGl0X2lkLmlkID09IDgpIHsgLy8gUml2ZXJcXG4gICAgICAgIGZsb2F0IGUgPSAwLjAxO1xcbiAgICAgICAgdmVjMiBleCA9IHZlYzIoZSwgMC4wKTtcXG4gICAgICAgIGZsb2F0IEggPSBnZXR3YXZlcyhwLnh6LCBpbnQoSVRFUkFUSU9OU19OT1JNQUwpKTtcXG4gICAgICAgIHZlYzMgYSA9IHZlYzMocC54LCBILCBwLnopO1xcbiAgICAgICAgdmVjMyBiID0gdmVjMyhwLnggLSBlLCBnZXR3YXZlcyhwLnh6IC0gZXgueHksIGludChJVEVSQVRJT05TX05PUk1BTCkpLCBwLnopO1xcbiAgICAgICAgdmVjMyBjID0gdmVjMyhwLngsIGdldHdhdmVzKHAueHogKyBleC55eCwgaW50KElURVJBVElPTlNfTk9STUFMKSksIHAueiArIGUpO1xcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShjcm9zcyhhIC0gYiwgYSAtIGMpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIFxcbiAgICAgICAgdmVjMyBuID0gdmVjMyhcXG4gICAgICAgICAgICBzZGYyKHAgKyB2ZWMzKGR4LCAwLjAsIDAuMCkpIC0gcyxcXG4gICAgICAgICAgICBzZGYyKHAgKyB2ZWMzKDAuMCwgZHgsIDAuMCkpIC0gcyxcXG4gICAgICAgICAgICBzZGYyKHAgKyB2ZWMzKDAuMCwgMC4wLCBkeCkpIC0gc1xcbiAgICAgICAgKTtcXG4gICAgICAgIHJldHVybiBub3JtYWxpemUobik7XFxuICAgIH1cXG59XFxuXFxuLyoqXFxuICogQSBDb3B5IG9mIHBob25nX3NoYWRpbmcyIGZvciBoYW5kbGluZyByZWZsZWN0aW9uLlxcbiAqIEJlY2F1c2UgR0xTTCBkb2VzIG5vdCBzdXBwb3J0IHJlY3Vyc2l2ZSBmdW5jdGlvbiBjYWxscy5cXG4gKiBUaGlzIGlzIHdpdGggZnVydGhlciByZWZsZWN0aW9uIHBhcnQgcmVtb3ZlZCBiZWNhdXNlIHdlIGp1c3QgbmVlZCBvbmUgYm91bmNlLlxcbiAqL1xcbnZlYzMgcGhvbmdfc2hhZGluZ19yZWZsZWN0aW9uKHZlYzMgcCwgdmVjMyBuLCB2ZWMzIHJheV9kaXIsIHZlYzMgb3JpZ2luKVxcbntcXG4gICAgLy8vLyBwaG9uZyBzaGFkaW5nXFxuICAgIGZsb2F0IHQgPSBnZXRTeW5jZWRUaW1lQ3ljbGUoKSAqIDMuMDtcXG4gICAgZmxvYXQgYnJpZ2h0bmVzc19zY2FsZSA9IDAuNiArIDAuMjAgKiB0OyAvLyBTdW4gcmlzZSBzaW11bGF0aW9uXFxuICAgIHZlYzMgbGlnaHRQb3MgPSB2ZWMzKDEuMCwgdCArIDUuMCwgMzAuMCk7XFxuICAgIHZlYzMgbGlnaHRfY29sb3IgPSB2ZWMzKDAuODIsIDAuNjcsIDAuNTgpICogMS4yO1xcbiAgICB2ZWMzIGwgPSBub3JtYWxpemUobGlnaHRQb3MgLSBwKTsgICAgICAgICAgICAgICBcXG4gICAgZmxvYXQgYW1iID0gMC4zO1xcbiAgICBmbG9hdCBkaWYgPSBtYXgoZG90KG4sIGwpLCAwLikgKiAwLjY7XFxuICAgIHZlYzMgZXllID0gb3JpZ2luO1xcbiAgICBmbG9hdCBzcGVjID0gcG93KG1heChkb3QocmVmbGVjdCgtbCwgbiksIG5vcm1hbGl6ZShleWUgLSBwKSksIDAuMCksIDEyOC4wKSAqIDAuNztcXG5cXG4gICAgdmVjMyBzdW5EaXIgPSB2ZWMzKDAsIDEsIC0xKTtcXG4gICAgZmxvYXQgc3VuRGlmID0gbWF4KGRvdChuLCBzdW5EaXIpLCAwLikgKiAwLjI7XFxuXFxuICAgIC8vLy8gQ29sb3JpbmdcXG4gICAgZmxvYXQgYmlyYl9icmlnaHRuZXNzID0gMS4yO1xcbiAgICB2ZWMzIGNvbG9yID0gdmVjMygxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgc3dpdGNoIChoaXRfaWQuaWQpIHtcXG4gICAgICAgIGNhc2UgMTogLy8gR3JvdW5kXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDEuMCkgKiAxLjE7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIDI6IC8vIEJpcmIgMVxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjAsIDAuODksIDAuOTcpICogYmlyYl9icmlnaHRuZXNzO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAzOiAvLyBCaXJiIDJcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMS4wLCAwLjYxLCAwLjc4KSAqIGJpcmJfYnJpZ2h0bmVzcztcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgNDogLy8gQmlyYiAzXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDAuOTksIDAuNzksIDAuNjgpICogYmlyYl9icmlnaHRuZXNzO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSA1OiAvLyBCYWNrZ3JvdW5kIFNreVxcbiAgICAgICAgICAgIHZlYzMgY29sb3IxID0gdmVjMygwLjc3LCAwLjY3LCAwLjUzKTtcXG4gICAgICAgICAgICB2ZWMzIGNvbG9yMiA9IHZlYzMoMS4wLCAwLjI1LCAwLjk4KTtcXG4gICAgICAgICAgICBjb2xvciA9IG1peChjb2xvcjEsIGNvbG9yMiwgKHAueSArIDUuMCkgLyAxMDAuMCkgKiBicmlnaHRuZXNzX3NjYWxlO1xcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcXG4gICAgICAgIGNhc2UgNjogLy8gU3VuXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDEuMCwgMC4yOSwgMC4wOSk7XFxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xcbiAgICAgICAgY2FzZSA3OiAvLyBDbG91ZFxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjApO1xcbiAgICAgICAgICAgIHJldHVybiAoYW1iICsgc3VuRGlmICsgMC4yKSAqIGNvbG9yICogbGlnaHRfY29sb3IgKiBicmlnaHRuZXNzX3NjYWxlO1xcbiAgICAgICAgY2FzZSA4OiAvLyBSaXZlclxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygwLjc5LCAwLjg5LCAxLjApO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgZGVmYXVsdDogLy8gVW5leHBlY3RlZCBoaXRfaWQgdmFsdWVzXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDAuMCwgMC4xOCwgMS4wKTsgLy8gQmx1ZSBmb3IgZGVidWdnaW5nIHJlZmxlY3Rpb25cXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XFxuICAgIH1cXG5cXG4gICAgLy8vLyBzaGFkb3dcXG4gICAgZmxvYXQgcyA9IHJheU1hcmNoaW5nMihwICsgbiAqIDAuMDIsIGwpO1xcbiAgICBpZihzIDwgbGVuZ3RoKGxpZ2h0UG9zIC0gcCkpIGRpZiAqPSAuMjsgLy8gc2hhZG93XFxuXFxuICAgIC8vLy8gQmFsYW5jZSB0aGUgY29sb3Igb2YgdGhlIHNjZW5lXFxuICAgIGZsb2F0IGZvZyA9IDEuMCAtIGV4cCgtMC4wMyAqIHAueik7XFxuICAgIHZlYzMgZm9nX2NvbG9yID0gdmVjMygwLjUpO1xcbiAgICBjb2xvciA9IG1peChjb2xvciwgZm9nX2NvbG9yLCBmb2cpO1xcblxcbiAgICByZXR1cm4gKGFtYiArIGRpZiArIHNwZWMgKyBzdW5EaWYpICogYnJpZ2h0bmVzc19zY2FsZSAqIGNvbG9yICogbGlnaHRfY29sb3I7XFxufVxcblxcbi8qKlxcbiAqIFBob25nIFNoYWRpbmcgZm9yIFNERjIgU2NlbmVcXG4gKiBAcGFyYW0gcDogaW50ZXJzZWN0aW9uIHBvaW50XFxuICogQHBhcmFtIG46IG5vcm1hbCBhdCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50XFxuICogQHBhcmFtIHJheV9kaXI6IHJheSBkaXJlY3Rpb25cXG4gKiBAcGFyYW0gb3JpZ2luOiBjYW1lcmEgcG9zaXRpb25cXG4gKiBAcmV0dXJuIGNvbG9yOiBwaG9uZyBzaGFkaW5nIGNvbG9yXFxuICpcXG4gKiBOb3RlOiBBbnkgY2hhbmdlcyB0byB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjb3BpZWQgdG8gcGhvbmdfc2hhZGluZ19yZWZsZWN0aW9uXFxuICovXFxudmVjMyBwaG9uZ19zaGFkaW5nMih2ZWMzIHAsIHZlYzMgbiwgdmVjMyByYXlfZGlyLCB2ZWMzIG9yaWdpbilcXG57XFxuICAgIC8vLy8gcGhvbmcgc2hhZGluZ1xcbiAgICBmbG9hdCB0ID0gZ2V0U3luY2VkVGltZUN5Y2xlKCkgKiAzLjA7XFxuICAgIGZsb2F0IGJyaWdodG5lc3Nfc2NhbGUgPSAwLjYgKyAwLjIwICogdDsgLy8gU3VuIHJpc2Ugc2ltdWxhdGlvblxcbiAgICB2ZWMzIGxpZ2h0UG9zID0gdmVjMygxLjAsIHQgKyA1LjAsIDMwLjApO1xcbiAgICB2ZWMzIGxpZ2h0X2NvbG9yID0gdmVjMygwLjgyLCAwLjY3LCAwLjU4KSAqIDEuMjtcXG4gICAgdmVjMyBsID0gbm9ybWFsaXplKGxpZ2h0UG9zIC0gcCk7ICAgICAgICAgICAgICAgXFxuICAgIGZsb2F0IGFtYiA9IDAuMztcXG4gICAgZmxvYXQgZGlmID0gbWF4KGRvdChuLCBsKSwgMC4pICogMC42O1xcbiAgICB2ZWMzIGV5ZSA9IG9yaWdpbjtcXG4gICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KHJlZmxlY3QoLWwsIG4pLCBub3JtYWxpemUoZXllIC0gcCkpLCAwLjApLCAxMjguMCkgKiAwLjc7XFxuXFxuICAgIHZlYzMgc3VuRGlyID0gdmVjMygwLCAxLCAtMSk7XFxuICAgIGZsb2F0IHN1bkRpZiA9IG1heChkb3Qobiwgc3VuRGlyKSwgMC4pICogMC4yO1xcblxcbiAgICAvLy8vIENvbG9yaW5nXFxuICAgIGZsb2F0IGJpcmJfYnJpZ2h0bmVzcyA9IDEuMjtcXG4gICAgdmVjMyBjb2xvciA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgIHN3aXRjaCAoaGl0X2lkLmlkKSB7XFxuICAgICAgICBjYXNlIDE6IC8vIEdyb3VuZFxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjApICogMS4xO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAyOiAvLyBCaXJiIDFcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMS4wLCAwLjg5LCAwLjk3KSAqIGJpcmJfYnJpZ2h0bmVzcztcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgMzogLy8gQmlyYiAyXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDEuMCwgMC42MSwgMC43OCkgKiBiaXJiX2JyaWdodG5lc3M7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIDQ6IC8vIEJpcmIgM1xcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygwLjk5LCAwLjc5LCAwLjY4KSAqIGJpcmJfYnJpZ2h0bmVzcztcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgNTogLy8gQmFja2dyb3VuZCBTa3lcXG4gICAgICAgICAgICB2ZWMzIGNvbG9yMSA9IHZlYzMoMC43NywgMC42NywgMC41Myk7XFxuICAgICAgICAgICAgdmVjMyBjb2xvcjIgPSB2ZWMzKDEuMCwgMC4yNSwgMC45OCk7XFxuICAgICAgICAgICAgY29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIChwLnkgKyA1LjApIC8gMTAwLjApICogYnJpZ2h0bmVzc19zY2FsZTtcXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XFxuICAgICAgICBjYXNlIDY6IC8vIFN1blxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjAsIDAuMjksIDAuMDkpO1xcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcXG4gICAgICAgIGNhc2UgNzogLy8gQ2xvdWRcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMS4wKTtcXG4gICAgICAgICAgICByZXR1cm4gKGFtYiArIHN1bkRpZiArIDAuMikgKiBjb2xvciAqIGxpZ2h0X2NvbG9yICogYnJpZ2h0bmVzc19zY2FsZTtcXG4gICAgICAgIGNhc2UgODogLy8gUml2ZXJcXG4gICAgICAgICAgICB2ZWMzIHdhdGVyX2NvbG9yID0gdmVjMygwLjc5LCAwLjg5LCAxLjApO1xcbiAgICAgICAgICAgIC8vIFJlZmxlY3Rpb24gb24gd2F0ZXJcXG4gICAgICAgICAgICB2ZWMzIHJlZmxlY3RfZGlyID0gcmVmbGVjdChyYXlfZGlyLCBuKTtcXG4gICAgICAgICAgICBmbG9hdCByZWZsZWN0X3MgPSByYXlNYXJjaGluZzIocCArIG4gKiAwLjAxLCByZWZsZWN0X2Rpcik7XFxuICAgICAgICAgICAgLy8gR2V0IHRoZSByZWZsZWN0aW9uIGNvbG9yXFxuICAgICAgICAgICAgdmVjMyByZWZsZWN0X3AgPSBwICsgcmVmbGVjdF9kaXIgKiByZWZsZWN0X3M7XFxuICAgICAgICAgICAgdmVjMyByZWZsZWN0X24gPSBub3JtYWwyKHJlZmxlY3RfcCk7XFxuICAgICAgICAgICAgdmVjMyByZWZsZWN0X2NvbG9yID0gcGhvbmdfc2hhZGluZ19yZWZsZWN0aW9uKHJlZmxlY3RfcCwgcmVmbGVjdF9uLCByZWZsZWN0X2RpciwgcCk7XFxuICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3RfY29sb3IgKiB3YXRlcl9jb2xvciAqIDAuOTtcXG4gICAgICAgICAgICAvLyBjb2xvciA9IHZlYzMoMC45OSwgMC43OSwgMC42OCk7XFxuICAgICAgICAgICAgLy8gYnJlYWs7XFxuXFxuICAgICAgICBkZWZhdWx0OiAvLyBVbmV4cGVjdGVkIGhpdF9pZCB2YWx1ZXNcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMC4xMywgMS4wLCAwLjApOyAvLyBHcmVlbiBmb3IgZGVidWdnaW5nXFxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xcbiAgICB9XFxuXFxuICAgIC8vLy8gc2hhZG93XFxuICAgIGZsb2F0IHMgPSByYXlNYXJjaGluZzIocCArIG4gKiAwLjAyLCBsKTtcXG4gICAgaWYocyA8IGxlbmd0aChsaWdodFBvcyAtIHApKSBkaWYgKj0gLjI7XFxuXFxuICAgIC8vLy8gQmFsYW5jZSB0aGUgY29sb3Igb2YgdGhlIHNjZW5lXFxuICAgIGZsb2F0IGZvZyA9IDEuMCAtIGV4cCgtMC4wMyAqIHAueik7XFxuICAgIHZlYzMgZm9nX2NvbG9yID0gdmVjMygwLjUpO1xcbiAgICBjb2xvciA9IG1peChjb2xvciwgZm9nX2NvbG9yLCBmb2cpO1xcblxcbiAgICByZXR1cm4gKGFtYiArIGRpZiArIHNwZWMgKyBzdW5EaWYpICogYnJpZ2h0bmVzc19zY2FsZSAqIGNvbG9yICogbGlnaHRfY29sb3I7XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8vLyBtYWluIGZ1bmN0aW9uXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5cXG52b2lkIG1haW5JbWFnZTIob3V0IHZlYzQgZnJhZ0NvbG9yLCBpbiB2ZWMyIGZyYWdDb29yZClcXG57XFxuICAgIHZlYzIgdXYgPSAoZnJhZ0Nvb3JkLnh5IC0gLjUgKiBpUmVzb2x1dGlvbi54eSkgLyBpUmVzb2x1dGlvbi55OyAgICAgICAgICAgLy8vLyBzY3JlZW4gdXZcXG4gICAgXFxuICAgIGZsb2F0IGNhbV9tb3ZlID0gZ2V0U3luY2VkVGltZUN5Y2xlKCk7XFxuICAgIHZlYzMgb3JpZ2luID0gQ0FNX1BPUyArIHZlYzMoMC4wLCAtMC41LCAxLjUpIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyB2ZWMzKDAuMCwgY2FtX21vdmUgKiAwLjMsIC1jYW1fbW92ZSAqIDIuMCk7ICAgICAgICAgIC8vLy8gY2FtZXJhIHBvc2l0aW9uIFxcbiAgICAvLyB2ZWMzIG9yaWdpbiA9IENBTV9QT1M7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gY2FtZXJhIHBvc2l0aW9uXFxuICAgIHZlYzMgZGlyID0gbm9ybWFsaXplKHZlYzModXYueCwgdXYueSwgMSkpOyAgICAgICAgICAgICAgICAgIC8vLy8gY2FtZXJhIGRpcmVjdGlvblxcbiAgICBmbG9hdCBzID0gcmF5TWFyY2hpbmcyKG9yaWdpbiwgZGlyKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyByYXkgbWFyY2hpbmdcXG4gICAgdmVjMyBwID0gb3JpZ2luICsgZGlyICogczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gcmF5LXNkZiBpbnRlcnNlY3Rpb25cXG4gICAgdmVjMyBuID0gbm9ybWFsMihwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gc2RmIG5vcm1hbFxcbiAgICB2ZWMzIGNvbG9yID0gcGhvbmdfc2hhZGluZzIocCwgbiwgZGlyLCBvcmlnaW4pOyAgICAvLy8vIHBob25nIHNoYWRpbmdcXG4gICAgZnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vIGZyYWdtZW50IGNvbG9yXFxufVxcblxcbnZvaWQgbWFpbkltYWdlMShvdXQgdmVjNCBmcmFnQ29sb3IsIGluIHZlYzIgZnJhZ0Nvb3JkKVxcbntcXG4gICAgdmVjMiB1diA9IChmcmFnQ29vcmQueHkgLSAuNSAqIGlSZXNvbHV0aW9uLnh5KSAvIGlSZXNvbHV0aW9uLnk7ICAgICAgICAgICAvLy8vIHNjcmVlbiB1dlxcblxcbiAgICB2ZWMzIG9yaWdpbiA9IENBTV9QT1M7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gY2FtZXJhIHBvc2l0aW9uXFxuICAgIHZlYzMgZGlyID0gbm9ybWFsaXplKHZlYzModXYueCwgdXYueSwgMSkpOyAgICAgICAgICAgICAgICAgIC8vLy8gY2FtZXJhIGRpcmVjdGlvblxcbiAgICBmbG9hdCBzID0gcmF5TWFyY2hpbmcob3JpZ2luLCBkaXIpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vIHJheSBtYXJjaGluZ1xcbiAgICB2ZWMzIHAgPSBvcmlnaW4gKyBkaXIgKiBzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyByYXktc2RmIGludGVyc2VjdGlvblxcbiAgICB2ZWMzIG4gPSBub3JtYWwocCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vIHNkZiBub3JtYWxcXG4gICAgdmVjMyBjb2xvciA9IHBob25nX3NoYWRpbmcocCwgbik7ICAgIC8vLy8gcGhvbmcgc2hhZGluZ1xcbiAgICBmcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gZnJhZ21lbnQgY29sb3JcXG59XFxuXFxudm9pZCBtYWluKCkgXFxue1xcbiAgICAvLy8vLS0tIFVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmUgdG8gcmVuZGVyIHRoZSBCYXNlIFNERjEgc2NlbmUgLS0tLy8vL1xcbiAgICAvLyBtYWluSW1hZ2UxKGdsX0ZyYWdDb2xvciwgZ2xfRnJhZ0Nvb3JkLnh5KTtcXG5cXG4gICAgLy8vLy0tLSBVbmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lIHRvIHJlbmRlciB0aGUgQ3VzdG9tIFNERjIgc2NlbmUgLS0tLy8vL1xcbiAgICBtYWluSW1hZ2UyKGdsX0ZyYWdDb2xvciwgZ2xfRnJhZ0Nvb3JkLnh5KTtcXG59XCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A1a/fragment_water.glsl\n"));

/***/ })

});