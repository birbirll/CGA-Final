"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(assignment)/assignment/A1a/page",{

/***/ "(app-pages-browser)/./src/app/(assignment)/assignment/A1a/fragment.glsl":
/*!***********************************************************!*\
  !*** ./src/app/(assignment)/assignment/A1a/fragment.glsl ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"precision highp float;\\n#define GLSLIFY 1\\n              //// set default precision of float variables to high precision\\n\\nvarying vec2 vUv;                   //// screen uv coordinates (varying, from vertex shader)\\nuniform vec2 iResolution;           //// screen resolution (uniform, from CPU)\\nuniform float iTime;                //// time elapsed (uniform, from CPU)\\n\\nconst vec3 CAM_POS = vec3(-0.35, 1.0, -3.0); //// camera position\\n\\n// Data structure to store current object hit\\nstruct HitID {\\n    float dist;\\n    int id;\\n};\\nHitID hit_id = HitID(2000.0, -1);\\n\\n//// sphere: p - query point; c - sphere center; r - sphere radius\\nfloat sdfSphere(vec3 p, vec3 c, float r)\\n{\\n    return length(p - c) - r;\\n}\\n\\n//// plane: p - query point; h - height\\nfloat sdfPlane(vec3 p, float h)\\n{\\n    return p.y - h;\\n}\\n\\n//// box: p - query point; c - box center; b - box half size (i.e., the box size is (2*b.x, 2*b.y, 2*b.z))\\nfloat sdfBox(vec3 p, vec3 c, vec3 b)\\n{\\n    //// your implementation starts\\n\\n    vec3 d = abs(p - c) - b;\\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\\n    \\n    //// your implementation ends\\n}\\n\\nfloat sdfIntersection(float s1, float s2)\\n{\\n    return max(s1, s2);\\n}\\n\\nfloat sdfUnion(float s1, float s2)\\n{\\n    return min(s1, s2);\\n}\\n\\nfloat sdfSubtraction(float s1, float s2)\\n{\\n    return max(s1, -s2);\\n}\\n\\n/**\\n * Return a float value between 0.0(0s) and 1.0(10s) that represents a 10s cycle\\n * Used for time-based animations\\n */\\nfloat getSyncedTimeCycle() \\n{\\n    return float(int(iTime * 60.0) % 600) / 600.0; // 10s cycle\\n}\\n\\n/**\\n * SDF for a curvy ground of sin and cos waves\\n * With larger waves for hills and smaller waves for texture\\n * @param p: query point\\n * @param h: height of the ground\\n * @return SDF value\\n */\\nfloat sdfCurvyGround(vec3 p, float h) \\n{\\n    p -= vec3(0.0, 0.0, 0.0);\\n    float wave = 0.3 * sin(0.5 * p.x) * cos(1.0 * p.z); // Hills and Valleys\\n    float texture = 0.02 * sin(40.0 * p.x) * sin(80.0 * p.z); // Texture\\n    return p.y - (h + wave + texture);\\n}\\n\\nfloat sdfUnionSmooth(float s1, float s2, float k)\\n{\\n    return -k * log(exp(-s1 / k) + exp(-s2 / k));\\n}\\n\\nfloat sdfSubtractionSmooth(float s1, float s2, float k)\\n{\\n    return -sdfUnionSmooth(-s1, s2, k);\\n}\\n\\nfloat sdfEllipsoid(vec3 p, vec3 c, vec3 r)\\n{\\n    p = p - c;\\n    float k0 = length(p / r);\\n    float k1 = length(p / (r * r));\\n    return k0 * (k0 - 1.0) / k1;\\n}\\n\\n/**\\n * Rotate a point around a center point with given angles\\n * @param p: point to rotate\\n * @param c: center point\\n * @param angles: rotation angles in degrees\\n * @return rotated point\\n */\\nvec3 rotateXYZ(vec3 p, vec3 c, vec3 angles)\\n{   \\n    p -= c; // Translate to origin\\n    angles = radians(angles);\\n    float c1 = cos(angles.x), s1 = sin(angles.x);\\n    float c2 = cos(angles.y), s2 = sin(angles.y);\\n    float c3 = cos(angles.z), s3 = sin(angles.z);\\n\\n    mat3 m = mat3(\\n        c1 * c3 + s1 * s2 * s3, c2 * s3, -s1 * c3 + c1 * s2 * s3,\\n        -c1 * s3 + s1 * s2 * c3, c2 * c3, s1 * s3 + c1 * s2 * c3,\\n        s1 * c2, -s2, c1 * c2\\n    );\\n\\n    return m * p + c; // Rotate and translate back\\n}\\n\\nfloat sdfBorb(vec3 p, vec3 c, float angle, bool birbHair)\\n{\\n    \\n    // Rotate around the Y-axis\\n    float birb_move1 = 3.0 * sin(iTime * 3.0);\\n    float birb_move2 = 3.0 * cos(iTime * 1.0);\\n    vec3 local_p = rotateXYZ(p, c, vec3(angle, birb_move1, birb_move2));\\n\\n    // Define the borb components\\n    float r = 0.2;\\n    vec3 head_c  = c + r * vec3(-0.1, 1.5, 0.0);\\n    vec3 body_c  = c + r * vec3(0.0, 0.0, 0.0);\\n    vec3 tail_c  = c + r * vec3(1.5, -0.3, 0.0);\\n    vec3 wingL_c = c + r * vec3(0.0, 0.1, -1.0);\\n    vec3 wingR_c = c + r * vec3(0.0, 0.1, 1.0);\\n    vec3 peak_c  = c + r * vec3(-1.2, 1.4, 0.0);\\n    vec3 eyeL_c  = c + r * vec3(-0.7, 1.6, -0.95);\\n    vec3 eyeR_c  = c + r * vec3(-0.7, 1.6, 0.95);\\n    vec3 hair1_c = c + r * vec3(-0.5, 2.6, 0.0);\\n    vec3 hair2_c = c + r * vec3(-0.45, 2.7, -0.2);\\n    vec3 hair3_c = c + r * vec3(-0.45, 2.7, 0.2);\\n\\n    // Compute SDF for each part\\n    float head = sdfSphere(local_p, head_c, 0.9 * r);\\n    float body = sdfSphere(local_p, body_c, 1.3 * r);\\n    float tail = sdfEllipsoid(local_p, tail_c, vec3(1.2 * r, 0.6 * r, 0.6 * r));\\n    vec3 local_p_wing = rotateXYZ(local_p, wingL_c, vec3(0.0, 0.0, -20.0));\\n    float wingL = sdfEllipsoid(local_p_wing, wingL_c, vec3(0.6 * r, 1.0 * r, 1.0 * r));\\n    float wingR = sdfEllipsoid(local_p_wing, wingR_c, vec3(0.6 * r, 1.0 * r, 1.0 * r));\\n    float peak = sdfEllipsoid(local_p, peak_c, vec3(0.25 * r, 0.4 * r, 0.2 * r));\\n    float eyeL = sdfSphere(local_p, eyeL_c, 0.15 * r);\\n    float eyeR = sdfSphere(local_p, eyeR_c, 0.15 * r);\\n\\n    vec3 local_p_hair = rotateXYZ(local_p, hair1_c, vec3(0.0, 0.0, 30.0));\\n    float hair1 = sdfEllipsoid(local_p_hair, hair1_c, vec3(0.08, 0.3, 0.2) * r * 1.7);\\n    local_p_hair = rotateXYZ(local_p, hair1_c, vec3(0.0, 45.0, 30.0));\\n    float hair2 = sdfEllipsoid(local_p_hair, hair2_c, vec3(0.08, 0.3, 0.2) * r * 1.7);\\n    local_p_hair = rotateXYZ(local_p, hair1_c, vec3(0.0, -45.0, 30.0));\\n    float hair3 = sdfEllipsoid(local_p_hair, hair3_c, vec3(0.08, 0.3, 0.2) * r * 1.7);\\n\\n    // Combine the parts smoothly\\n    body = sdfUnionSmooth(sdfUnionSmooth(head, body, .1), tail, .1);\\n    float wings = sdfUnion(wingL, wingR);\\n    body = sdfUnion(body, peak);\\n    body = sdfSubtraction(body, eyeL);\\n    body = sdfSubtraction(body, eyeR);\\n    \\n    if (birbHair) {\\n        float hair = sdfUnion(sdfUnion(hair1, hair2), hair3);\\n        body = sdfUnionSmooth(body, hair, .01);\\n    }   \\n    return sdfUnion(body, wings);\\n}\\n\\nfloat sdfCloud(vec3 p, vec3 c)\\n{\\n    float r = 0.8;\\n    float space = 0.8;\\n    float s1 = sdfSphere(p, c, r);\\n    float s2 = sdfSphere(p, c + r * vec3(1, 1.4, 0.0) * space, r);\\n    float s3 = sdfSphere(p, c + r * vec3(2, 0.0, 0.0) * space, r);\\n    float s4 = sdfSphere(p, c + r * vec3(3, 1.4, 0.0) * space, r);\\n    float s5 = sdfSphere(p, c + r * vec3(4, 0.0, 0.0) * space, r);\\n    // return sdfUnion(sdfUnion(sdfUnion(sdfUnion(s1, s2), s3), s4), s5);\\n    return sdfUnionSmooth(sdfUnionSmooth(sdfUnionSmooth(sdfUnionSmooth(s1, s2, 0.1), s3, 0.1), s4, 0.1), s5, 0.1);\\n}\\n\\nfloat sdfRiver(vec3 p)\\n{\\n    float riverbody = sdfBox(p, vec3(0.0, -0.65, 0.0), vec3(2.0, 0.1, 100.0));\\n    float t = getSyncedTimeCycle();\\n    float wave = 0.0015 * cos(8.0 * p.z - t * 15.0); // Curvy wave effect\\n    return riverbody + wave;\\n}\\n\\n//// sdf2: p - query point\\nfloat sdf2(vec3 p, bool record_hit)\\n{\\n    float s = 0.;\\n\\n    // Calculate the SDF for each 5 objects\\n    float ground = sdfCurvyGround(p, -0.1);\\n    float mountain1 = sdfSphere(p, vec3(-5.0, -1.0, 20.0), 2.0);\\n    float mountain2 = sdfSphere(p, vec3(-10.0, -1.5, 30.0), 4.0);\\n    float mountain3 = sdfSphere(p, vec3(-15.0, -2.0, 25.0), 6.0);\\n    float mountain4 = sdfSphere(p, vec3(-7.0, -1.0, 15.0), 2.0);\\n    float mountain5 = sdfSphere(p, vec3(10.0, -1.0, 20.0), 2.0);\\n    float mountain6 = sdfSphere(p, vec3(13.0, -2.0, 15.0), 4.0);\\n    ground = sdfUnionSmooth(ground, mountain1, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain2, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain3, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain4, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain5, 0.5);\\n    ground = sdfUnionSmooth(ground, mountain6, 0.5);\\n\\n    // change p for riverbed with respect to p.z\\n    vec3 riverbed_p = p + vec3(sin(p.z * 0.2), 0.0, 0.0);\\n    float riverbed = sdfBox(riverbed_p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.5, 100.0));\\n    ground = sdfSubtractionSmooth(ground, riverbed, 0.5);\\n    float riverbody = sdfRiver(p);\\n\\n    float birb_move = 0.03 * sin(iTime / 2.0);\\n    float birb1 = sdfBorb(p, vec3(0.5, -0.4 - 0.2 + birb_move, -0.65 + 1.), -80.0, true);\\n    float birb2 = sdfBorb(p, vec3(-0.2, -0.3 - 0.2 + birb_move, 0.0 + 1.), 160.0, true);\\n    float birb3 = sdfBorb(p, vec3(0.6, -0.3 - 0.2 + birb_move, 0.5 + 1.), 40.0 , true);\\n\\n    float background = sdfBox(p, vec3(0.0, 0.0, 50.0), vec3(100.0, 100.0, 1.0));\\n\\n    // float sun_move = float(int(iTime * 60.0) % 600) / 240.0;\\n    float sun_move = getSyncedTimeCycle() * 3.0;\\n    float sun = sdfSphere(p, vec3(1.0, sun_move, 50.0), 2.5);\\n    \\n    // float cloud_move = 0.2 * sin(iTime / 1.0);\\n    // float cloud1 = sdfCloud(p, vec3(-10.0, 10.0, 20.0) + vec3(0.0, cloud_move, 0.0));\\n    // float cloud2 = sdfCloud(p, vec3(-15.0, 4.0, 15.0) + vec3(0.0, -cloud_move, 0.0));\\n    // float cloud3 = sdfCloud(p, vec3(12.0, 5.0, 17.0) + vec3(0.0, cloud_move, 0.0));\\n    // float cloud4 = sdfCloud(p, vec3(3.0, 10.0, 20.0) + vec3(0.0, -cloud_move, 0.0));\\n    // float cloud5 = sdfCloud(p, vec3(8.0, 3.0, 15.0) + vec3(0.0, cloud_move, 0.0));\\n    // float cloud6 = sdfCloud(p, vec3(10.0, 7.0, 30.0) + vec3(0.0, -cloud_move, 0.0));\\n    // float cloud7 = sdfCloud(p, vec3(-3.0, 8.0, 40.0) + vec3(0.0, cloud_move, 0.0));\\n    float cloud = sdfCloud(p, vec3(-10.0, 10.0, 20.0) + vec3(0.0, sun_move * 0.5, 0.0));\\n\\n    // Combine the SDF for all objects\\n    float objects[] = float[](\\n        ground,\\n        birb1,\\n        birb2, \\n        birb3,\\n        background,\\n        sun,\\n        cloud,\\n        riverbody\\n    );\\n    // Assign object ids for coloring\\n    int object_ids[] = int[](\\n        1,\\n        2,\\n        3, \\n        4,\\n        5,\\n        6,\\n        7,\\n        8\\n    );\\n    s = 1000.0; // set a large initial distance for union\\n    for (int i = 0; i < objects.length(); i++) {\\n        s = sdfUnion(s, objects[i]);\\n        // Record the closest object hit\\n        if (record_hit && s < hit_id.dist) {\\n            hit_id.dist = s;\\n            hit_id.id = object_ids[i];\\n        }\\n    }\\n\\n    return s;\\n}\\n\\n/** \\n * Overload sdf2 without hit_id update\\n * E.g. we don't need to know what the object is in normal calculation\\n */\\nfloat sdf2(vec3 p)\\n{\\n    bool record_hit = true; // TODO: Should be false,\\n                            // but if I disable hit_id in normal calculation, \\n                            // there will be artifacts in reflection... Don't know why yet\\n    return sdf2(p, record_hit);\\n}\\n\\n//// ray marching: origin - ray origin; dir - ray direction \\nfloat rayMarching2(vec3 origin, vec3 dir)\\n{\\n    float s = 0.0; // distance\\n    for(int i = 0; i < 1000; i++)\\n    {\\n        vec3 p = origin + dir * s;\\n        float dist = sdf2(p, true); // sdf value in p\\n        s += dist; // update the distance\\n        if (s > 200.0 || abs(dist) < 0.0001) {\\n            break;\\n        }\\n    }\\n    \\n    return s;\\n}\\n\\n// Cloud shader\\n{\\n    mat3 m = mat3( 0.00,  0.80,  0.60,\\n                -0.80,  0.36, -0.48,\\n                -0.60, -0.48,  0.64 );\\n    float hash( float n )\\n    {\\n        return fract(sin(n)*43758.5453);\\n    }\\n\\n    float noise( in vec3 x )\\n    {\\n        vec3 p = floor(x);\\n        vec3 f = fract(x);\\n\\n        f = f*f*(3.0-2.0*f);\\n\\n        float n = p.x + p.y*57.0 + 113.0*p.z;\\n\\n        float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n                            mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\\n                        mix(mix( hash(n+113.0), hash(n+114.0),f.x),\\n                            mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\\n        return res;\\n    }\\n\\n    float fbm( vec3 p )\\n    {\\n        float f;\\n        f  = 0.5000*noise( p ); p = m*p*2.02;\\n        f += 0.2500*noise( p ); p = m*p*2.03;\\n        f += 0.12500*noise( p ); p = m*p*2.01;\\n        f += 0.06250*noise( p );\\n        return f;\\n    }\\n    /////////////////////////////////////\\n\\n    // iq's smin\\n    float smin( float d1, float d2, float k ) {\\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\\n\\n    float sdTorus( vec3 p, vec2 t )\\n    {\\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\\n    return length(q)-t.y;\\n    }\\n\\n    float map( in vec3 p )\\n    {\\n        p *= 2.0;\\n        vec3 q = p - vec3(0.0,0.5,1.0)*iTime;\\n        float f = fbm(q);\\n        float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\\n\\n        return min(max(0.0, torus), 1.0);\\n    }\\n\\n    float jitter;\\n\\n    #define MAX_STEPS 48\\n    #define SHADOW_STEPS 8\\n    #define VOLUME_LENGTH 15.\\n    #define SHADOW_LENGTH 2.\\n\\n    // Reference\\n    // https://shaderbits.com/blog/creating-volumetric-ray-marcher\\n    vec4 cloudMarch(vec3 p, vec3 ray)\\n    {\\n        float density = 0.;\\n\\n        float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\\n        float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\\n        vec3 light = normalize(vec3(1.0, 2.0, 1.0));\\n\\n        vec4 sum = vec4(0., 0., 0., 1.);\\n        \\n        vec3 pos = p + ray * jitter * stepLength;\\n        \\n        for (int i = 0; i < MAX_STEPS; i++)\\n        {\\n            if (sum.a < 0.1) {\\n                break;\\n            }\\n            float d = map(pos);\\n        \\n            if( d > 0.001)\\n            {\\n                vec3 lpos = pos + light * jitter * shadowStepLength;\\n                float shadow = 0.;\\n        \\n                for (int s = 0; s < SHADOW_STEPS; s++)\\n                {\\n                    lpos += light * shadowStepLength;\\n                    float lsample = map(lpos);\\n                    shadow += lsample;\\n                }\\n        \\n                density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\\n                float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\\n                sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\\n                sum.a *= 1.-density;\\n\\n                sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\\n            }\\n            pos += ray * stepLength;\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Normal calculation for SDF2 Scene\\n * @param p: intersection point query\\n * @return norm: normal at the intersection point\\n */\\nvec3 normal2(vec3 p)\\n{\\n    float s = sdf2(p); // sdf value in p\\n    float dx = 0.011; // Can't get smaller than this.. \\n                      // 0.010 will produce wired artifacts in reflection... Don't know why yet\\n\\n    vec3 norm = vec3(\\n        sdf2(p + vec3(dx, 0.0, 0.0)) - s, // dsx\\n        sdf2(p + vec3(0.0, dx, 0.0)) - s, // dsy\\n        sdf2(p + vec3(0.0, 0.0, dx)) - s  // dsz\\n    );\\n    return normalize(norm);\\n}\\n\\n/**\\n * A Copy of phong_shading2 for handling reflection.\\n * Because GLSL does not support recursive function calls.\\n * This is with further reflection part removed because we just need one bounce.\\n */\\nvec3 phong_shading_reflection(vec3 p, vec3 n, vec3 ray_dir, vec3 origin)\\n{\\n    //// phong shading\\n    float t = getSyncedTimeCycle() * 3.0;\\n    float brightness_scale = 0.6 + 0.20 * t; // Sun rise simulation\\n    vec3 lightPos = vec3(1.0, t + 5.0, 30.0);\\n    vec3 light_color = vec3(0.82, 0.67, 0.58) * 1.2;\\n    vec3 l = normalize(lightPos - p);               \\n    float amb = 0.3;\\n    float dif = max(dot(n, l), 0.) * 0.6;\\n    vec3 eye = origin;\\n    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.7;\\n\\n    vec3 sunDir = vec3(0, 1, -1);\\n    float sunDif = max(dot(n, sunDir), 0.) * 0.2;\\n\\n    //// Coloring\\n    float birb_brightness = 1.2;\\n    vec3 color = vec3(1.0, 1.0, 1.0);\\n\\n    switch (hit_id.id) {\\n        case 1: // Ground\\n            color = vec3(1.0) * 1.1;\\n            break;\\n        case 2: // Birb 1\\n            color = vec3(1.0, 0.89, 0.97) * birb_brightness;\\n            break;\\n        case 3: // Birb 2\\n            color = vec3(1.0, 0.61, 0.78) * birb_brightness;\\n            break;\\n        case 4: // Birb 3\\n            color = vec3(0.99, 0.79, 0.68) * birb_brightness;\\n            break;\\n        case 5: // Background Sky\\n            vec3 color1 = vec3(0.77, 0.67, 0.53);\\n            vec3 color2 = vec3(1.0, 0.25, 0.98);\\n            color = mix(color1, color2, (p.y + 5.0) / 100.0) * brightness_scale;\\n            return color;\\n        case 6: // Sun\\n            color = vec3(1.0, 0.29, 0.09);\\n            return color;\\n        case 7: // Cloud\\n            color = vec3(1.0);\\n            return (amb + sunDif + 0.2) * color * light_color * brightness_scale;\\n        case 8: // River\\n            color = vec3(0.79, 0.89, 1.0);\\n            break;\\n\\n        default: // Unexpected hit_id values\\n            color = vec3(0.0, 0.18, 1.0); // Blue for debugging reflection\\n            return color;\\n    }\\n\\n    //// shadow\\n    float s = rayMarching2(p + n * 0.02, l);\\n    if(s < length(lightPos - p)) dif *= .2; // shadow\\n\\n    //// Balance the color of the scene\\n    float fog = 1.0 - exp(-0.03 * p.z);\\n    vec3 fog_color = vec3(0.5);\\n    color = mix(color, fog_color, fog);\\n\\n    return (amb + dif + spec + sunDif) * brightness_scale * color * light_color;\\n}\\n\\n/**\\n * Phong Shading for SDF2 Scene\\n * @param p: intersection point\\n * @param n: normal at the intersection point\\n * @param ray_dir: ray direction\\n * @param origin: camera position\\n * @return color: phong shading color\\n *\\n * Note: Any changes to this function should be copied to phong_shading_reflection\\n */\\nvec3 phong_shading2(vec3 p, vec3 n, vec3 ray_dir, vec3 origin)\\n{\\n    //// phong shading\\n    float t = getSyncedTimeCycle() * 3.0;\\n    float brightness_scale = 0.6 + 0.20 * t; // Sun rise simulation\\n    vec3 lightPos = vec3(1.0, t + 5.0, 30.0);\\n    vec3 light_color = vec3(0.82, 0.67, 0.58) * 1.2;\\n    vec3 l = normalize(lightPos - p);               \\n    float amb = 0.3;\\n    float dif = max(dot(n, l), 0.) * 0.6;\\n    vec3 eye = origin;\\n    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.7;\\n\\n    vec3 sunDir = vec3(0, 1, -1);\\n    float sunDif = max(dot(n, sunDir), 0.) * 0.2;\\n\\n    //// Cloud marching\\n    vec4 cloud_color = cloudMarch(p, ray_dir);\\n    if (hit_id.id == 7) {\\n        return cloud_color.rgb * light_color * brightness_scale;\\n    }\\n\\n    //// Coloring\\n    float birb_brightness = 1.2;\\n    vec3 color = vec3(1.0, 1.0, 1.0);\\n\\n    switch (hit_id.id) {\\n        case 1: // Ground\\n            color = vec3(1.0) * 1.1;\\n            break;\\n        case 2: // Birb 1\\n            color = vec3(1.0, 0.89, 0.97) * birb_brightness;\\n            break;\\n        case 3: // Birb 2\\n            color = vec3(1.0, 0.61, 0.78) * birb_brightness;\\n            break;\\n        case 4: // Birb 3\\n            color = vec3(0.99, 0.79, 0.68) * birb_brightness;\\n            break;\\n        case 5: // Background Sky\\n            vec3 color1 = vec3(0.77, 0.67, 0.53);\\n            vec3 color2 = vec3(1.0, 0.25, 0.98);\\n            color = mix(color1, color2, (p.y + 5.0) / 100.0) * brightness_scale;\\n            return color;\\n        case 6: // Sun\\n            color = vec3(1.0, 0.29, 0.09);\\n            return color;\\n        case 7: // Cloud\\n            color = vec3(1.0);\\n            return (amb + sunDif + 0.2) * color * light_color * brightness_scale;\\n            // break;\\n        case 8: // River\\n            vec3 water_color = vec3(0.79, 0.89, 1.0);\\n            // Reflection on water\\n            vec3 reflect_dir = reflect(ray_dir, n);\\n            float reflect_s = rayMarching2(p + n * 0.01, reflect_dir);\\n            // Get the reflection color\\n            vec3 reflect_p = p + reflect_dir * reflect_s;\\n            vec3 reflect_n = normal2(reflect_p);\\n            vec3 reflect_color = phong_shading_reflection(reflect_p, reflect_n, reflect_dir, p);\\n            return reflect_color * water_color * 0.9;\\n\\n        default: // Unexpected hit_id values\\n            color = vec3(0.13, 1.0, 0.0); // Green for debugging\\n            return color;\\n    }\\n\\n    //// shadow\\n    float s = rayMarching2(p + n * 0.02, l);\\n    if(s < length(lightPos - p)) dif *= .2;\\n\\n    //// Balance the color of the scene\\n    float fog = 1.0 - exp(-0.03 * p.z);\\n    vec3 fog_color = vec3(0.5);\\n    color = mix(color, fog_color, fog);\\n\\n    return (amb + dif + spec + sunDif) * brightness_scale * color * light_color;\\n}\\n\\n/////////////////////////////////////////////////////\\n//// main function\\n/////////////////////////////////////////////////////\\n\\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord)\\n{\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;           //// screen uv\\n    \\n    float cam_move = getSyncedTimeCycle();\\n    vec3 origin = CAM_POS + vec3(0.0, -0.5, 1.5) \\n                          + vec3(0.0, cam_move * 0.3, -cam_move * 2.0);          //// camera position \\n    // vec3 origin = CAM_POS;                                                 //// camera position\\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));                  //// camera direction\\n    float s = rayMarching2(origin, dir);                     //// ray marching\\n    vec3 p = origin + dir * s;                                               //// ray-sdf intersection\\n    vec3 n = normal2(p);                                         //// sdf normal\\n    \\n    // // if objectID is cloud, use cloud marching\\n    // if (hit_id.id == 7) {\\n    //     fragColor = vec4(1.0, 1.0, 1.0, 1.0); // White for cloud\\n    //     return;\\n    // }\\n\\n    jitter = 1.0;\\n    \\n    vec3 color = phong_shading2(p, n, dir, origin);    //// phong shading\\n    fragColor = vec4(color, 1.);                                     //// fragment color\\n}\\n\\nvoid main() \\n{\\n    mainImage2(gl_FragColor, gl_FragCoord.xy);\\n}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGFzc2lnbm1lbnQpL2Fzc2lnbm1lbnQvQTFhL2ZyYWdtZW50Lmdsc2wiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLHVCQUF1QiwwSUFBMEksOEZBQThGLGdGQUFnRixzRkFBc0YscUZBQXFGLGlCQUFpQixhQUFhLElBQUksbUNBQW1DLGtDQUFrQyxtQkFBbUIsOERBQThELCtCQUErQixHQUFHLGlDQUFpQyw4Q0FBOEMscUJBQXFCLEdBQUcsK0JBQStCLGdCQUFnQix3R0FBd0cscUVBQXFFLHFFQUFxRSw0Q0FBNEMsZ0RBQWdELHlCQUF5QixHQUFHLHlDQUF5Qyx5QkFBeUIsR0FBRywrQ0FBK0MsMEJBQTBCLEdBQUcsaUtBQWlLLHFEQUFxRCxlQUFlLHdQQUF3UCwrQkFBK0IsMERBQTBELG9GQUFvRixrREFBa0QsR0FBRyx3REFBd0QsbURBQW1ELEdBQUcsOERBQThELHlDQUF5QyxHQUFHLGlEQUFpRCxnQkFBZ0IsK0JBQStCLHFDQUFxQyxrQ0FBa0MsR0FBRywyUEFBMlAsY0FBYyxxREFBcUQsbURBQW1ELG1EQUFtRCxtREFBbUQsbU1BQW1NLDBCQUEwQiwrQkFBK0IsZ0VBQWdFLHVGQUF1RixnREFBZ0QsMEVBQTBFLHlEQUF5RCxrREFBa0QsaURBQWlELGtEQUFrRCxrREFBa0QsaURBQWlELGtEQUFrRCxvREFBb0QsbURBQW1ELGtEQUFrRCxvREFBb0QsbURBQW1ELDJGQUEyRix1REFBdUQsa0ZBQWtGLDZFQUE2RSx5RkFBeUYseUZBQXlGLG1GQUFtRix3REFBd0Qsd0RBQXdELDhFQUE4RSx3RkFBd0Ysd0VBQXdFLHdGQUF3Rix5RUFBeUUsd0ZBQXdGLDJHQUEyRywyQ0FBMkMsa0NBQWtDLHdDQUF3Qyx3Q0FBd0MsMkJBQTJCLCtEQUErRCxpREFBaUQsVUFBVSxtQ0FBbUMsR0FBRyxxQ0FBcUMsb0JBQW9CLHdCQUF3QixvQ0FBb0Msb0VBQW9FLG9FQUFvRSxvRUFBb0Usb0VBQW9FLDJFQUEyRSxvSEFBb0gs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LHlGQUF5RixzQkFBc0IsbUJBQW1CLGdEQUFnRCxHQUFHLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC8oYXNzaWdubWVudCkvYXNzaWdubWVudC9BMWEvZnJhZ21lbnQuZ2xzbD81YjZiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgICAgICAgICAvLy8vIHNldCBkZWZhdWx0IHByZWNpc2lvbiBvZiBmbG9hdCB2YXJpYWJsZXMgdG8gaGlnaCBwcmVjaXNpb25cXG5cXG52YXJ5aW5nIHZlYzIgdlV2OyAgICAgICAgICAgICAgICAgICAvLy8vIHNjcmVlbiB1diBjb29yZGluYXRlcyAodmFyeWluZywgZnJvbSB2ZXJ0ZXggc2hhZGVyKVxcbnVuaWZvcm0gdmVjMiBpUmVzb2x1dGlvbjsgICAgICAgICAgIC8vLy8gc2NyZWVuIHJlc29sdXRpb24gKHVuaWZvcm0sIGZyb20gQ1BVKVxcbnVuaWZvcm0gZmxvYXQgaVRpbWU7ICAgICAgICAgICAgICAgIC8vLy8gdGltZSBlbGFwc2VkICh1bmlmb3JtLCBmcm9tIENQVSlcXG5cXG5jb25zdCB2ZWMzIENBTV9QT1MgPSB2ZWMzKC0wLjM1LCAxLjAsIC0zLjApOyAvLy8vIGNhbWVyYSBwb3NpdGlvblxcblxcbi8vIERhdGEgc3RydWN0dXJlIHRvIHN0b3JlIGN1cnJlbnQgb2JqZWN0IGhpdFxcbnN0cnVjdCBIaXRJRCB7XFxuICAgIGZsb2F0IGRpc3Q7XFxuICAgIGludCBpZDtcXG59O1xcbkhpdElEIGhpdF9pZCA9IEhpdElEKDIwMDAuMCwgLTEpO1xcblxcbi8vLy8gc3BoZXJlOiBwIC0gcXVlcnkgcG9pbnQ7IGMgLSBzcGhlcmUgY2VudGVyOyByIC0gc3BoZXJlIHJhZGl1c1xcbmZsb2F0IHNkZlNwaGVyZSh2ZWMzIHAsIHZlYzMgYywgZmxvYXQgcilcXG57XFxuICAgIHJldHVybiBsZW5ndGgocCAtIGMpIC0gcjtcXG59XFxuXFxuLy8vLyBwbGFuZTogcCAtIHF1ZXJ5IHBvaW50OyBoIC0gaGVpZ2h0XFxuZmxvYXQgc2RmUGxhbmUodmVjMyBwLCBmbG9hdCBoKVxcbntcXG4gICAgcmV0dXJuIHAueSAtIGg7XFxufVxcblxcbi8vLy8gYm94OiBwIC0gcXVlcnkgcG9pbnQ7IGMgLSBib3ggY2VudGVyOyBiIC0gYm94IGhhbGYgc2l6ZSAoaS5lLiwgdGhlIGJveCBzaXplIGlzICgyKmIueCwgMipiLnksIDIqYi56KSlcXG5mbG9hdCBzZGZCb3godmVjMyBwLCB2ZWMzIGMsIHZlYzMgYilcXG57XFxuICAgIC8vLy8geW91ciBpbXBsZW1lbnRhdGlvbiBzdGFydHNcXG5cXG4gICAgdmVjMyBkID0gYWJzKHAgLSBjKSAtIGI7XFxuICAgIHJldHVybiBsZW5ndGgobWF4KGQsIDAuMCkpICsgbWluKG1heChkLngsIG1heChkLnksIGQueikpLCAwLjApO1xcbiAgICBcXG4gICAgLy8vLyB5b3VyIGltcGxlbWVudGF0aW9uIGVuZHNcXG59XFxuXFxuZmxvYXQgc2RmSW50ZXJzZWN0aW9uKGZsb2F0IHMxLCBmbG9hdCBzMilcXG57XFxuICAgIHJldHVybiBtYXgoczEsIHMyKTtcXG59XFxuXFxuZmxvYXQgc2RmVW5pb24oZmxvYXQgczEsIGZsb2F0IHMyKVxcbntcXG4gICAgcmV0dXJuIG1pbihzMSwgczIpO1xcbn1cXG5cXG5mbG9hdCBzZGZTdWJ0cmFjdGlvbihmbG9hdCBzMSwgZmxvYXQgczIpXFxue1xcbiAgICByZXR1cm4gbWF4KHMxLCAtczIpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCgwcykgYW5kIDEuMCgxMHMpIHRoYXQgcmVwcmVzZW50cyBhIDEwcyBjeWNsZVxcbiAqIFVzZWQgZm9yIHRpbWUtYmFzZWQgYW5pbWF0aW9uc1xcbiAqL1xcbmZsb2F0IGdldFN5bmNlZFRpbWVDeWNsZSgpIFxcbntcXG4gICAgcmV0dXJuIGZsb2F0KGludChpVGltZSAqIDYwLjApICUgNjAwKSAvIDYwMC4wOyAvLyAxMHMgY3ljbGVcXG59XFxuXFxuLyoqXFxuICogU0RGIGZvciBhIGN1cnZ5IGdyb3VuZCBvZiBzaW4gYW5kIGNvcyB3YXZlc1xcbiAqIFdpdGggbGFyZ2VyIHdhdmVzIGZvciBoaWxscyBhbmQgc21hbGxlciB3YXZlcyBmb3IgdGV4dHVyZVxcbiAqIEBwYXJhbSBwOiBxdWVyeSBwb2ludFxcbiAqIEBwYXJhbSBoOiBoZWlnaHQgb2YgdGhlIGdyb3VuZFxcbiAqIEByZXR1cm4gU0RGIHZhbHVlXFxuICovXFxuZmxvYXQgc2RmQ3VydnlHcm91bmQodmVjMyBwLCBmbG9hdCBoKSBcXG57XFxuICAgIHAgLT0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG4gICAgZmxvYXQgd2F2ZSA9IDAuMyAqIHNpbigwLjUgKiBwLngpICogY29zKDEuMCAqIHAueik7IC8vIEhpbGxzIGFuZCBWYWxsZXlzXFxuICAgIGZsb2F0IHRleHR1cmUgPSAwLjAyICogc2luKDQwLjAgKiBwLngpICogc2luKDgwLjAgKiBwLnopOyAvLyBUZXh0dXJlXFxuICAgIHJldHVybiBwLnkgLSAoaCArIHdhdmUgKyB0ZXh0dXJlKTtcXG59XFxuXFxuZmxvYXQgc2RmVW5pb25TbW9vdGgoZmxvYXQgczEsIGZsb2F0IHMyLCBmbG9hdCBrKVxcbntcXG4gICAgcmV0dXJuIC1rICogbG9nKGV4cCgtczEgLyBrKSArIGV4cCgtczIgLyBrKSk7XFxufVxcblxcbmZsb2F0IHNkZlN1YnRyYWN0aW9uU21vb3RoKGZsb2F0IHMxLCBmbG9hdCBzMiwgZmxvYXQgaylcXG57XFxuICAgIHJldHVybiAtc2RmVW5pb25TbW9vdGgoLXMxLCBzMiwgayk7XFxufVxcblxcbmZsb2F0IHNkZkVsbGlwc29pZCh2ZWMzIHAsIHZlYzMgYywgdmVjMyByKVxcbntcXG4gICAgcCA9IHAgLSBjO1xcbiAgICBmbG9hdCBrMCA9IGxlbmd0aChwIC8gcik7XFxuICAgIGZsb2F0IGsxID0gbGVuZ3RoKHAgLyAociAqIHIpKTtcXG4gICAgcmV0dXJuIGswICogKGswIC0gMS4wKSAvIGsxO1xcbn1cXG5cXG4vKipcXG4gKiBSb3RhdGUgYSBwb2ludCBhcm91bmQgYSBjZW50ZXIgcG9pbnQgd2l0aCBnaXZlbiBhbmdsZXNcXG4gKiBAcGFyYW0gcDogcG9pbnQgdG8gcm90YXRlXFxuICogQHBhcmFtIGM6IGNlbnRlciBwb2ludFxcbiAqIEBwYXJhbSBhbmdsZXM6IHJvdGF0aW9uIGFuZ2xlcyBpbiBkZWdyZWVzXFxuICogQHJldHVybiByb3RhdGVkIHBvaW50XFxuICovXFxudmVjMyByb3RhdGVYWVoodmVjMyBwLCB2ZWMzIGMsIHZlYzMgYW5nbGVzKVxcbnsgICBcXG4gICAgcCAtPSBjOyAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXFxuICAgIGFuZ2xlcyA9IHJhZGlhbnMoYW5nbGVzKTtcXG4gICAgZmxvYXQgYzEgPSBjb3MoYW5nbGVzLngpLCBzMSA9IHNpbihhbmdsZXMueCk7XFxuICAgIGZsb2F0IGMyID0gY29zKGFuZ2xlcy55KSwgczIgPSBzaW4oYW5nbGVzLnkpO1xcbiAgICBmbG9hdCBjMyA9IGNvcyhhbmdsZXMueiksIHMzID0gc2luKGFuZ2xlcy56KTtcXG5cXG4gICAgbWF0MyBtID0gbWF0MyhcXG4gICAgICAgIGMxICogYzMgKyBzMSAqIHMyICogczMsIGMyICogczMsIC1zMSAqIGMzICsgYzEgKiBzMiAqIHMzLFxcbiAgICAgICAgLWMxICogczMgKyBzMSAqIHMyICogYzMsIGMyICogYzMsIHMxICogczMgKyBjMSAqIHMyICogYzMsXFxuICAgICAgICBzMSAqIGMyLCAtczIsIGMxICogYzJcXG4gICAgKTtcXG5cXG4gICAgcmV0dXJuIG0gKiBwICsgYzsgLy8gUm90YXRlIGFuZCB0cmFuc2xhdGUgYmFja1xcbn1cXG5cXG5mbG9hdCBzZGZCb3JiKHZlYzMgcCwgdmVjMyBjLCBmbG9hdCBhbmdsZSwgYm9vbCBiaXJiSGFpcilcXG57XFxuICAgIFxcbiAgICAvLyBSb3RhdGUgYXJvdW5kIHRoZSBZLWF4aXNcXG4gICAgZmxvYXQgYmlyYl9tb3ZlMSA9IDMuMCAqIHNpbihpVGltZSAqIDMuMCk7XFxuICAgIGZsb2F0IGJpcmJfbW92ZTIgPSAzLjAgKiBjb3MoaVRpbWUgKiAxLjApO1xcbiAgICB2ZWMzIGxvY2FsX3AgPSByb3RhdGVYWVoocCwgYywgdmVjMyhhbmdsZSwgYmlyYl9tb3ZlMSwgYmlyYl9tb3ZlMikpO1xcblxcbiAgICAvLyBEZWZpbmUgdGhlIGJvcmIgY29tcG9uZW50c1xcbiAgICBmbG9hdCByID0gMC4yO1xcbiAgICB2ZWMzIGhlYWRfYyAgPSBjICsgciAqIHZlYzMoLTAuMSwgMS41LCAwLjApO1xcbiAgICB2ZWMzIGJvZHlfYyAgPSBjICsgciAqIHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuICAgIHZlYzMgdGFpbF9jICA9IGMgKyByICogdmVjMygxLjUsIC0wLjMsIDAuMCk7XFxuICAgIHZlYzMgd2luZ0xfYyA9IGMgKyByICogdmVjMygwLjAsIDAuMSwgLTEuMCk7XFxuICAgIHZlYzMgd2luZ1JfYyA9IGMgKyByICogdmVjMygwLjAsIDAuMSwgMS4wKTtcXG4gICAgdmVjMyBwZWFrX2MgID0gYyArIHIgKiB2ZWMzKC0xLjIsIDEuNCwgMC4wKTtcXG4gICAgdmVjMyBleWVMX2MgID0gYyArIHIgKiB2ZWMzKC0wLjcsIDEuNiwgLTAuOTUpO1xcbiAgICB2ZWMzIGV5ZVJfYyAgPSBjICsgciAqIHZlYzMoLTAuNywgMS42LCAwLjk1KTtcXG4gICAgdmVjMyBoYWlyMV9jID0gYyArIHIgKiB2ZWMzKC0wLjUsIDIuNiwgMC4wKTtcXG4gICAgdmVjMyBoYWlyMl9jID0gYyArIHIgKiB2ZWMzKC0wLjQ1LCAyLjcsIC0wLjIpO1xcbiAgICB2ZWMzIGhhaXIzX2MgPSBjICsgciAqIHZlYzMoLTAuNDUsIDIuNywgMC4yKTtcXG5cXG4gICAgLy8gQ29tcHV0ZSBTREYgZm9yIGVhY2ggcGFydFxcbiAgICBmbG9hdCBoZWFkID0gc2RmU3BoZXJlKGxvY2FsX3AsIGhlYWRfYywgMC45ICogcik7XFxuICAgIGZsb2F0IGJvZHkgPSBzZGZTcGhlcmUobG9jYWxfcCwgYm9keV9jLCAxLjMgKiByKTtcXG4gICAgZmxvYXQgdGFpbCA9IHNkZkVsbGlwc29pZChsb2NhbF9wLCB0YWlsX2MsIHZlYzMoMS4yICogciwgMC42ICogciwgMC42ICogcikpO1xcbiAgICB2ZWMzIGxvY2FsX3Bfd2luZyA9IHJvdGF0ZVhZWihsb2NhbF9wLCB3aW5nTF9jLCB2ZWMzKDAuMCwgMC4wLCAtMjAuMCkpO1xcbiAgICBmbG9hdCB3aW5nTCA9IHNkZkVsbGlwc29pZChsb2NhbF9wX3dpbmcsIHdpbmdMX2MsIHZlYzMoMC42ICogciwgMS4wICogciwgMS4wICogcikpO1xcbiAgICBmbG9hdCB3aW5nUiA9IHNkZkVsbGlwc29pZChsb2NhbF9wX3dpbmcsIHdpbmdSX2MsIHZlYzMoMC42ICogciwgMS4wICogciwgMS4wICogcikpO1xcbiAgICBmbG9hdCBwZWFrID0gc2RmRWxsaXBzb2lkKGxvY2FsX3AsIHBlYWtfYywgdmVjMygwLjI1ICogciwgMC40ICogciwgMC4yICogcikpO1xcbiAgICBmbG9hdCBleWVMID0gc2RmU3BoZXJlKGxvY2FsX3AsIGV5ZUxfYywgMC4xNSAqIHIpO1xcbiAgICBmbG9hdCBleWVSID0gc2RmU3BoZXJlKGxvY2FsX3AsIGV5ZVJfYywgMC4xNSAqIHIpO1xcblxcbiAgICB2ZWMzIGxvY2FsX3BfaGFpciA9IHJvdGF0ZVhZWihsb2NhbF9wLCBoYWlyMV9jLCB2ZWMzKDAuMCwgMC4wLCAzMC4wKSk7XFxuICAgIGZsb2F0IGhhaXIxID0gc2RmRWxsaXBzb2lkKGxvY2FsX3BfaGFpciwgaGFpcjFfYywgdmVjMygwLjA4LCAwLjMsIDAuMikgKiByICogMS43KTtcXG4gICAgbG9jYWxfcF9oYWlyID0gcm90YXRlWFlaKGxvY2FsX3AsIGhhaXIxX2MsIHZlYzMoMC4wLCA0NS4wLCAzMC4wKSk7XFxuICAgIGZsb2F0IGhhaXIyID0gc2RmRWxsaXBzb2lkKGxvY2FsX3BfaGFpciwgaGFpcjJfYywgdmVjMygwLjA4LCAwLjMsIDAuMikgKiByICogMS43KTtcXG4gICAgbG9jYWxfcF9oYWlyID0gcm90YXRlWFlaKGxvY2FsX3AsIGhhaXIxX2MsIHZlYzMoMC4wLCAtNDUuMCwgMzAuMCkpO1xcbiAgICBmbG9hdCBoYWlyMyA9IHNkZkVsbGlwc29pZChsb2NhbF9wX2hhaXIsIGhhaXIzX2MsIHZlYzMoMC4wOCwgMC4zLCAwLjIpICogciAqIDEuNyk7XFxuXFxuICAgIC8vIENvbWJpbmUgdGhlIHBhcnRzIHNtb290aGx5XFxuICAgIGJvZHkgPSBzZGZVbmlvblNtb290aChzZGZVbmlvblNtb290aChoZWFkLCBib2R5LCAuMSksIHRhaWwsIC4xKTtcXG4gICAgZmxvYXQgd2luZ3MgPSBzZGZVbmlvbih3aW5nTCwgd2luZ1IpO1xcbiAgICBib2R5ID0gc2RmVW5pb24oYm9keSwgcGVhayk7XFxuICAgIGJvZHkgPSBzZGZTdWJ0cmFjdGlvbihib2R5LCBleWVMKTtcXG4gICAgYm9keSA9IHNkZlN1YnRyYWN0aW9uKGJvZHksIGV5ZVIpO1xcbiAgICBcXG4gICAgaWYgKGJpcmJIYWlyKSB7XFxuICAgICAgICBmbG9hdCBoYWlyID0gc2RmVW5pb24oc2RmVW5pb24oaGFpcjEsIGhhaXIyKSwgaGFpcjMpO1xcbiAgICAgICAgYm9keSA9IHNkZlVuaW9uU21vb3RoKGJvZHksIGhhaXIsIC4wMSk7XFxuICAgIH0gICBcXG4gICAgcmV0dXJuIHNkZlVuaW9uKGJvZHksIHdpbmdzKTtcXG59XFxuXFxuZmxvYXQgc2RmQ2xvdWQodmVjMyBwLCB2ZWMzIGMpXFxue1xcbiAgICBmbG9hdCByID0gMC44O1xcbiAgICBmbG9hdCBzcGFjZSA9IDAuODtcXG4gICAgZmxvYXQgczEgPSBzZGZTcGhlcmUocCwgYywgcik7XFxuICAgIGZsb2F0IHMyID0gc2RmU3BoZXJlKHAsIGMgKyByICogdmVjMygxLCAxLjQsIDAuMCkgKiBzcGFjZSwgcik7XFxuICAgIGZsb2F0IHMzID0gc2RmU3BoZXJlKHAsIGMgKyByICogdmVjMygyLCAwLjAsIDAuMCkgKiBzcGFjZSwgcik7XFxuICAgIGZsb2F0IHM0ID0gc2RmU3BoZXJlKHAsIGMgKyByICogdmVjMygzLCAxLjQsIDAuMCkgKiBzcGFjZSwgcik7XFxuICAgIGZsb2F0IHM1ID0gc2RmU3BoZXJlKHAsIGMgKyByICogdmVjMyg0LCAwLjAsIDAuMCkgKiBzcGFjZSwgcik7XFxuICAgIC8vIHJldHVybiBzZGZVbmlvbihzZGZVbmlvbihzZGZVbmlvbihzZGZVbmlvbihzMSwgczIpLCBzMyksIHM0KSwgczUpO1xcbiAgICByZXR1cm4gc2RmVW5pb25TbW9vdGgoc2RmVW5pb25TbW9vdGgoc2RmVW5pb25TbW9vdGgoc2RmVW5pb25TbW9vdGgoczEsIHMyLCAwLjEpLCBzMywgMC4xKSwgczQsIDAuMSksIHM1LCAwLjEpO1xcbn1cXG5cXG5mbG9hdCBzZGZSaXZlcih2ZWMzIHApXFxue1xcbiAgICBmbG9hdCByaXZlcmJvZHkgPSBzZGZCb3gocCwgdmVjMygwLjAsIC0wLjY1LCAwLjApLCB2ZWMzKDIuMCwgMC4xLCAxMDAuMCkpO1xcbiAgICBmbG9hdCB0ID0gZ2V0U3luY2VkVGltZUN5Y2xlKCk7XFxuICAgIGZsb2F0IHdhdmUgPSAwLjAwMTUgKiBjb3MoOC4wICogcC56IC0gdCAqIDE1LjApOyAvLyBDdXJ2eSB3YXZlIGVmZmVjdFxcbiAgICByZXR1cm4gcml2ZXJib2R5ICsgd2F2ZTtcXG59XFxuXFxuLy8vLyBzZGYyOiBwIC0gcXVlcnkgcG9pbnRcXG5mbG9hdCBzZGYyKHZlYzMgcCwgYm9vbCByZWNvcmRfaGl0KVxcbntcXG4gICAgZmxvYXQgcyA9IDAuO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIFNERiBmb3IgZWFjaCA1IG9iamVjdHNcXG4gICAgZmxvYXQgZ3JvdW5kID0gc2RmQ3VydnlHcm91bmQocCwgLTAuMSk7XFxuICAgIGZsb2F0IG1vdW50YWluMSA9IHNkZlNwaGVyZShwLCB2ZWMzKC01LjAsIC0xLjAsIDIwLjApLCAyLjApO1xcbiAgICBmbG9hdCBtb3VudGFpbjIgPSBzZGZTcGhlcmUocCwgdmVjMygtMTAuMCwgLTEuNSwgMzAuMCksIDQuMCk7XFxuICAgIGZsb2F0IG1vdW50YWluMyA9IHNkZlNwaGVyZShwLCB2ZWMzKC0xNS4wLCAtMi4wLCAyNS4wKSwgNi4wKTtcXG4gICAgZmxvYXQgbW91bnRhaW40ID0gc2RmU3BoZXJlKHAsIHZlYzMoLTcuMCwgLTEuMCwgMTUuMCksIDIuMCk7XFxuICAgIGZsb2F0IG1vdW50YWluNSA9IHNkZlNwaGVyZShwLCB2ZWMzKDEwLjAsIC0xLjAsIDIwLjApLCAyLjApO1xcbiAgICBmbG9hdCBtb3VudGFpbjYgPSBzZGZTcGhlcmUocCwgdmVjMygxMy4wLCAtMi4wLCAxNS4wKSwgNC4wKTtcXG4gICAgZ3JvdW5kID0gc2RmVW5pb25TbW9vdGgoZ3JvdW5kLCBtb3VudGFpbjEsIDAuNSk7XFxuICAgIGdyb3VuZCA9IHNkZlVuaW9uU21vb3RoKGdyb3VuZCwgbW91bnRhaW4yLCAwLjUpO1xcbiAgICBncm91bmQgPSBzZGZVbmlvblNtb290aChncm91bmQsIG1vdW50YWluMywgMC41KTtcXG4gICAgZ3JvdW5kID0gc2RmVW5pb25TbW9vdGgoZ3JvdW5kLCBtb3VudGFpbjQsIDAuNSk7XFxuICAgIGdyb3VuZCA9IHNkZlVuaW9uU21vb3RoKGdyb3VuZCwgbW91bnRhaW41LCAwLjUpO1xcbiAgICBncm91bmQgPSBzZGZVbmlvblNtb290aChncm91bmQsIG1vdW50YWluNiwgMC41KTtcXG5cXG4gICAgLy8gY2hhbmdlIHAgZm9yIHJpdmVyYmVkIHdpdGggcmVzcGVjdCB0byBwLnpcXG4gICAgdmVjMyByaXZlcmJlZF9wID0gcCArIHZlYzMoc2luKHAueiAqIDAuMiksIDAuMCwgMC4wKTtcXG4gICAgZmxvYXQgcml2ZXJiZWQgPSBzZGZCb3gocml2ZXJiZWRfcCwgdmVjMygwLjAsIDAuMCwgMC4wKSwgdmVjMygxLjAsIDAuNSwgMTAwLjApKTtcXG4gICAgZ3JvdW5kID0gc2RmU3VidHJhY3Rpb25TbW9vdGgoZ3JvdW5kLCByaXZlcmJlZCwgMC41KTtcXG4gICAgZmxvYXQgcml2ZXJib2R5ID0gc2RmUml2ZXIocCk7XFxuXFxuICAgIGZsb2F0IGJpcmJfbW92ZSA9IDAuMDMgKiBzaW4oaVRpbWUgLyAyLjApO1xcbiAgICBmbG9hdCBiaXJiMSA9IHNkZkJvcmIocCwgdmVjMygwLjUsIC0wLjQgLSAwLjIgKyBiaXJiX21vdmUsIC0wLjY1ICsgMS4pLCAtODAuMCwgdHJ1ZSk7XFxuICAgIGZsb2F0IGJpcmIyID0gc2RmQm9yYihwLCB2ZWMzKC0wLjIsIC0wLjMgLSAwLjIgKyBiaXJiX21vdmUsIDAuMCArIDEuKSwgMTYwLjAsIHRydWUpO1xcbiAgICBmbG9hdCBiaXJiMyA9IHNkZkJvcmIocCwgdmVjMygwLjYsIC0wLjMgLSAwLjIgKyBiaXJiX21vdmUsIDAuNSArIDEuKSwgNDAuMCAsIHRydWUpO1xcblxcbiAgICBmbG9hdCBiYWNrZ3JvdW5kID0gc2RmQm94KHAsIHZlYzMoMC4wLCAwLjAsIDUwLjApLCB2ZWMzKDEwMC4wLCAxMDAuMCwgMS4wKSk7XFxuXFxuICAgIC8vIGZsb2F0IHN1bl9tb3ZlID0gZmxvYXQoaW50KGlUaW1lICogNjAuMCkgJSA2MDApIC8gMjQwLjA7XFxuICAgIGZsb2F0IHN1bl9tb3ZlID0gZ2V0U3luY2VkVGltZUN5Y2xlKCkgKiAzLjA7XFxuICAgIGZsb2F0IHN1biA9IHNkZlNwaGVyZShwLCB2ZWMzKDEuMCwgc3VuX21vdmUsIDUwLjApLCAyLjUpO1xcbiAgICBcXG4gICAgLy8gZmxvYXQgY2xvdWRfbW92ZSA9IDAuMiAqIHNpbihpVGltZSAvIDEuMCk7XFxuICAgIC8vIGZsb2F0IGNsb3VkMSA9IHNkZkNsb3VkKHAsIHZlYzMoLTEwLjAsIDEwLjAsIDIwLjApICsgdmVjMygwLjAsIGNsb3VkX21vdmUsIDAuMCkpO1xcbiAgICAvLyBmbG9hdCBjbG91ZDIgPSBzZGZDbG91ZChwLCB2ZWMzKC0xNS4wLCA0LjAsIDE1LjApICsgdmVjMygwLjAsIC1jbG91ZF9tb3ZlLCAwLjApKTtcXG4gICAgLy8gZmxvYXQgY2xvdWQzID0gc2RmQ2xvdWQocCwgdmVjMygxMi4wLCA1LjAsIDE3LjApICsgdmVjMygwLjAsIGNsb3VkX21vdmUsIDAuMCkpO1xcbiAgICAvLyBmbG9hdCBjbG91ZDQgPSBzZGZDbG91ZChwLCB2ZWMzKDMuMCwgMTAuMCwgMjAuMCkgKyB2ZWMzKDAuMCwgLWNsb3VkX21vdmUsIDAuMCkpO1xcbiAgICAvLyBmbG9hdCBjbG91ZDUgPSBzZGZDbG91ZChwLCB2ZWMzKDguMCwgMy4wLCAxNS4wKSArIHZlYzMoMC4wLCBjbG91ZF9tb3ZlLCAwLjApKTtcXG4gICAgLy8gZmxvYXQgY2xvdWQ2ID0gc2RmQ2xvdWQocCwgdmVjMygxMC4wLCA3LjAsIDMwLjApICsgdmVjMygwLjAsIC1jbG91ZF9tb3ZlLCAwLjApKTtcXG4gICAgLy8gZmxvYXQgY2xvdWQ3ID0gc2RmQ2xvdWQocCwgdmVjMygtMy4wLCA4LjAsIDQwLjApICsgdmVjMygwLjAsIGNsb3VkX21vdmUsIDAuMCkpO1xcbiAgICBmbG9hdCBjbG91ZCA9IHNkZkNsb3VkKHAsIHZlYzMoLTEwLjAsIDEwLjAsIDIwLjApICsgdmVjMygwLjAsIHN1bl9tb3ZlICogMC41LCAwLjApKTtcXG5cXG4gICAgLy8gQ29tYmluZSB0aGUgU0RGIGZvciBhbGwgb2JqZWN0c1xcbiAgICBmbG9hdCBvYmplY3RzW10gPSBmbG9hdFtdKFxcbiAgICAgICAgZ3JvdW5kLFxcbiAgICAgICAgYmlyYjEsXFxuICAgICAgICBiaXJiMiwgXFxuICAgICAgICBiaXJiMyxcXG4gICAgICAgIGJhY2tncm91bmQsXFxuICAgICAgICBzdW4sXFxuICAgICAgICBjbG91ZCxcXG4gICAgICAgIHJpdmVyYm9keVxcbiAgICApO1xcbiAgICAvLyBBc3NpZ24gb2JqZWN0IGlkcyBmb3IgY29sb3JpbmdcXG4gICAgaW50IG9iamVjdF9pZHNbXSA9IGludFtdKFxcbiAgICAgICAgMSxcXG4gICAgICAgIDIsXFxuICAgICAgICAzLCBcXG4gICAgICAgIDQsXFxuICAgICAgICA1LFxcbiAgICAgICAgNixcXG4gICAgICAgIDcsXFxuICAgICAgICA4XFxuICAgICk7XFxuICAgIHMgPSAxMDAwLjA7IC8vIHNldCBhIGxhcmdlIGluaXRpYWwgZGlzdGFuY2UgZm9yIHVuaW9uXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGgoKTsgaSsrKSB7XFxuICAgICAgICBzID0gc2RmVW5pb24ocywgb2JqZWN0c1tpXSk7XFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNsb3Nlc3Qgb2JqZWN0IGhpdFxcbiAgICAgICAgaWYgKHJlY29yZF9oaXQgJiYgcyA8IGhpdF9pZC5kaXN0KSB7XFxuICAgICAgICAgICAgaGl0X2lkLmRpc3QgPSBzO1xcbiAgICAgICAgICAgIGhpdF9pZC5pZCA9IG9iamVjdF9pZHNbaV07XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHM7XFxufVxcblxcbi8qKiBcXG4gKiBPdmVybG9hZCBzZGYyIHdpdGhvdXQgaGl0X2lkIHVwZGF0ZVxcbiAqIEUuZy4gd2UgZG9uJ3QgbmVlZCB0byBrbm93IHdoYXQgdGhlIG9iamVjdCBpcyBpbiBub3JtYWwgY2FsY3VsYXRpb25cXG4gKi9cXG5mbG9hdCBzZGYyKHZlYzMgcClcXG57XFxuICAgIGJvb2wgcmVjb3JkX2hpdCA9IHRydWU7IC8vIFRPRE86IFNob3VsZCBiZSBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGlmIEkgZGlzYWJsZSBoaXRfaWQgaW4gbm9ybWFsIGNhbGN1bGF0aW9uLCBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgd2lsbCBiZSBhcnRpZmFjdHMgaW4gcmVmbGVjdGlvbi4uLiBEb24ndCBrbm93IHdoeSB5ZXRcXG4gICAgcmV0dXJuIHNkZjIocCwgcmVjb3JkX2hpdCk7XFxufVxcblxcbi8vLy8gcmF5IG1hcmNoaW5nOiBvcmlnaW4gLSByYXkgb3JpZ2luOyBkaXIgLSByYXkgZGlyZWN0aW9uIFxcbmZsb2F0IHJheU1hcmNoaW5nMih2ZWMzIG9yaWdpbiwgdmVjMyBkaXIpXFxue1xcbiAgICBmbG9hdCBzID0gMC4wOyAvLyBkaXN0YW5jZVxcbiAgICBmb3IoaW50IGkgPSAwOyBpIDwgMTAwMDsgaSsrKVxcbiAgICB7XFxuICAgICAgICB2ZWMzIHAgPSBvcmlnaW4gKyBkaXIgKiBzO1xcbiAgICAgICAgZmxvYXQgZGlzdCA9IHNkZjIocCwgdHJ1ZSk7IC8vIHNkZiB2YWx1ZSBpbiBwXFxuICAgICAgICBzICs9IGRpc3Q7IC8vIHVwZGF0ZSB0aGUgZGlzdGFuY2VcXG4gICAgICAgIGlmIChzID4gMjAwLjAgfHwgYWJzKGRpc3QpIDwgMC4wMDAxKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgXFxuICAgIHJldHVybiBzO1xcbn1cXG5cXG4vLyBDbG91ZCBzaGFkZXJcXG57XFxuICAgIG1hdDMgbSA9IG1hdDMoIDAuMDAsICAwLjgwLCAgMC42MCxcXG4gICAgICAgICAgICAgICAgLTAuODAsICAwLjM2LCAtMC40OCxcXG4gICAgICAgICAgICAgICAgLTAuNjAsIC0wLjQ4LCAgMC42NCApO1xcbiAgICBmbG9hdCBoYXNoKCBmbG9hdCBuIClcXG4gICAge1xcbiAgICAgICAgcmV0dXJuIGZyYWN0KHNpbihuKSo0Mzc1OC41NDUzKTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBub2lzZSggaW4gdmVjMyB4IClcXG4gICAge1xcbiAgICAgICAgdmVjMyBwID0gZmxvb3IoeCk7XFxuICAgICAgICB2ZWMzIGYgPSBmcmFjdCh4KTtcXG5cXG4gICAgICAgIGYgPSBmKmYqKDMuMC0yLjAqZik7XFxuXFxuICAgICAgICBmbG9hdCBuID0gcC54ICsgcC55KjU3LjAgKyAxMTMuMCpwLno7XFxuXFxuICAgICAgICBmbG9hdCByZXMgPSBtaXgobWl4KG1peCggaGFzaChuKyAgMC4wKSwgaGFzaChuKyAgMS4wKSxmLngpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXgoIGhhc2gobisgNTcuMCksIGhhc2gobisgNTguMCksZi54KSxmLnkpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peChtaXgoIGhhc2gobisxMTMuMCksIGhhc2gobisxMTQuMCksZi54KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4KCBoYXNoKG4rMTcwLjApLCBoYXNoKG4rMTcxLjApLGYueCksZi55KSxmLnopO1xcbiAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgfVxcblxcbiAgICBmbG9hdCBmYm0oIHZlYzMgcCApXFxuICAgIHtcXG4gICAgICAgIGZsb2F0IGY7XFxuICAgICAgICBmICA9IDAuNTAwMCpub2lzZSggcCApOyBwID0gbSpwKjIuMDI7XFxuICAgICAgICBmICs9IDAuMjUwMCpub2lzZSggcCApOyBwID0gbSpwKjIuMDM7XFxuICAgICAgICBmICs9IDAuMTI1MDAqbm9pc2UoIHAgKTsgcCA9IG0qcCoyLjAxO1xcbiAgICAgICAgZiArPSAwLjA2MjUwKm5vaXNlKCBwICk7XFxuICAgICAgICByZXR1cm4gZjtcXG4gICAgfVxcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxuICAgIC8vIGlxJ3Mgc21pblxcbiAgICBmbG9hdCBzbWluKCBmbG9hdCBkMSwgZmxvYXQgZDIsIGZsb2F0IGsgKSB7XFxuICAgICAgICBmbG9hdCBoID0gY2xhbXAoIDAuNSArIDAuNSooZDItZDEpL2ssIDAuMCwgMS4wICk7XFxuICAgICAgICByZXR1cm4gbWl4KCBkMiwgZDEsIGggKSAtIGsqaCooMS4wLWgpOyB9XFxuXFxuICAgIGZsb2F0IHNkVG9ydXMoIHZlYzMgcCwgdmVjMiB0IClcXG4gICAge1xcbiAgICB2ZWMyIHEgPSB2ZWMyKGxlbmd0aChwLnh6KS10LngscC55KTtcXG4gICAgcmV0dXJuIGxlbmd0aChxKS10Lnk7XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgbWFwKCBpbiB2ZWMzIHAgKVxcbiAgICB7XFxuICAgICAgICBwICo9IDIuMDtcXG4gICAgICAgIHZlYzMgcSA9IHAgLSB2ZWMzKDAuMCwwLjUsMS4wKSppVGltZTtcXG4gICAgICAgIGZsb2F0IGYgPSBmYm0ocSk7XFxuICAgICAgICBmbG9hdCB0b3J1cyA9IDEuIC0gc2RUb3J1cyhwICogMi4wLCB2ZWMyKDYuMCwgMC4wMDUpKSArIGYgKiAzLjU7XFxuXFxuICAgICAgICByZXR1cm4gbWluKG1heCgwLjAsIHRvcnVzKSwgMS4wKTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBqaXR0ZXI7XFxuXFxuICAgICNkZWZpbmUgTUFYX1NURVBTIDQ4XFxuICAgICNkZWZpbmUgU0hBRE9XX1NURVBTIDhcXG4gICAgI2RlZmluZSBWT0xVTUVfTEVOR1RIIDE1LlxcbiAgICAjZGVmaW5lIFNIQURPV19MRU5HVEggMi5cXG5cXG4gICAgLy8gUmVmZXJlbmNlXFxuICAgIC8vIGh0dHBzOi8vc2hhZGVyYml0cy5jb20vYmxvZy9jcmVhdGluZy12b2x1bWV0cmljLXJheS1tYXJjaGVyXFxuICAgIHZlYzQgY2xvdWRNYXJjaCh2ZWMzIHAsIHZlYzMgcmF5KVxcbiAgICB7XFxuICAgICAgICBmbG9hdCBkZW5zaXR5ID0gMC47XFxuXFxuICAgICAgICBmbG9hdCBzdGVwTGVuZ3RoID0gVk9MVU1FX0xFTkdUSCAvIGZsb2F0KE1BWF9TVEVQUyk7XFxuICAgICAgICBmbG9hdCBzaGFkb3dTdGVwTGVuZ3RoID0gU0hBRE9XX0xFTkdUSCAvIGZsb2F0KFNIQURPV19TVEVQUyk7XFxuICAgICAgICB2ZWMzIGxpZ2h0ID0gbm9ybWFsaXplKHZlYzMoMS4wLCAyLjAsIDEuMCkpO1xcblxcbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG4gICAgICAgIFxcbiAgICAgICAgdmVjMyBwb3MgPSBwICsgcmF5ICogaml0dGVyICogc3RlcExlbmd0aDtcXG4gICAgICAgIFxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfU1RFUFM7IGkrKylcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBpZiAoc3VtLmEgPCAwLjEpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZsb2F0IGQgPSBtYXAocG9zKTtcXG4gICAgICAgIFxcbiAgICAgICAgICAgIGlmKCBkID4gMC4wMDEpXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICB2ZWMzIGxwb3MgPSBwb3MgKyBsaWdodCAqIGppdHRlciAqIHNoYWRvd1N0ZXBMZW5ndGg7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHNoYWRvdyA9IDAuO1xcbiAgICAgICAgXFxuICAgICAgICAgICAgICAgIGZvciAoaW50IHMgPSAwOyBzIDwgU0hBRE9XX1NURVBTOyBzKyspXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIGxwb3MgKz0gbGlnaHQgKiBzaGFkb3dTdGVwTGVuZ3RoO1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbHNhbXBsZSA9IG1hcChscG9zKTtcXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvdyArPSBsc2FtcGxlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgICAgICAgICAgZGVuc2l0eSA9IGNsYW1wKChkIC8gZmxvYXQoTUFYX1NURVBTKSkgKiAyMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBleHAoKC1zaGFkb3cgLyBmbG9hdChTSEFET1dfU1RFUFMpKSAqIDMuKTtcXG4gICAgICAgICAgICAgICAgc3VtLnJnYiArPSB2ZWMzKHMgKiBkZW5zaXR5KSAqIHZlYzMoMS4xLCAwLjksIC41KSAqIHN1bS5hO1xcbiAgICAgICAgICAgICAgICBzdW0uYSAqPSAxLi1kZW5zaXR5O1xcblxcbiAgICAgICAgICAgICAgICBzdW0ucmdiICs9IGV4cCgtbWFwKHBvcyArIHZlYzMoMCwwLjI1LDAuMCkpICogLjIpICogZGVuc2l0eSAqIHZlYzMoMC4xNSwgMC40NSwgMS4xKSAqIHN1bS5hO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwb3MgKz0gcmF5ICogc3RlcExlbmd0aDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBzdW07XFxuICAgIH1cXG59XFxuXFxuLyoqXFxuICogTm9ybWFsIGNhbGN1bGF0aW9uIGZvciBTREYyIFNjZW5lXFxuICogQHBhcmFtIHA6IGludGVyc2VjdGlvbiBwb2ludCBxdWVyeVxcbiAqIEByZXR1cm4gbm9ybTogbm9ybWFsIGF0IHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcXG4gKi9cXG52ZWMzIG5vcm1hbDIodmVjMyBwKVxcbntcXG4gICAgZmxvYXQgcyA9IHNkZjIocCk7IC8vIHNkZiB2YWx1ZSBpbiBwXFxuICAgIGZsb2F0IGR4ID0gMC4wMTE7IC8vIENhbid0IGdldCBzbWFsbGVyIHRoYW4gdGhpcy4uIFxcbiAgICAgICAgICAgICAgICAgICAgICAvLyAwLjAxMCB3aWxsIHByb2R1Y2Ugd2lyZWQgYXJ0aWZhY3RzIGluIHJlZmxlY3Rpb24uLi4gRG9uJ3Qga25vdyB3aHkgeWV0XFxuXFxuICAgIHZlYzMgbm9ybSA9IHZlYzMoXFxuICAgICAgICBzZGYyKHAgKyB2ZWMzKGR4LCAwLjAsIDAuMCkpIC0gcywgLy8gZHN4XFxuICAgICAgICBzZGYyKHAgKyB2ZWMzKDAuMCwgZHgsIDAuMCkpIC0gcywgLy8gZHN5XFxuICAgICAgICBzZGYyKHAgKyB2ZWMzKDAuMCwgMC4wLCBkeCkpIC0gcyAgLy8gZHN6XFxuICAgICk7XFxuICAgIHJldHVybiBub3JtYWxpemUobm9ybSk7XFxufVxcblxcbi8qKlxcbiAqIEEgQ29weSBvZiBwaG9uZ19zaGFkaW5nMiBmb3IgaGFuZGxpbmcgcmVmbGVjdGlvbi5cXG4gKiBCZWNhdXNlIEdMU0wgZG9lcyBub3Qgc3VwcG9ydCByZWN1cnNpdmUgZnVuY3Rpb24gY2FsbHMuXFxuICogVGhpcyBpcyB3aXRoIGZ1cnRoZXIgcmVmbGVjdGlvbiBwYXJ0IHJlbW92ZWQgYmVjYXVzZSB3ZSBqdXN0IG5lZWQgb25lIGJvdW5jZS5cXG4gKi9cXG52ZWMzIHBob25nX3NoYWRpbmdfcmVmbGVjdGlvbih2ZWMzIHAsIHZlYzMgbiwgdmVjMyByYXlfZGlyLCB2ZWMzIG9yaWdpbilcXG57XFxuICAgIC8vLy8gcGhvbmcgc2hhZGluZ1xcbiAgICBmbG9hdCB0ID0gZ2V0U3luY2VkVGltZUN5Y2xlKCkgKiAzLjA7XFxuICAgIGZsb2F0IGJyaWdodG5lc3Nfc2NhbGUgPSAwLjYgKyAwLjIwICogdDsgLy8gU3VuIHJpc2Ugc2ltdWxhdGlvblxcbiAgICB2ZWMzIGxpZ2h0UG9zID0gdmVjMygxLjAsIHQgKyA1LjAsIDMwLjApO1xcbiAgICB2ZWMzIGxpZ2h0X2NvbG9yID0gdmVjMygwLjgyLCAwLjY3LCAwLjU4KSAqIDEuMjtcXG4gICAgdmVjMyBsID0gbm9ybWFsaXplKGxpZ2h0UG9zIC0gcCk7ICAgICAgICAgICAgICAgXFxuICAgIGZsb2F0IGFtYiA9IDAuMztcXG4gICAgZmxvYXQgZGlmID0gbWF4KGRvdChuLCBsKSwgMC4pICogMC42O1xcbiAgICB2ZWMzIGV5ZSA9IG9yaWdpbjtcXG4gICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KHJlZmxlY3QoLWwsIG4pLCBub3JtYWxpemUoZXllIC0gcCkpLCAwLjApLCAxMjguMCkgKiAwLjc7XFxuXFxuICAgIHZlYzMgc3VuRGlyID0gdmVjMygwLCAxLCAtMSk7XFxuICAgIGZsb2F0IHN1bkRpZiA9IG1heChkb3Qobiwgc3VuRGlyKSwgMC4pICogMC4yO1xcblxcbiAgICAvLy8vIENvbG9yaW5nXFxuICAgIGZsb2F0IGJpcmJfYnJpZ2h0bmVzcyA9IDEuMjtcXG4gICAgdmVjMyBjb2xvciA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgIHN3aXRjaCAoaGl0X2lkLmlkKSB7XFxuICAgICAgICBjYXNlIDE6IC8vIEdyb3VuZFxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjApICogMS4xO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAyOiAvLyBCaXJiIDFcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMS4wLCAwLjg5LCAwLjk3KSAqIGJpcmJfYnJpZ2h0bmVzcztcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgMzogLy8gQmlyYiAyXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDEuMCwgMC42MSwgMC43OCkgKiBiaXJiX2JyaWdodG5lc3M7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIDQ6IC8vIEJpcmIgM1xcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygwLjk5LCAwLjc5LCAwLjY4KSAqIGJpcmJfYnJpZ2h0bmVzcztcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgNTogLy8gQmFja2dyb3VuZCBTa3lcXG4gICAgICAgICAgICB2ZWMzIGNvbG9yMSA9IHZlYzMoMC43NywgMC42NywgMC41Myk7XFxuICAgICAgICAgICAgdmVjMyBjb2xvcjIgPSB2ZWMzKDEuMCwgMC4yNSwgMC45OCk7XFxuICAgICAgICAgICAgY29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIChwLnkgKyA1LjApIC8gMTAwLjApICogYnJpZ2h0bmVzc19zY2FsZTtcXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XFxuICAgICAgICBjYXNlIDY6IC8vIFN1blxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjAsIDAuMjksIDAuMDkpO1xcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcXG4gICAgICAgIGNhc2UgNzogLy8gQ2xvdWRcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMS4wKTtcXG4gICAgICAgICAgICByZXR1cm4gKGFtYiArIHN1bkRpZiArIDAuMikgKiBjb2xvciAqIGxpZ2h0X2NvbG9yICogYnJpZ2h0bmVzc19zY2FsZTtcXG4gICAgICAgIGNhc2UgODogLy8gUml2ZXJcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMC43OSwgMC44OSwgMS4wKTtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGRlZmF1bHQ6IC8vIFVuZXhwZWN0ZWQgaGl0X2lkIHZhbHVlc1xcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygwLjAsIDAuMTgsIDEuMCk7IC8vIEJsdWUgZm9yIGRlYnVnZ2luZyByZWZsZWN0aW9uXFxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xcbiAgICB9XFxuXFxuICAgIC8vLy8gc2hhZG93XFxuICAgIGZsb2F0IHMgPSByYXlNYXJjaGluZzIocCArIG4gKiAwLjAyLCBsKTtcXG4gICAgaWYocyA8IGxlbmd0aChsaWdodFBvcyAtIHApKSBkaWYgKj0gLjI7IC8vIHNoYWRvd1xcblxcbiAgICAvLy8vIEJhbGFuY2UgdGhlIGNvbG9yIG9mIHRoZSBzY2VuZVxcbiAgICBmbG9hdCBmb2cgPSAxLjAgLSBleHAoLTAuMDMgKiBwLnopO1xcbiAgICB2ZWMzIGZvZ19jb2xvciA9IHZlYzMoMC41KTtcXG4gICAgY29sb3IgPSBtaXgoY29sb3IsIGZvZ19jb2xvciwgZm9nKTtcXG5cXG4gICAgcmV0dXJuIChhbWIgKyBkaWYgKyBzcGVjICsgc3VuRGlmKSAqIGJyaWdodG5lc3Nfc2NhbGUgKiBjb2xvciAqIGxpZ2h0X2NvbG9yO1xcbn1cXG5cXG4vKipcXG4gKiBQaG9uZyBTaGFkaW5nIGZvciBTREYyIFNjZW5lXFxuICogQHBhcmFtIHA6IGludGVyc2VjdGlvbiBwb2ludFxcbiAqIEBwYXJhbSBuOiBub3JtYWwgYXQgdGhlIGludGVyc2VjdGlvbiBwb2ludFxcbiAqIEBwYXJhbSByYXlfZGlyOiByYXkgZGlyZWN0aW9uXFxuICogQHBhcmFtIG9yaWdpbjogY2FtZXJhIHBvc2l0aW9uXFxuICogQHJldHVybiBjb2xvcjogcGhvbmcgc2hhZGluZyBjb2xvclxcbiAqXFxuICogTm90ZTogQW55IGNoYW5nZXMgdG8gdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY29waWVkIHRvIHBob25nX3NoYWRpbmdfcmVmbGVjdGlvblxcbiAqL1xcbnZlYzMgcGhvbmdfc2hhZGluZzIodmVjMyBwLCB2ZWMzIG4sIHZlYzMgcmF5X2RpciwgdmVjMyBvcmlnaW4pXFxue1xcbiAgICAvLy8vIHBob25nIHNoYWRpbmdcXG4gICAgZmxvYXQgdCA9IGdldFN5bmNlZFRpbWVDeWNsZSgpICogMy4wO1xcbiAgICBmbG9hdCBicmlnaHRuZXNzX3NjYWxlID0gMC42ICsgMC4yMCAqIHQ7IC8vIFN1biByaXNlIHNpbXVsYXRpb25cXG4gICAgdmVjMyBsaWdodFBvcyA9IHZlYzMoMS4wLCB0ICsgNS4wLCAzMC4wKTtcXG4gICAgdmVjMyBsaWdodF9jb2xvciA9IHZlYzMoMC44MiwgMC42NywgMC41OCkgKiAxLjI7XFxuICAgIHZlYzMgbCA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIHApOyAgICAgICAgICAgICAgIFxcbiAgICBmbG9hdCBhbWIgPSAwLjM7XFxuICAgIGZsb2F0IGRpZiA9IG1heChkb3QobiwgbCksIDAuKSAqIDAuNjtcXG4gICAgdmVjMyBleWUgPSBvcmlnaW47XFxuICAgIGZsb2F0IHNwZWMgPSBwb3cobWF4KGRvdChyZWZsZWN0KC1sLCBuKSwgbm9ybWFsaXplKGV5ZSAtIHApKSwgMC4wKSwgMTI4LjApICogMC43O1xcblxcbiAgICB2ZWMzIHN1bkRpciA9IHZlYzMoMCwgMSwgLTEpO1xcbiAgICBmbG9hdCBzdW5EaWYgPSBtYXgoZG90KG4sIHN1bkRpciksIDAuKSAqIDAuMjtcXG5cXG4gICAgLy8vLyBDbG91ZCBtYXJjaGluZ1xcbiAgICB2ZWM0IGNsb3VkX2NvbG9yID0gY2xvdWRNYXJjaChwLCByYXlfZGlyKTtcXG4gICAgaWYgKGhpdF9pZC5pZCA9PSA3KSB7XFxuICAgICAgICByZXR1cm4gY2xvdWRfY29sb3IucmdiICogbGlnaHRfY29sb3IgKiBicmlnaHRuZXNzX3NjYWxlO1xcbiAgICB9XFxuXFxuICAgIC8vLy8gQ29sb3JpbmdcXG4gICAgZmxvYXQgYmlyYl9icmlnaHRuZXNzID0gMS4yO1xcbiAgICB2ZWMzIGNvbG9yID0gdmVjMygxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgc3dpdGNoIChoaXRfaWQuaWQpIHtcXG4gICAgICAgIGNhc2UgMTogLy8gR3JvdW5kXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDEuMCkgKiAxLjE7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIDI6IC8vIEJpcmIgMVxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjAsIDAuODksIDAuOTcpICogYmlyYl9icmlnaHRuZXNzO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAzOiAvLyBCaXJiIDJcXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoMS4wLCAwLjYxLCAwLjc4KSAqIGJpcmJfYnJpZ2h0bmVzcztcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgNDogLy8gQmlyYiAzXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDAuOTksIDAuNzksIDAuNjgpICogYmlyYl9icmlnaHRuZXNzO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSA1OiAvLyBCYWNrZ3JvdW5kIFNreVxcbiAgICAgICAgICAgIHZlYzMgY29sb3IxID0gdmVjMygwLjc3LCAwLjY3LCAwLjUzKTtcXG4gICAgICAgICAgICB2ZWMzIGNvbG9yMiA9IHZlYzMoMS4wLCAwLjI1LCAwLjk4KTtcXG4gICAgICAgICAgICBjb2xvciA9IG1peChjb2xvcjEsIGNvbG9yMiwgKHAueSArIDUuMCkgLyAxMDAuMCkgKiBicmlnaHRuZXNzX3NjYWxlO1xcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcXG4gICAgICAgIGNhc2UgNjogLy8gU3VuXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDEuMCwgMC4yOSwgMC4wOSk7XFxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xcbiAgICAgICAgY2FzZSA3OiAvLyBDbG91ZFxcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLjApO1xcbiAgICAgICAgICAgIHJldHVybiAoYW1iICsgc3VuRGlmICsgMC4yKSAqIGNvbG9yICogbGlnaHRfY29sb3IgKiBicmlnaHRuZXNzX3NjYWxlO1xcbiAgICAgICAgICAgIC8vIGJyZWFrO1xcbiAgICAgICAgY2FzZSA4OiAvLyBSaXZlclxcbiAgICAgICAgICAgIHZlYzMgd2F0ZXJfY29sb3IgPSB2ZWMzKDAuNzksIDAuODksIDEuMCk7XFxuICAgICAgICAgICAgLy8gUmVmbGVjdGlvbiBvbiB3YXRlclxcbiAgICAgICAgICAgIHZlYzMgcmVmbGVjdF9kaXIgPSByZWZsZWN0KHJheV9kaXIsIG4pO1xcbiAgICAgICAgICAgIGZsb2F0IHJlZmxlY3RfcyA9IHJheU1hcmNoaW5nMihwICsgbiAqIDAuMDEsIHJlZmxlY3RfZGlyKTtcXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlZmxlY3Rpb24gY29sb3JcXG4gICAgICAgICAgICB2ZWMzIHJlZmxlY3RfcCA9IHAgKyByZWZsZWN0X2RpciAqIHJlZmxlY3RfcztcXG4gICAgICAgICAgICB2ZWMzIHJlZmxlY3RfbiA9IG5vcm1hbDIocmVmbGVjdF9wKTtcXG4gICAgICAgICAgICB2ZWMzIHJlZmxlY3RfY29sb3IgPSBwaG9uZ19zaGFkaW5nX3JlZmxlY3Rpb24ocmVmbGVjdF9wLCByZWZsZWN0X24sIHJlZmxlY3RfZGlyLCBwKTtcXG4gICAgICAgICAgICByZXR1cm4gcmVmbGVjdF9jb2xvciAqIHdhdGVyX2NvbG9yICogMC45O1xcblxcbiAgICAgICAgZGVmYXVsdDogLy8gVW5leHBlY3RlZCBoaXRfaWQgdmFsdWVzXFxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKDAuMTMsIDEuMCwgMC4wKTsgLy8gR3JlZW4gZm9yIGRlYnVnZ2luZ1xcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcXG4gICAgfVxcblxcbiAgICAvLy8vIHNoYWRvd1xcbiAgICBmbG9hdCBzID0gcmF5TWFyY2hpbmcyKHAgKyBuICogMC4wMiwgbCk7XFxuICAgIGlmKHMgPCBsZW5ndGgobGlnaHRQb3MgLSBwKSkgZGlmICo9IC4yO1xcblxcbiAgICAvLy8vIEJhbGFuY2UgdGhlIGNvbG9yIG9mIHRoZSBzY2VuZVxcbiAgICBmbG9hdCBmb2cgPSAxLjAgLSBleHAoLTAuMDMgKiBwLnopO1xcbiAgICB2ZWMzIGZvZ19jb2xvciA9IHZlYzMoMC41KTtcXG4gICAgY29sb3IgPSBtaXgoY29sb3IsIGZvZ19jb2xvciwgZm9nKTtcXG5cXG4gICAgcmV0dXJuIChhbWIgKyBkaWYgKyBzcGVjICsgc3VuRGlmKSAqIGJyaWdodG5lc3Nfc2NhbGUgKiBjb2xvciAqIGxpZ2h0X2NvbG9yO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vLy8gbWFpbiBmdW5jdGlvblxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxudm9pZCBtYWluSW1hZ2UyKG91dCB2ZWM0IGZyYWdDb2xvciwgaW4gdmVjMiBmcmFnQ29vcmQpXFxue1xcbiAgICB2ZWMyIHV2ID0gKGZyYWdDb29yZC54eSAtIC41ICogaVJlc29sdXRpb24ueHkpIC8gaVJlc29sdXRpb24ueTsgICAgICAgICAgIC8vLy8gc2NyZWVuIHV2XFxuICAgIFxcbiAgICBmbG9hdCBjYW1fbW92ZSA9IGdldFN5bmNlZFRpbWVDeWNsZSgpO1xcbiAgICB2ZWMzIG9yaWdpbiA9IENBTV9QT1MgKyB2ZWMzKDAuMCwgLTAuNSwgMS41KSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgdmVjMygwLjAsIGNhbV9tb3ZlICogMC4zLCAtY2FtX21vdmUgKiAyLjApOyAgICAgICAgICAvLy8vIGNhbWVyYSBwb3NpdGlvbiBcXG4gICAgLy8gdmVjMyBvcmlnaW4gPSBDQU1fUE9TOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vIGNhbWVyYSBwb3NpdGlvblxcbiAgICB2ZWMzIGRpciA9IG5vcm1hbGl6ZSh2ZWMzKHV2LngsIHV2LnksIDEpKTsgICAgICAgICAgICAgICAgICAvLy8vIGNhbWVyYSBkaXJlY3Rpb25cXG4gICAgZmxvYXQgcyA9IHJheU1hcmNoaW5nMihvcmlnaW4sIGRpcik7ICAgICAgICAgICAgICAgICAgICAgLy8vLyByYXkgbWFyY2hpbmdcXG4gICAgdmVjMyBwID0gb3JpZ2luICsgZGlyICogczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gcmF5LXNkZiBpbnRlcnNlY3Rpb25cXG4gICAgdmVjMyBuID0gbm9ybWFsMihwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gc2RmIG5vcm1hbFxcbiAgICBcXG4gICAgLy8gLy8gaWYgb2JqZWN0SUQgaXMgY2xvdWQsIHVzZSBjbG91ZCBtYXJjaGluZ1xcbiAgICAvLyBpZiAoaGl0X2lkLmlkID09IDcpIHtcXG4gICAgLy8gICAgIGZyYWdDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTsgLy8gV2hpdGUgZm9yIGNsb3VkXFxuICAgIC8vICAgICByZXR1cm47XFxuICAgIC8vIH1cXG5cXG4gICAgaml0dGVyID0gMS4wO1xcbiAgICBcXG4gICAgdmVjMyBjb2xvciA9IHBob25nX3NoYWRpbmcyKHAsIG4sIGRpciwgb3JpZ2luKTsgICAgLy8vLyBwaG9uZyBzaGFkaW5nXFxuICAgIGZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBmcmFnbWVudCBjb2xvclxcbn1cXG5cXG52b2lkIG1haW4oKSBcXG57XFxuICAgIG1haW5JbWFnZTIoZ2xfRnJhZ0NvbG9yLCBnbF9GcmFnQ29vcmQueHkpO1xcbn1cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(assignment)/assignment/A1a/fragment.glsl\n"));

/***/ })

});